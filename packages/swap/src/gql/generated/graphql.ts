/* eslint-disable */
import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /** A floating point number that requires more precision than IEEE 754 binary 64 */
  BigFloat: { input: any; output: any; }
  /**
   * A signed eight-byte integer. The upper big integer values are greater than the
   * max value for a JavaScript number. Therefore all big integers will be output as
   * strings and not numbers.
   */
  BigInt: { input: any; output: any; }
  /** A location in a connection that can be used for resuming pagination. */
  Cursor: { input: any; output: any; }
  /**
   * A point in time as described by the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
   */
  Datetime: { input: any; output: any; }
  /** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
  JSON: { input: any; output: any; }
};

export type AcalaEvmExecuted = Node & {
  __typename?: 'AcalaEvmExecuted';
  contract: Scalars['String']['output'];
  /** Reads a single `Event` that is related to this `AcalaEvmExecuted`. */
  eventByEventId: Event;
  eventId: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

export type AcalaEvmExecutedAggregates = {
  __typename?: 'AcalaEvmExecutedAggregates';
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<AcalaEvmExecutedDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/**
 * A condition to be used against `AcalaEvmExecuted` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type AcalaEvmExecutedCondition = {
  /** Checks for equality with the object’s `contract` field. */
  contract?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `eventId` field. */
  eventId?: InputMaybe<Scalars['String']['input']>;
};

export type AcalaEvmExecutedDistinctCountAggregates = {
  __typename?: 'AcalaEvmExecutedDistinctCountAggregates';
  /** Distinct count of contract across the matching connection */
  contract?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of eventId across the matching connection */
  eventId?: Maybe<Scalars['BigInt']['output']>;
};

export type AcalaEvmExecutedFailed = Node & {
  __typename?: 'AcalaEvmExecutedFailed';
  contract: Scalars['String']['output'];
  /** Reads a single `Event` that is related to this `AcalaEvmExecutedFailed`. */
  eventByEventId: Event;
  eventId: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

export type AcalaEvmExecutedFailedAggregates = {
  __typename?: 'AcalaEvmExecutedFailedAggregates';
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<AcalaEvmExecutedFailedDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/**
 * A condition to be used against `AcalaEvmExecutedFailed` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type AcalaEvmExecutedFailedCondition = {
  /** Checks for equality with the object’s `contract` field. */
  contract?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `eventId` field. */
  eventId?: InputMaybe<Scalars['String']['input']>;
};

export type AcalaEvmExecutedFailedDistinctCountAggregates = {
  __typename?: 'AcalaEvmExecutedFailedDistinctCountAggregates';
  /** Distinct count of contract across the matching connection */
  contract?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of eventId across the matching connection */
  eventId?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `AcalaEvmExecutedFailed` object types. All fields are combined with a logical ‘and.’ */
export type AcalaEvmExecutedFailedFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AcalaEvmExecutedFailedFilter>>;
  /** Filter by the object’s `contract` field. */
  contract?: InputMaybe<StringFilter>;
  /** Filter by the object’s `eventId` field. */
  eventId?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AcalaEvmExecutedFailedFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AcalaEvmExecutedFailedFilter>>;
};

/** Grouping methods for `AcalaEvmExecutedFailed` for usage during aggregation. */
export type AcalaEvmExecutedFailedGroupBy =
  | 'CONTRACT';

/** Conditions for `AcalaEvmExecutedFailed` aggregates. */
export type AcalaEvmExecutedFailedHavingInput = {
  AND?: InputMaybe<Array<AcalaEvmExecutedFailedHavingInput>>;
  OR?: InputMaybe<Array<AcalaEvmExecutedFailedHavingInput>>;
};

export type AcalaEvmExecutedFailedLog = Node & {
  __typename?: 'AcalaEvmExecutedFailedLog';
  contract: Scalars['String']['output'];
  /** Reads a single `Event` that is related to this `AcalaEvmExecutedFailedLog`. */
  eventByEventId: Event;
  eventContract: Scalars['String']['output'];
  eventId: Scalars['String']['output'];
  id: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  topic0?: Maybe<Scalars['String']['output']>;
  topic1?: Maybe<Scalars['String']['output']>;
  topic2?: Maybe<Scalars['String']['output']>;
  topic3?: Maybe<Scalars['String']['output']>;
};

export type AcalaEvmExecutedFailedLogAggregates = {
  __typename?: 'AcalaEvmExecutedFailedLogAggregates';
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<AcalaEvmExecutedFailedLogDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/**
 * A condition to be used against `AcalaEvmExecutedFailedLog` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type AcalaEvmExecutedFailedLogCondition = {
  /** Checks for equality with the object’s `contract` field. */
  contract?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `eventContract` field. */
  eventContract?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `eventId` field. */
  eventId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `topic0` field. */
  topic0?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `topic1` field. */
  topic1?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `topic2` field. */
  topic2?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `topic3` field. */
  topic3?: InputMaybe<Scalars['String']['input']>;
};

export type AcalaEvmExecutedFailedLogDistinctCountAggregates = {
  __typename?: 'AcalaEvmExecutedFailedLogDistinctCountAggregates';
  /** Distinct count of contract across the matching connection */
  contract?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of eventContract across the matching connection */
  eventContract?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of eventId across the matching connection */
  eventId?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of id across the matching connection */
  id?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of topic0 across the matching connection */
  topic0?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of topic1 across the matching connection */
  topic1?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of topic2 across the matching connection */
  topic2?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of topic3 across the matching connection */
  topic3?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `AcalaEvmExecutedFailedLog` object types. All fields are combined with a logical ‘and.’ */
export type AcalaEvmExecutedFailedLogFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AcalaEvmExecutedFailedLogFilter>>;
  /** Filter by the object’s `contract` field. */
  contract?: InputMaybe<StringFilter>;
  /** Filter by the object’s `eventContract` field. */
  eventContract?: InputMaybe<StringFilter>;
  /** Filter by the object’s `eventId` field. */
  eventId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AcalaEvmExecutedFailedLogFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AcalaEvmExecutedFailedLogFilter>>;
  /** Filter by the object’s `topic0` field. */
  topic0?: InputMaybe<StringFilter>;
  /** Filter by the object’s `topic1` field. */
  topic1?: InputMaybe<StringFilter>;
  /** Filter by the object’s `topic2` field. */
  topic2?: InputMaybe<StringFilter>;
  /** Filter by the object’s `topic3` field. */
  topic3?: InputMaybe<StringFilter>;
};

/** Grouping methods for `AcalaEvmExecutedFailedLog` for usage during aggregation. */
export type AcalaEvmExecutedFailedLogGroupBy =
  | 'CONTRACT'
  | 'EVENT_CONTRACT'
  | 'EVENT_ID'
  | 'TOPIC0'
  | 'TOPIC1'
  | 'TOPIC2'
  | 'TOPIC3';

/** Conditions for `AcalaEvmExecutedFailedLog` aggregates. */
export type AcalaEvmExecutedFailedLogHavingInput = {
  AND?: InputMaybe<Array<AcalaEvmExecutedFailedLogHavingInput>>;
  OR?: InputMaybe<Array<AcalaEvmExecutedFailedLogHavingInput>>;
};

/** A connection to a list of `AcalaEvmExecutedFailedLog` values. */
export type AcalaEvmExecutedFailedLogsConnection = {
  __typename?: 'AcalaEvmExecutedFailedLogsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AcalaEvmExecutedFailedLogAggregates>;
  /** A list of edges which contains the `AcalaEvmExecutedFailedLog` and cursor to aid in pagination. */
  edges: Array<AcalaEvmExecutedFailedLogsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AcalaEvmExecutedFailedLogAggregates>>;
  /** A list of `AcalaEvmExecutedFailedLog` objects. */
  nodes: Array<AcalaEvmExecutedFailedLog>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AcalaEvmExecutedFailedLog` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `AcalaEvmExecutedFailedLog` values. */
export type AcalaEvmExecutedFailedLogsConnectionGroupedAggregatesArgs = {
  groupBy: Array<AcalaEvmExecutedFailedLogGroupBy>;
  having?: InputMaybe<AcalaEvmExecutedFailedLogHavingInput>;
};

/** A `AcalaEvmExecutedFailedLog` edge in the connection. */
export type AcalaEvmExecutedFailedLogsEdge = {
  __typename?: 'AcalaEvmExecutedFailedLogsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AcalaEvmExecutedFailedLog` at the end of the edge. */
  node: AcalaEvmExecutedFailedLog;
};

/** Methods to use when ordering `AcalaEvmExecutedFailedLog`. */
export type AcalaEvmExecutedFailedLogsOrderBy =
  | 'CONTRACT_ASC'
  | 'CONTRACT_DESC'
  | 'EVENT_CONTRACT_ASC'
  | 'EVENT_CONTRACT_DESC'
  | 'EVENT_ID_ASC'
  | 'EVENT_ID_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TOPIC0_ASC'
  | 'TOPIC0_DESC'
  | 'TOPIC1_ASC'
  | 'TOPIC1_DESC'
  | 'TOPIC2_ASC'
  | 'TOPIC2_DESC'
  | 'TOPIC3_ASC'
  | 'TOPIC3_DESC';

/** A connection to a list of `AcalaEvmExecutedFailed` values. */
export type AcalaEvmExecutedFailedsConnection = {
  __typename?: 'AcalaEvmExecutedFailedsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AcalaEvmExecutedFailedAggregates>;
  /** A list of edges which contains the `AcalaEvmExecutedFailed` and cursor to aid in pagination. */
  edges: Array<AcalaEvmExecutedFailedsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AcalaEvmExecutedFailedAggregates>>;
  /** A list of `AcalaEvmExecutedFailed` objects. */
  nodes: Array<AcalaEvmExecutedFailed>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AcalaEvmExecutedFailed` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `AcalaEvmExecutedFailed` values. */
export type AcalaEvmExecutedFailedsConnectionGroupedAggregatesArgs = {
  groupBy: Array<AcalaEvmExecutedFailedGroupBy>;
  having?: InputMaybe<AcalaEvmExecutedFailedHavingInput>;
};

/** A `AcalaEvmExecutedFailed` edge in the connection. */
export type AcalaEvmExecutedFailedsEdge = {
  __typename?: 'AcalaEvmExecutedFailedsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AcalaEvmExecutedFailed` at the end of the edge. */
  node: AcalaEvmExecutedFailed;
};

/** Methods to use when ordering `AcalaEvmExecutedFailed`. */
export type AcalaEvmExecutedFailedsOrderBy =
  | 'CONTRACT_ASC'
  | 'CONTRACT_DESC'
  | 'EVENT_ID_ASC'
  | 'EVENT_ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A filter to be used against `AcalaEvmExecuted` object types. All fields are combined with a logical ‘and.’ */
export type AcalaEvmExecutedFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AcalaEvmExecutedFilter>>;
  /** Filter by the object’s `contract` field. */
  contract?: InputMaybe<StringFilter>;
  /** Filter by the object’s `eventId` field. */
  eventId?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AcalaEvmExecutedFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AcalaEvmExecutedFilter>>;
};

/** Grouping methods for `AcalaEvmExecuted` for usage during aggregation. */
export type AcalaEvmExecutedGroupBy =
  | 'CONTRACT';

/** Conditions for `AcalaEvmExecuted` aggregates. */
export type AcalaEvmExecutedHavingInput = {
  AND?: InputMaybe<Array<AcalaEvmExecutedHavingInput>>;
  OR?: InputMaybe<Array<AcalaEvmExecutedHavingInput>>;
};

export type AcalaEvmExecutedLog = Node & {
  __typename?: 'AcalaEvmExecutedLog';
  contract: Scalars['String']['output'];
  /** Reads a single `Event` that is related to this `AcalaEvmExecutedLog`. */
  eventByEventId: Event;
  eventContract: Scalars['String']['output'];
  eventId: Scalars['String']['output'];
  id: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  topic0?: Maybe<Scalars['String']['output']>;
  topic1?: Maybe<Scalars['String']['output']>;
  topic2?: Maybe<Scalars['String']['output']>;
  topic3?: Maybe<Scalars['String']['output']>;
};

export type AcalaEvmExecutedLogAggregates = {
  __typename?: 'AcalaEvmExecutedLogAggregates';
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<AcalaEvmExecutedLogDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/**
 * A condition to be used against `AcalaEvmExecutedLog` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type AcalaEvmExecutedLogCondition = {
  /** Checks for equality with the object’s `contract` field. */
  contract?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `eventContract` field. */
  eventContract?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `eventId` field. */
  eventId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `topic0` field. */
  topic0?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `topic1` field. */
  topic1?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `topic2` field. */
  topic2?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `topic3` field. */
  topic3?: InputMaybe<Scalars['String']['input']>;
};

export type AcalaEvmExecutedLogDistinctCountAggregates = {
  __typename?: 'AcalaEvmExecutedLogDistinctCountAggregates';
  /** Distinct count of contract across the matching connection */
  contract?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of eventContract across the matching connection */
  eventContract?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of eventId across the matching connection */
  eventId?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of id across the matching connection */
  id?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of topic0 across the matching connection */
  topic0?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of topic1 across the matching connection */
  topic1?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of topic2 across the matching connection */
  topic2?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of topic3 across the matching connection */
  topic3?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `AcalaEvmExecutedLog` object types. All fields are combined with a logical ‘and.’ */
export type AcalaEvmExecutedLogFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AcalaEvmExecutedLogFilter>>;
  /** Filter by the object’s `contract` field. */
  contract?: InputMaybe<StringFilter>;
  /** Filter by the object’s `eventContract` field. */
  eventContract?: InputMaybe<StringFilter>;
  /** Filter by the object’s `eventId` field. */
  eventId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AcalaEvmExecutedLogFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AcalaEvmExecutedLogFilter>>;
  /** Filter by the object’s `topic0` field. */
  topic0?: InputMaybe<StringFilter>;
  /** Filter by the object’s `topic1` field. */
  topic1?: InputMaybe<StringFilter>;
  /** Filter by the object’s `topic2` field. */
  topic2?: InputMaybe<StringFilter>;
  /** Filter by the object’s `topic3` field. */
  topic3?: InputMaybe<StringFilter>;
};

/** Grouping methods for `AcalaEvmExecutedLog` for usage during aggregation. */
export type AcalaEvmExecutedLogGroupBy =
  | 'CONTRACT'
  | 'EVENT_CONTRACT'
  | 'EVENT_ID'
  | 'TOPIC0'
  | 'TOPIC1'
  | 'TOPIC2'
  | 'TOPIC3';

/** Conditions for `AcalaEvmExecutedLog` aggregates. */
export type AcalaEvmExecutedLogHavingInput = {
  AND?: InputMaybe<Array<AcalaEvmExecutedLogHavingInput>>;
  OR?: InputMaybe<Array<AcalaEvmExecutedLogHavingInput>>;
};

/** A connection to a list of `AcalaEvmExecutedLog` values. */
export type AcalaEvmExecutedLogsConnection = {
  __typename?: 'AcalaEvmExecutedLogsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AcalaEvmExecutedLogAggregates>;
  /** A list of edges which contains the `AcalaEvmExecutedLog` and cursor to aid in pagination. */
  edges: Array<AcalaEvmExecutedLogsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AcalaEvmExecutedLogAggregates>>;
  /** A list of `AcalaEvmExecutedLog` objects. */
  nodes: Array<AcalaEvmExecutedLog>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AcalaEvmExecutedLog` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `AcalaEvmExecutedLog` values. */
export type AcalaEvmExecutedLogsConnectionGroupedAggregatesArgs = {
  groupBy: Array<AcalaEvmExecutedLogGroupBy>;
  having?: InputMaybe<AcalaEvmExecutedLogHavingInput>;
};

/** A `AcalaEvmExecutedLog` edge in the connection. */
export type AcalaEvmExecutedLogsEdge = {
  __typename?: 'AcalaEvmExecutedLogsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AcalaEvmExecutedLog` at the end of the edge. */
  node: AcalaEvmExecutedLog;
};

/** Methods to use when ordering `AcalaEvmExecutedLog`. */
export type AcalaEvmExecutedLogsOrderBy =
  | 'CONTRACT_ASC'
  | 'CONTRACT_DESC'
  | 'EVENT_CONTRACT_ASC'
  | 'EVENT_CONTRACT_DESC'
  | 'EVENT_ID_ASC'
  | 'EVENT_ID_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TOPIC0_ASC'
  | 'TOPIC0_DESC'
  | 'TOPIC1_ASC'
  | 'TOPIC1_DESC'
  | 'TOPIC2_ASC'
  | 'TOPIC2_DESC'
  | 'TOPIC3_ASC'
  | 'TOPIC3_DESC';

/** A connection to a list of `AcalaEvmExecuted` values. */
export type AcalaEvmExecutedsConnection = {
  __typename?: 'AcalaEvmExecutedsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AcalaEvmExecutedAggregates>;
  /** A list of edges which contains the `AcalaEvmExecuted` and cursor to aid in pagination. */
  edges: Array<AcalaEvmExecutedsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AcalaEvmExecutedAggregates>>;
  /** A list of `AcalaEvmExecuted` objects. */
  nodes: Array<AcalaEvmExecuted>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AcalaEvmExecuted` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `AcalaEvmExecuted` values. */
export type AcalaEvmExecutedsConnectionGroupedAggregatesArgs = {
  groupBy: Array<AcalaEvmExecutedGroupBy>;
  having?: InputMaybe<AcalaEvmExecutedHavingInput>;
};

/** A `AcalaEvmExecuted` edge in the connection. */
export type AcalaEvmExecutedsEdge = {
  __typename?: 'AcalaEvmExecutedsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AcalaEvmExecuted` at the end of the edge. */
  node: AcalaEvmExecuted;
};

/** Methods to use when ordering `AcalaEvmExecuted`. */
export type AcalaEvmExecutedsOrderBy =
  | 'CONTRACT_ASC'
  | 'CONTRACT_DESC'
  | 'EVENT_ID_ASC'
  | 'EVENT_ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

export type Account = Node & {
  __typename?: 'Account';
  alias?: Maybe<Scalars['String']['output']>;
  /** Reads a single `BrokerAccount` that is related to this `Account`. */
  brokerAccountByIdSs58?: Maybe<BrokerAccount>;
  /**
   * Reads and enables pagination through a set of `BrokerAccount`.
   * @deprecated Please use brokerAccountByIdSs58 instead
   */
  brokerAccountsByIdSs58: BrokerAccountsConnection;
  /** Reads and enables pagination through a set of `Delegation`. */
  delegationsByDelegatorIdSs58: DelegationsConnection;
  idHex: Scalars['String']['output'];
  idSs58: Scalars['String']['output'];
  /** Reads a single `LpAccount` that is related to this `Account`. */
  lpAccountByIdSs58?: Maybe<LpAccount>;
  /**
   * Reads and enables pagination through a set of `LpAccount`.
   * @deprecated Please use lpAccountByIdSs58 instead
   */
  lpAccountsByIdSs58: LpAccountsConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Operator` that is related to this `Account`. */
  operatorByIdSs58?: Maybe<Operator>;
  /**
   * Reads and enables pagination through a set of `Operator`.
   * @deprecated Please use operatorByIdSs58 instead
   */
  operatorsByIdSs58: OperatorsConnection;
  /** Reads a single `Unregistered` that is related to this `Account`. */
  unregisteredByIdSs58?: Maybe<Unregistered>;
  /**
   * Reads and enables pagination through a set of `Unregistered`.
   * @deprecated Please use unregisteredByIdSs58 instead
   */
  unregisteredsByIdSs58: UnregisteredsConnection;
  /** Reads a single `Validator` that is related to this `Account`. */
  validatorByIdSs58?: Maybe<Validator>;
  /**
   * Reads and enables pagination through a set of `Validator`.
   * @deprecated Please use validatorByIdSs58 instead
   */
  validatorsByIdSs58: ValidatorsConnection;
};


export type AccountBrokerAccountsByIdSs58Args = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<BrokerAccountCondition>;
  filter?: InputMaybe<BrokerAccountFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BrokerAccountsOrderBy>>;
};


export type AccountDelegationsByDelegatorIdSs58Args = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DelegationCondition>;
  filter?: InputMaybe<DelegationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DelegationsOrderBy>>;
};


export type AccountLpAccountsByIdSs58Args = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LpAccountCondition>;
  filter?: InputMaybe<LpAccountFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LpAccountsOrderBy>>;
};


export type AccountOperatorsByIdSs58Args = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OperatorCondition>;
  filter?: InputMaybe<OperatorFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OperatorsOrderBy>>;
};


export type AccountUnregisteredsByIdSs58Args = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UnregisteredCondition>;
  filter?: InputMaybe<UnregisteredFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UnregisteredsOrderBy>>;
};


export type AccountValidatorsByIdSs58Args = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ValidatorCondition>;
  filter?: InputMaybe<ValidatorFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ValidatorsOrderBy>>;
};

export type AccountAggregates = {
  __typename?: 'AccountAggregates';
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<AccountDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A condition to be used against `Account` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type AccountCondition = {
  /** Checks for equality with the object’s `alias` field. */
  alias?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `idHex` field. */
  idHex?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `idSs58` field. */
  idSs58?: InputMaybe<Scalars['String']['input']>;
};

export type AccountDistinctCountAggregates = {
  __typename?: 'AccountDistinctCountAggregates';
  /** Distinct count of alias across the matching connection */
  alias?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of idHex across the matching connection */
  idHex?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of idSs58 across the matching connection */
  idSs58?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `Account` object types. All fields are combined with a logical ‘and.’ */
export type AccountFilter = {
  /** Filter by the object’s `alias` field. */
  alias?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AccountFilter>>;
  /** Filter by the object’s `brokerAccountByIdSs58` relation. */
  brokerAccountByIdSs58?: InputMaybe<BrokerAccountFilter>;
  /** A related `brokerAccountByIdSs58` exists. */
  brokerAccountByIdSs58Exists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `delegationsByDelegatorIdSs58` relation. */
  delegationsByDelegatorIdSs58?: InputMaybe<AccountToManyDelegationFilter>;
  /** Some related `delegationsByDelegatorIdSs58` exist. */
  delegationsByDelegatorIdSs58Exist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `idHex` field. */
  idHex?: InputMaybe<StringFilter>;
  /** Filter by the object’s `idSs58` field. */
  idSs58?: InputMaybe<StringFilter>;
  /** Filter by the object’s `lpAccountByIdSs58` relation. */
  lpAccountByIdSs58?: InputMaybe<LpAccountFilter>;
  /** A related `lpAccountByIdSs58` exists. */
  lpAccountByIdSs58Exists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Negates the expression. */
  not?: InputMaybe<AccountFilter>;
  /** Filter by the object’s `operatorByIdSs58` relation. */
  operatorByIdSs58?: InputMaybe<OperatorFilter>;
  /** A related `operatorByIdSs58` exists. */
  operatorByIdSs58Exists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AccountFilter>>;
  /** Filter by the object’s `unregisteredByIdSs58` relation. */
  unregisteredByIdSs58?: InputMaybe<UnregisteredFilter>;
  /** A related `unregisteredByIdSs58` exists. */
  unregisteredByIdSs58Exists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `validatorByIdSs58` relation. */
  validatorByIdSs58?: InputMaybe<ValidatorFilter>;
  /** A related `validatorByIdSs58` exists. */
  validatorByIdSs58Exists?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Grouping methods for `Account` for usage during aggregation. */
export type AccountGroupBy =
  | 'ALIAS';

/** Conditions for `Account` aggregates. */
export type AccountHavingInput = {
  AND?: InputMaybe<Array<AccountHavingInput>>;
  OR?: InputMaybe<Array<AccountHavingInput>>;
};

export type AccountLink = Node & {
  __typename?: 'AccountLink';
  accountIdSs58: Scalars['String']['output'];
  ethereumAddress: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

export type AccountLinkAggregates = {
  __typename?: 'AccountLinkAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<AccountLinkAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<AccountLinkDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<AccountLinkMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<AccountLinkMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<AccountLinkStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<AccountLinkStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<AccountLinkSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<AccountLinkVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<AccountLinkVarianceSampleAggregates>;
};

export type AccountLinkAverageAggregates = {
  __typename?: 'AccountLinkAverageAggregates';
  /** Mean average of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `AccountLink` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type AccountLinkCondition = {
  /** Checks for equality with the object’s `accountIdSs58` field. */
  accountIdSs58?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ethereumAddress` field. */
  ethereumAddress?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
};

export type AccountLinkDistinctCountAggregates = {
  __typename?: 'AccountLinkDistinctCountAggregates';
  /** Distinct count of accountIdSs58 across the matching connection */
  accountIdSs58?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of ethereumAddress across the matching connection */
  ethereumAddress?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of id across the matching connection */
  id?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `AccountLink` object types. All fields are combined with a logical ‘and.’ */
export type AccountLinkFilter = {
  /** Filter by the object’s `accountIdSs58` field. */
  accountIdSs58?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AccountLinkFilter>>;
  /** Filter by the object’s `ethereumAddress` field. */
  ethereumAddress?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AccountLinkFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AccountLinkFilter>>;
};

/** Grouping methods for `AccountLink` for usage during aggregation. */
export type AccountLinkGroupBy =
  | 'ACCOUNT_ID_SS58'
  | 'ETHEREUM_ADDRESS';

export type AccountLinkHavingAverageInput = {
  id?: InputMaybe<HavingIntFilter>;
};

export type AccountLinkHavingDistinctCountInput = {
  id?: InputMaybe<HavingIntFilter>;
};

/** Conditions for `AccountLink` aggregates. */
export type AccountLinkHavingInput = {
  AND?: InputMaybe<Array<AccountLinkHavingInput>>;
  OR?: InputMaybe<Array<AccountLinkHavingInput>>;
  average?: InputMaybe<AccountLinkHavingAverageInput>;
  distinctCount?: InputMaybe<AccountLinkHavingDistinctCountInput>;
  max?: InputMaybe<AccountLinkHavingMaxInput>;
  min?: InputMaybe<AccountLinkHavingMinInput>;
  stddevPopulation?: InputMaybe<AccountLinkHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<AccountLinkHavingStddevSampleInput>;
  sum?: InputMaybe<AccountLinkHavingSumInput>;
  variancePopulation?: InputMaybe<AccountLinkHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<AccountLinkHavingVarianceSampleInput>;
};

export type AccountLinkHavingMaxInput = {
  id?: InputMaybe<HavingIntFilter>;
};

export type AccountLinkHavingMinInput = {
  id?: InputMaybe<HavingIntFilter>;
};

export type AccountLinkHavingStddevPopulationInput = {
  id?: InputMaybe<HavingIntFilter>;
};

export type AccountLinkHavingStddevSampleInput = {
  id?: InputMaybe<HavingIntFilter>;
};

export type AccountLinkHavingSumInput = {
  id?: InputMaybe<HavingIntFilter>;
};

export type AccountLinkHavingVariancePopulationInput = {
  id?: InputMaybe<HavingIntFilter>;
};

export type AccountLinkHavingVarianceSampleInput = {
  id?: InputMaybe<HavingIntFilter>;
};

export type AccountLinkMaxAggregates = {
  __typename?: 'AccountLinkMaxAggregates';
  /** Maximum of id across the matching connection */
  id?: Maybe<Scalars['Int']['output']>;
};

export type AccountLinkMinAggregates = {
  __typename?: 'AccountLinkMinAggregates';
  /** Minimum of id across the matching connection */
  id?: Maybe<Scalars['Int']['output']>;
};

export type AccountLinkStddevPopulationAggregates = {
  __typename?: 'AccountLinkStddevPopulationAggregates';
  /** Population standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
};

export type AccountLinkStddevSampleAggregates = {
  __typename?: 'AccountLinkStddevSampleAggregates';
  /** Sample standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
};

export type AccountLinkSumAggregates = {
  __typename?: 'AccountLinkSumAggregates';
  /** Sum of id across the matching connection */
  id: Scalars['BigInt']['output'];
};

export type AccountLinkVariancePopulationAggregates = {
  __typename?: 'AccountLinkVariancePopulationAggregates';
  /** Population variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
};

export type AccountLinkVarianceSampleAggregates = {
  __typename?: 'AccountLinkVarianceSampleAggregates';
  /** Sample variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
};

/** A connection to a list of `AccountLink` values. */
export type AccountLinksConnection = {
  __typename?: 'AccountLinksConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AccountLinkAggregates>;
  /** A list of edges which contains the `AccountLink` and cursor to aid in pagination. */
  edges: Array<AccountLinksEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AccountLinkAggregates>>;
  /** A list of `AccountLink` objects. */
  nodes: Array<AccountLink>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AccountLink` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `AccountLink` values. */
export type AccountLinksConnectionGroupedAggregatesArgs = {
  groupBy: Array<AccountLinkGroupBy>;
  having?: InputMaybe<AccountLinkHavingInput>;
};

/** A `AccountLink` edge in the connection. */
export type AccountLinksEdge = {
  __typename?: 'AccountLinksEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AccountLink` at the end of the edge. */
  node: AccountLink;
};

/** Methods to use when ordering `AccountLink`. */
export type AccountLinksOrderBy =
  | 'ACCOUNT_ID_SS58_ASC'
  | 'ACCOUNT_ID_SS58_DESC'
  | 'ETHEREUM_ADDRESS_ASC'
  | 'ETHEREUM_ADDRESS_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

export type AccountRole =
  | 'LIQUIDITY_PROVIDER'
  | 'UNREGISTERED'
  | 'VALIDATOR';

/** A filter to be used against AccountRole fields. All fields are combined with a logical ‘and.’ */
export type AccountRoleFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<AccountRole>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<AccountRole>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<AccountRole>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<AccountRole>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<AccountRole>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<AccountRole>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<AccountRole>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<AccountRole>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<AccountRole>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<AccountRole>>;
};

/** A filter to be used against many `Delegation` object types. All fields are combined with a logical ‘and.’ */
export type AccountToManyDelegationFilter = {
  /** Aggregates across related `Delegation` match the filter criteria. */
  aggregates?: InputMaybe<DelegationAggregatesFilter>;
  /** Every related `Delegation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DelegationFilter>;
  /** No related `Delegation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DelegationFilter>;
  /** Some related `Delegation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DelegationFilter>;
};

/** A connection to a list of `Account` values. */
export type AccountsConnection = {
  __typename?: 'AccountsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AccountAggregates>;
  /** A list of edges which contains the `Account` and cursor to aid in pagination. */
  edges: Array<AccountsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AccountAggregates>>;
  /** A list of `Account` objects. */
  nodes: Array<Account>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Account` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `Account` values. */
export type AccountsConnectionGroupedAggregatesArgs = {
  groupBy: Array<AccountGroupBy>;
  having?: InputMaybe<AccountHavingInput>;
};

/** A `Account` edge in the connection. */
export type AccountsEdge = {
  __typename?: 'AccountsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Account` at the end of the edge. */
  node: Account;
};

/** Methods to use when ordering `Account`. */
export type AccountsOrderBy =
  | 'ALIAS_ASC'
  | 'ALIAS_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_AVERAGE_ACTIVE_AMOUNT_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_AVERAGE_ACTIVE_AMOUNT_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_AVERAGE_DELEGATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_AVERAGE_DELEGATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_AVERAGE_OPERATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_AVERAGE_OPERATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_AVERAGE_UPCOMING_AMOUNT_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_AVERAGE_UPCOMING_AMOUNT_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_COUNT_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_COUNT_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_DISTINCT_COUNT_ACTIVE_AMOUNT_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_DISTINCT_COUNT_ACTIVE_AMOUNT_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_DISTINCT_COUNT_DELEGATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_DISTINCT_COUNT_DELEGATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_DISTINCT_COUNT_OPERATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_DISTINCT_COUNT_OPERATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_DISTINCT_COUNT_UPCOMING_AMOUNT_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_DISTINCT_COUNT_UPCOMING_AMOUNT_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_MAX_ACTIVE_AMOUNT_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_MAX_ACTIVE_AMOUNT_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_MAX_DELEGATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_MAX_DELEGATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_MAX_OPERATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_MAX_OPERATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_MAX_UPCOMING_AMOUNT_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_MAX_UPCOMING_AMOUNT_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_MIN_ACTIVE_AMOUNT_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_MIN_ACTIVE_AMOUNT_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_MIN_DELEGATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_MIN_DELEGATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_MIN_OPERATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_MIN_OPERATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_MIN_UPCOMING_AMOUNT_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_MIN_UPCOMING_AMOUNT_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_STDDEV_POPULATION_ACTIVE_AMOUNT_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_STDDEV_POPULATION_ACTIVE_AMOUNT_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_STDDEV_POPULATION_DELEGATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_STDDEV_POPULATION_DELEGATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_STDDEV_POPULATION_OPERATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_STDDEV_POPULATION_OPERATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_STDDEV_POPULATION_UPCOMING_AMOUNT_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_STDDEV_POPULATION_UPCOMING_AMOUNT_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_STDDEV_SAMPLE_ACTIVE_AMOUNT_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_STDDEV_SAMPLE_ACTIVE_AMOUNT_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_STDDEV_SAMPLE_DELEGATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_STDDEV_SAMPLE_DELEGATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_STDDEV_SAMPLE_OPERATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_STDDEV_SAMPLE_OPERATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_STDDEV_SAMPLE_UPCOMING_AMOUNT_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_STDDEV_SAMPLE_UPCOMING_AMOUNT_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_SUM_ACTIVE_AMOUNT_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_SUM_ACTIVE_AMOUNT_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_SUM_DELEGATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_SUM_DELEGATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_SUM_OPERATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_SUM_OPERATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_SUM_UPCOMING_AMOUNT_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_SUM_UPCOMING_AMOUNT_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_VARIANCE_POPULATION_ACTIVE_AMOUNT_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_VARIANCE_POPULATION_ACTIVE_AMOUNT_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_VARIANCE_POPULATION_DELEGATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_VARIANCE_POPULATION_DELEGATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_VARIANCE_POPULATION_OPERATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_VARIANCE_POPULATION_OPERATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_VARIANCE_POPULATION_UPCOMING_AMOUNT_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_VARIANCE_POPULATION_UPCOMING_AMOUNT_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_VARIANCE_SAMPLE_ACTIVE_AMOUNT_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_VARIANCE_SAMPLE_ACTIVE_AMOUNT_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_VARIANCE_SAMPLE_DELEGATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_VARIANCE_SAMPLE_DELEGATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_VARIANCE_SAMPLE_OPERATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_VARIANCE_SAMPLE_OPERATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_VARIANCE_SAMPLE_UPCOMING_AMOUNT_ASC'
  | 'DELEGATIONS_BY_DELEGATOR_ID_SS58_VARIANCE_SAMPLE_UPCOMING_AMOUNT_DESC'
  | 'ID_HEX_ASC'
  | 'ID_HEX_DESC'
  | 'ID_SS58_ASC'
  | 'ID_SS58_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

export type App =
  | 'ALL'
  | 'EXPLORER'
  | 'LP'
  | 'STAKE'
  | 'SWAP';

/** A filter to be used against App fields. All fields are combined with a logical ‘and.’ */
export type AppFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<App>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<App>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<App>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<App>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<App>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<App>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<App>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<App>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<App>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<App>>;
};

export type Auction = Node & {
  __typename?: 'Auction';
  activeBond: Scalars['BigFloat']['output'];
  authorityRotationEnabled: Scalars['Boolean']['output'];
  blockReward: Scalars['BigFloat']['output'];
  currentHeight: Scalars['Int']['output'];
  endBlockNumber: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  minActiveBid?: Maybe<Scalars['BigFloat']['output']>;
  minBid: Scalars['BigFloat']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  projectedLockup?: Maybe<Scalars['BigFloat']['output']>;
  redemptionPeriodAsPercentage: Scalars['Int']['output'];
  startBlockNumber: Scalars['Int']['output'];
  targetSetSize: Scalars['Int']['output'];
};

export type AuctionAggregates = {
  __typename?: 'AuctionAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<AuctionAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<AuctionDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<AuctionMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<AuctionMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<AuctionStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<AuctionStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<AuctionSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<AuctionVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<AuctionVarianceSampleAggregates>;
};

export type AuctionAverageAggregates = {
  __typename?: 'AuctionAverageAggregates';
  /** Mean average of activeBond across the matching connection */
  activeBond?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of blockReward across the matching connection */
  blockReward?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of currentHeight across the matching connection */
  currentHeight?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of endBlockNumber across the matching connection */
  endBlockNumber?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of minActiveBid across the matching connection */
  minActiveBid?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of minBid across the matching connection */
  minBid?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of projectedLockup across the matching connection */
  projectedLockup?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of redemptionPeriodAsPercentage across the matching connection */
  redemptionPeriodAsPercentage?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of startBlockNumber across the matching connection */
  startBlockNumber?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of targetSetSize across the matching connection */
  targetSetSize?: Maybe<Scalars['BigFloat']['output']>;
};

/** A condition to be used against `Auction` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type AuctionCondition = {
  /** Checks for equality with the object’s `activeBond` field. */
  activeBond?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `authorityRotationEnabled` field. */
  authorityRotationEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `blockReward` field. */
  blockReward?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `currentHeight` field. */
  currentHeight?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `endBlockNumber` field. */
  endBlockNumber?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `minActiveBid` field. */
  minActiveBid?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `minBid` field. */
  minBid?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `projectedLockup` field. */
  projectedLockup?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `redemptionPeriodAsPercentage` field. */
  redemptionPeriodAsPercentage?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `startBlockNumber` field. */
  startBlockNumber?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `targetSetSize` field. */
  targetSetSize?: InputMaybe<Scalars['Int']['input']>;
};

export type AuctionDistinctCountAggregates = {
  __typename?: 'AuctionDistinctCountAggregates';
  /** Distinct count of activeBond across the matching connection */
  activeBond?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of authorityRotationEnabled across the matching connection */
  authorityRotationEnabled?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of blockReward across the matching connection */
  blockReward?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of currentHeight across the matching connection */
  currentHeight?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of endBlockNumber across the matching connection */
  endBlockNumber?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of id across the matching connection */
  id?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of minActiveBid across the matching connection */
  minActiveBid?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of minBid across the matching connection */
  minBid?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of projectedLockup across the matching connection */
  projectedLockup?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of redemptionPeriodAsPercentage across the matching connection */
  redemptionPeriodAsPercentage?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of startBlockNumber across the matching connection */
  startBlockNumber?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of targetSetSize across the matching connection */
  targetSetSize?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `Auction` object types. All fields are combined with a logical ‘and.’ */
export type AuctionFilter = {
  /** Filter by the object’s `activeBond` field. */
  activeBond?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AuctionFilter>>;
  /** Filter by the object’s `authorityRotationEnabled` field. */
  authorityRotationEnabled?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `blockReward` field. */
  blockReward?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `currentHeight` field. */
  currentHeight?: InputMaybe<IntFilter>;
  /** Filter by the object’s `endBlockNumber` field. */
  endBlockNumber?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `minActiveBid` field. */
  minActiveBid?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `minBid` field. */
  minBid?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AuctionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AuctionFilter>>;
  /** Filter by the object’s `projectedLockup` field. */
  projectedLockup?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `redemptionPeriodAsPercentage` field. */
  redemptionPeriodAsPercentage?: InputMaybe<IntFilter>;
  /** Filter by the object’s `startBlockNumber` field. */
  startBlockNumber?: InputMaybe<IntFilter>;
  /** Filter by the object’s `targetSetSize` field. */
  targetSetSize?: InputMaybe<IntFilter>;
};

/** Grouping methods for `Auction` for usage during aggregation. */
export type AuctionGroupBy =
  | 'ACTIVE_BOND'
  | 'AUTHORITY_ROTATION_ENABLED'
  | 'BLOCK_REWARD'
  | 'CURRENT_HEIGHT'
  | 'END_BLOCK_NUMBER'
  | 'MIN_ACTIVE_BID'
  | 'MIN_BID'
  | 'PROJECTED_LOCKUP'
  | 'REDEMPTION_PERIOD_AS_PERCENTAGE'
  | 'START_BLOCK_NUMBER'
  | 'TARGET_SET_SIZE';

export type AuctionHavingAverageInput = {
  activeBond?: InputMaybe<HavingBigfloatFilter>;
  blockReward?: InputMaybe<HavingBigfloatFilter>;
  currentHeight?: InputMaybe<HavingIntFilter>;
  endBlockNumber?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingIntFilter>;
  minActiveBid?: InputMaybe<HavingBigfloatFilter>;
  minBid?: InputMaybe<HavingBigfloatFilter>;
  projectedLockup?: InputMaybe<HavingBigfloatFilter>;
  redemptionPeriodAsPercentage?: InputMaybe<HavingIntFilter>;
  startBlockNumber?: InputMaybe<HavingIntFilter>;
  targetSetSize?: InputMaybe<HavingIntFilter>;
};

export type AuctionHavingDistinctCountInput = {
  activeBond?: InputMaybe<HavingBigfloatFilter>;
  blockReward?: InputMaybe<HavingBigfloatFilter>;
  currentHeight?: InputMaybe<HavingIntFilter>;
  endBlockNumber?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingIntFilter>;
  minActiveBid?: InputMaybe<HavingBigfloatFilter>;
  minBid?: InputMaybe<HavingBigfloatFilter>;
  projectedLockup?: InputMaybe<HavingBigfloatFilter>;
  redemptionPeriodAsPercentage?: InputMaybe<HavingIntFilter>;
  startBlockNumber?: InputMaybe<HavingIntFilter>;
  targetSetSize?: InputMaybe<HavingIntFilter>;
};

/** Conditions for `Auction` aggregates. */
export type AuctionHavingInput = {
  AND?: InputMaybe<Array<AuctionHavingInput>>;
  OR?: InputMaybe<Array<AuctionHavingInput>>;
  average?: InputMaybe<AuctionHavingAverageInput>;
  distinctCount?: InputMaybe<AuctionHavingDistinctCountInput>;
  max?: InputMaybe<AuctionHavingMaxInput>;
  min?: InputMaybe<AuctionHavingMinInput>;
  stddevPopulation?: InputMaybe<AuctionHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<AuctionHavingStddevSampleInput>;
  sum?: InputMaybe<AuctionHavingSumInput>;
  variancePopulation?: InputMaybe<AuctionHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<AuctionHavingVarianceSampleInput>;
};

export type AuctionHavingMaxInput = {
  activeBond?: InputMaybe<HavingBigfloatFilter>;
  blockReward?: InputMaybe<HavingBigfloatFilter>;
  currentHeight?: InputMaybe<HavingIntFilter>;
  endBlockNumber?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingIntFilter>;
  minActiveBid?: InputMaybe<HavingBigfloatFilter>;
  minBid?: InputMaybe<HavingBigfloatFilter>;
  projectedLockup?: InputMaybe<HavingBigfloatFilter>;
  redemptionPeriodAsPercentage?: InputMaybe<HavingIntFilter>;
  startBlockNumber?: InputMaybe<HavingIntFilter>;
  targetSetSize?: InputMaybe<HavingIntFilter>;
};

export type AuctionHavingMinInput = {
  activeBond?: InputMaybe<HavingBigfloatFilter>;
  blockReward?: InputMaybe<HavingBigfloatFilter>;
  currentHeight?: InputMaybe<HavingIntFilter>;
  endBlockNumber?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingIntFilter>;
  minActiveBid?: InputMaybe<HavingBigfloatFilter>;
  minBid?: InputMaybe<HavingBigfloatFilter>;
  projectedLockup?: InputMaybe<HavingBigfloatFilter>;
  redemptionPeriodAsPercentage?: InputMaybe<HavingIntFilter>;
  startBlockNumber?: InputMaybe<HavingIntFilter>;
  targetSetSize?: InputMaybe<HavingIntFilter>;
};

export type AuctionHavingStddevPopulationInput = {
  activeBond?: InputMaybe<HavingBigfloatFilter>;
  blockReward?: InputMaybe<HavingBigfloatFilter>;
  currentHeight?: InputMaybe<HavingIntFilter>;
  endBlockNumber?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingIntFilter>;
  minActiveBid?: InputMaybe<HavingBigfloatFilter>;
  minBid?: InputMaybe<HavingBigfloatFilter>;
  projectedLockup?: InputMaybe<HavingBigfloatFilter>;
  redemptionPeriodAsPercentage?: InputMaybe<HavingIntFilter>;
  startBlockNumber?: InputMaybe<HavingIntFilter>;
  targetSetSize?: InputMaybe<HavingIntFilter>;
};

export type AuctionHavingStddevSampleInput = {
  activeBond?: InputMaybe<HavingBigfloatFilter>;
  blockReward?: InputMaybe<HavingBigfloatFilter>;
  currentHeight?: InputMaybe<HavingIntFilter>;
  endBlockNumber?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingIntFilter>;
  minActiveBid?: InputMaybe<HavingBigfloatFilter>;
  minBid?: InputMaybe<HavingBigfloatFilter>;
  projectedLockup?: InputMaybe<HavingBigfloatFilter>;
  redemptionPeriodAsPercentage?: InputMaybe<HavingIntFilter>;
  startBlockNumber?: InputMaybe<HavingIntFilter>;
  targetSetSize?: InputMaybe<HavingIntFilter>;
};

export type AuctionHavingSumInput = {
  activeBond?: InputMaybe<HavingBigfloatFilter>;
  blockReward?: InputMaybe<HavingBigfloatFilter>;
  currentHeight?: InputMaybe<HavingIntFilter>;
  endBlockNumber?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingIntFilter>;
  minActiveBid?: InputMaybe<HavingBigfloatFilter>;
  minBid?: InputMaybe<HavingBigfloatFilter>;
  projectedLockup?: InputMaybe<HavingBigfloatFilter>;
  redemptionPeriodAsPercentage?: InputMaybe<HavingIntFilter>;
  startBlockNumber?: InputMaybe<HavingIntFilter>;
  targetSetSize?: InputMaybe<HavingIntFilter>;
};

export type AuctionHavingVariancePopulationInput = {
  activeBond?: InputMaybe<HavingBigfloatFilter>;
  blockReward?: InputMaybe<HavingBigfloatFilter>;
  currentHeight?: InputMaybe<HavingIntFilter>;
  endBlockNumber?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingIntFilter>;
  minActiveBid?: InputMaybe<HavingBigfloatFilter>;
  minBid?: InputMaybe<HavingBigfloatFilter>;
  projectedLockup?: InputMaybe<HavingBigfloatFilter>;
  redemptionPeriodAsPercentage?: InputMaybe<HavingIntFilter>;
  startBlockNumber?: InputMaybe<HavingIntFilter>;
  targetSetSize?: InputMaybe<HavingIntFilter>;
};

export type AuctionHavingVarianceSampleInput = {
  activeBond?: InputMaybe<HavingBigfloatFilter>;
  blockReward?: InputMaybe<HavingBigfloatFilter>;
  currentHeight?: InputMaybe<HavingIntFilter>;
  endBlockNumber?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingIntFilter>;
  minActiveBid?: InputMaybe<HavingBigfloatFilter>;
  minBid?: InputMaybe<HavingBigfloatFilter>;
  projectedLockup?: InputMaybe<HavingBigfloatFilter>;
  redemptionPeriodAsPercentage?: InputMaybe<HavingIntFilter>;
  startBlockNumber?: InputMaybe<HavingIntFilter>;
  targetSetSize?: InputMaybe<HavingIntFilter>;
};

export type AuctionMaxAggregates = {
  __typename?: 'AuctionMaxAggregates';
  /** Maximum of activeBond across the matching connection */
  activeBond?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of blockReward across the matching connection */
  blockReward?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of currentHeight across the matching connection */
  currentHeight?: Maybe<Scalars['Int']['output']>;
  /** Maximum of endBlockNumber across the matching connection */
  endBlockNumber?: Maybe<Scalars['Int']['output']>;
  /** Maximum of id across the matching connection */
  id?: Maybe<Scalars['Int']['output']>;
  /** Maximum of minActiveBid across the matching connection */
  minActiveBid?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of minBid across the matching connection */
  minBid?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of projectedLockup across the matching connection */
  projectedLockup?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of redemptionPeriodAsPercentage across the matching connection */
  redemptionPeriodAsPercentage?: Maybe<Scalars['Int']['output']>;
  /** Maximum of startBlockNumber across the matching connection */
  startBlockNumber?: Maybe<Scalars['Int']['output']>;
  /** Maximum of targetSetSize across the matching connection */
  targetSetSize?: Maybe<Scalars['Int']['output']>;
};

export type AuctionMinAggregates = {
  __typename?: 'AuctionMinAggregates';
  /** Minimum of activeBond across the matching connection */
  activeBond?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of blockReward across the matching connection */
  blockReward?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of currentHeight across the matching connection */
  currentHeight?: Maybe<Scalars['Int']['output']>;
  /** Minimum of endBlockNumber across the matching connection */
  endBlockNumber?: Maybe<Scalars['Int']['output']>;
  /** Minimum of id across the matching connection */
  id?: Maybe<Scalars['Int']['output']>;
  /** Minimum of minActiveBid across the matching connection */
  minActiveBid?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of minBid across the matching connection */
  minBid?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of projectedLockup across the matching connection */
  projectedLockup?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of redemptionPeriodAsPercentage across the matching connection */
  redemptionPeriodAsPercentage?: Maybe<Scalars['Int']['output']>;
  /** Minimum of startBlockNumber across the matching connection */
  startBlockNumber?: Maybe<Scalars['Int']['output']>;
  /** Minimum of targetSetSize across the matching connection */
  targetSetSize?: Maybe<Scalars['Int']['output']>;
};

export type AuctionStddevPopulationAggregates = {
  __typename?: 'AuctionStddevPopulationAggregates';
  /** Population standard deviation of activeBond across the matching connection */
  activeBond?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of blockReward across the matching connection */
  blockReward?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of currentHeight across the matching connection */
  currentHeight?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of endBlockNumber across the matching connection */
  endBlockNumber?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of minActiveBid across the matching connection */
  minActiveBid?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of minBid across the matching connection */
  minBid?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of projectedLockup across the matching connection */
  projectedLockup?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of redemptionPeriodAsPercentage across the matching connection */
  redemptionPeriodAsPercentage?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of startBlockNumber across the matching connection */
  startBlockNumber?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of targetSetSize across the matching connection */
  targetSetSize?: Maybe<Scalars['BigFloat']['output']>;
};

export type AuctionStddevSampleAggregates = {
  __typename?: 'AuctionStddevSampleAggregates';
  /** Sample standard deviation of activeBond across the matching connection */
  activeBond?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of blockReward across the matching connection */
  blockReward?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of currentHeight across the matching connection */
  currentHeight?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of endBlockNumber across the matching connection */
  endBlockNumber?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of minActiveBid across the matching connection */
  minActiveBid?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of minBid across the matching connection */
  minBid?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of projectedLockup across the matching connection */
  projectedLockup?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of redemptionPeriodAsPercentage across the matching connection */
  redemptionPeriodAsPercentage?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of startBlockNumber across the matching connection */
  startBlockNumber?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of targetSetSize across the matching connection */
  targetSetSize?: Maybe<Scalars['BigFloat']['output']>;
};

export type AuctionSumAggregates = {
  __typename?: 'AuctionSumAggregates';
  /** Sum of activeBond across the matching connection */
  activeBond: Scalars['BigFloat']['output'];
  /** Sum of blockReward across the matching connection */
  blockReward: Scalars['BigFloat']['output'];
  /** Sum of currentHeight across the matching connection */
  currentHeight: Scalars['BigInt']['output'];
  /** Sum of endBlockNumber across the matching connection */
  endBlockNumber: Scalars['BigInt']['output'];
  /** Sum of id across the matching connection */
  id: Scalars['BigInt']['output'];
  /** Sum of minActiveBid across the matching connection */
  minActiveBid: Scalars['BigFloat']['output'];
  /** Sum of minBid across the matching connection */
  minBid: Scalars['BigFloat']['output'];
  /** Sum of projectedLockup across the matching connection */
  projectedLockup: Scalars['BigFloat']['output'];
  /** Sum of redemptionPeriodAsPercentage across the matching connection */
  redemptionPeriodAsPercentage: Scalars['BigInt']['output'];
  /** Sum of startBlockNumber across the matching connection */
  startBlockNumber: Scalars['BigInt']['output'];
  /** Sum of targetSetSize across the matching connection */
  targetSetSize: Scalars['BigInt']['output'];
};

export type AuctionVariancePopulationAggregates = {
  __typename?: 'AuctionVariancePopulationAggregates';
  /** Population variance of activeBond across the matching connection */
  activeBond?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of blockReward across the matching connection */
  blockReward?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of currentHeight across the matching connection */
  currentHeight?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of endBlockNumber across the matching connection */
  endBlockNumber?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of minActiveBid across the matching connection */
  minActiveBid?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of minBid across the matching connection */
  minBid?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of projectedLockup across the matching connection */
  projectedLockup?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of redemptionPeriodAsPercentage across the matching connection */
  redemptionPeriodAsPercentage?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of startBlockNumber across the matching connection */
  startBlockNumber?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of targetSetSize across the matching connection */
  targetSetSize?: Maybe<Scalars['BigFloat']['output']>;
};

export type AuctionVarianceSampleAggregates = {
  __typename?: 'AuctionVarianceSampleAggregates';
  /** Sample variance of activeBond across the matching connection */
  activeBond?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of blockReward across the matching connection */
  blockReward?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of currentHeight across the matching connection */
  currentHeight?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of endBlockNumber across the matching connection */
  endBlockNumber?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of minActiveBid across the matching connection */
  minActiveBid?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of minBid across the matching connection */
  minBid?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of projectedLockup across the matching connection */
  projectedLockup?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of redemptionPeriodAsPercentage across the matching connection */
  redemptionPeriodAsPercentage?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of startBlockNumber across the matching connection */
  startBlockNumber?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of targetSetSize across the matching connection */
  targetSetSize?: Maybe<Scalars['BigFloat']['output']>;
};

/** A connection to a list of `Auction` values. */
export type AuctionsConnection = {
  __typename?: 'AuctionsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<AuctionAggregates>;
  /** A list of edges which contains the `Auction` and cursor to aid in pagination. */
  edges: Array<AuctionsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<AuctionAggregates>>;
  /** A list of `Auction` objects. */
  nodes: Array<Auction>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Auction` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `Auction` values. */
export type AuctionsConnectionGroupedAggregatesArgs = {
  groupBy: Array<AuctionGroupBy>;
  having?: InputMaybe<AuctionHavingInput>;
};

/** A `Auction` edge in the connection. */
export type AuctionsEdge = {
  __typename?: 'AuctionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Auction` at the end of the edge. */
  node: Auction;
};

/** Methods to use when ordering `Auction`. */
export type AuctionsOrderBy =
  | 'ACTIVE_BOND_ASC'
  | 'ACTIVE_BOND_DESC'
  | 'AUTHORITY_ROTATION_ENABLED_ASC'
  | 'AUTHORITY_ROTATION_ENABLED_DESC'
  | 'BLOCK_REWARD_ASC'
  | 'BLOCK_REWARD_DESC'
  | 'CURRENT_HEIGHT_ASC'
  | 'CURRENT_HEIGHT_DESC'
  | 'END_BLOCK_NUMBER_ASC'
  | 'END_BLOCK_NUMBER_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'MIN_ACTIVE_BID_ASC'
  | 'MIN_ACTIVE_BID_DESC'
  | 'MIN_BID_ASC'
  | 'MIN_BID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'PROJECTED_LOCKUP_ASC'
  | 'PROJECTED_LOCKUP_DESC'
  | 'REDEMPTION_PERIOD_AS_PERCENTAGE_ASC'
  | 'REDEMPTION_PERIOD_AS_PERCENTAGE_DESC'
  | 'START_BLOCK_NUMBER_ASC'
  | 'START_BLOCK_NUMBER_DESC'
  | 'TARGET_SET_SIZE_ASC'
  | 'TARGET_SET_SIZE_DESC';

export type Banner = Node & {
  __typename?: 'Banner';
  app: App;
  message: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  type: BannerType;
};

export type BannerAggregates = {
  __typename?: 'BannerAggregates';
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<BannerDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A condition to be used against `Banner` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type BannerCondition = {
  /** Checks for equality with the object’s `app` field. */
  app?: InputMaybe<App>;
  /** Checks for equality with the object’s `message` field. */
  message?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<BannerType>;
};

export type BannerDistinctCountAggregates = {
  __typename?: 'BannerDistinctCountAggregates';
  /** Distinct count of app across the matching connection */
  app?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of message across the matching connection */
  message?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of type across the matching connection */
  type?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `Banner` object types. All fields are combined with a logical ‘and.’ */
export type BannerFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<BannerFilter>>;
  /** Filter by the object’s `app` field. */
  app?: InputMaybe<AppFilter>;
  /** Filter by the object’s `message` field. */
  message?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<BannerFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<BannerFilter>>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<BannerTypeFilter>;
};

/** Grouping methods for `Banner` for usage during aggregation. */
export type BannerGroupBy =
  | 'MESSAGE'
  | 'TYPE';

/** Conditions for `Banner` aggregates. */
export type BannerHavingInput = {
  AND?: InputMaybe<Array<BannerHavingInput>>;
  OR?: InputMaybe<Array<BannerHavingInput>>;
};

export type BannerType =
  | 'INFO'
  | 'SUCCESS'
  | 'WARNING';

/** A filter to be used against BannerType fields. All fields are combined with a logical ‘and.’ */
export type BannerTypeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<BannerType>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<BannerType>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<BannerType>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<BannerType>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<BannerType>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<BannerType>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<BannerType>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<BannerType>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<BannerType>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<BannerType>>;
};

/** A connection to a list of `Banner` values. */
export type BannersConnection = {
  __typename?: 'BannersConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BannerAggregates>;
  /** A list of edges which contains the `Banner` and cursor to aid in pagination. */
  edges: Array<BannersEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BannerAggregates>>;
  /** A list of `Banner` objects. */
  nodes: Array<Banner>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Banner` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `Banner` values. */
export type BannersConnectionGroupedAggregatesArgs = {
  groupBy: Array<BannerGroupBy>;
  having?: InputMaybe<BannerHavingInput>;
};

/** A `Banner` edge in the connection. */
export type BannersEdge = {
  __typename?: 'BannersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Banner` at the end of the edge. */
  node: Banner;
};

/** Methods to use when ordering `Banner`. */
export type BannersOrderBy =
  | 'APP_ASC'
  | 'APP_DESC'
  | 'MESSAGE_ASC'
  | 'MESSAGE_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC';

/** A filter to be used against BigFloat fields. All fields are combined with a logical ‘and.’ */
export type BigFloatFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['BigFloat']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['BigFloat']['input']>>;
};

/** A filter to be used against BigInt fields. All fields are combined with a logical ‘and.’ */
export type BigIntFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['BigInt']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['BigInt']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['BigInt']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['BigInt']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['BigInt']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['BigInt']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['BigInt']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['BigInt']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['BigInt']['input']>>;
};

export type Block = Node & {
  __typename?: 'Block';
  /** Reads and enables pagination through a set of `Call`. */
  callsByBlockId: CallsConnection;
  /** Reads and enables pagination through a set of `Event`. */
  eventsByBlockId: EventsConnection;
  /** Reads and enables pagination through a set of `Extrinsic`. */
  extrinsicsByBlockId: ExtrinsicsConnection;
  extrinsicsRoot: Scalars['String']['output'];
  hash: Scalars['String']['output'];
  height: Scalars['Int']['output'];
  id: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  parentHash: Scalars['String']['output'];
  specId: Scalars['String']['output'];
  stateRoot: Scalars['String']['output'];
  timestamp: Scalars['Datetime']['output'];
  validator?: Maybe<Scalars['String']['output']>;
};


export type BlockCallsByBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CallCondition>;
  filter?: InputMaybe<CallFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CallsOrderBy>>;
};


export type BlockEventsByBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventCondition>;
  filter?: InputMaybe<EventFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};


export type BlockExtrinsicsByBlockIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ExtrinsicCondition>;
  filter?: InputMaybe<ExtrinsicFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ExtrinsicsOrderBy>>;
};

export type BlockAggregates = {
  __typename?: 'BlockAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<BlockAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<BlockDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<BlockMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<BlockMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<BlockStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<BlockStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<BlockSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<BlockVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<BlockVarianceSampleAggregates>;
};

export type BlockAverageAggregates = {
  __typename?: 'BlockAverageAggregates';
  /** Mean average of height across the matching connection */
  height?: Maybe<Scalars['BigFloat']['output']>;
};

/** A condition to be used against `Block` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type BlockCondition = {
  /** Checks for equality with the object’s `extrinsicsRoot` field. */
  extrinsicsRoot?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `hash` field. */
  hash?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `height` field. */
  height?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `parentHash` field. */
  parentHash?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `specId` field. */
  specId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `stateRoot` field. */
  stateRoot?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `timestamp` field. */
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `validator` field. */
  validator?: InputMaybe<Scalars['String']['input']>;
};

export type BlockDistinctCountAggregates = {
  __typename?: 'BlockDistinctCountAggregates';
  /** Distinct count of extrinsicsRoot across the matching connection */
  extrinsicsRoot?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of hash across the matching connection */
  hash?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of height across the matching connection */
  height?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of id across the matching connection */
  id?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of parentHash across the matching connection */
  parentHash?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of specId across the matching connection */
  specId?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of stateRoot across the matching connection */
  stateRoot?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of timestamp across the matching connection */
  timestamp?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of validator across the matching connection */
  validator?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `Block` object types. All fields are combined with a logical ‘and.’ */
export type BlockFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<BlockFilter>>;
  /** Filter by the object’s `extrinsicsRoot` field. */
  extrinsicsRoot?: InputMaybe<StringFilter>;
  /** Filter by the object’s `hash` field. */
  hash?: InputMaybe<StringFilter>;
  /** Filter by the object’s `height` field. */
  height?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<BlockFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<BlockFilter>>;
  /** Filter by the object’s `parentHash` field. */
  parentHash?: InputMaybe<StringFilter>;
  /** Filter by the object’s `specId` field. */
  specId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `stateRoot` field. */
  stateRoot?: InputMaybe<StringFilter>;
  /** Filter by the object’s `timestamp` field. */
  timestamp?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `validator` field. */
  validator?: InputMaybe<StringFilter>;
};

/** Grouping methods for `Block` for usage during aggregation. */
export type BlockGroupBy =
  | 'EXTRINSICS_ROOT'
  | 'HASH'
  | 'HEIGHT'
  | 'PARENT_HASH'
  | 'SPEC_ID'
  | 'STATE_ROOT'
  | 'TIMESTAMP'
  | 'TIMESTAMP_TRUNCATED_TO_DAY'
  | 'TIMESTAMP_TRUNCATED_TO_HOUR'
  | 'TIMESTAMP_TRUNCATED_TO_MONTH'
  | 'TIMESTAMP_TRUNCATED_TO_WEEK'
  | 'VALIDATOR';

export type BlockHavingAverageInput = {
  height?: InputMaybe<HavingIntFilter>;
  timestamp?: InputMaybe<HavingDatetimeFilter>;
};

export type BlockHavingDistinctCountInput = {
  height?: InputMaybe<HavingIntFilter>;
  timestamp?: InputMaybe<HavingDatetimeFilter>;
};

/** Conditions for `Block` aggregates. */
export type BlockHavingInput = {
  AND?: InputMaybe<Array<BlockHavingInput>>;
  OR?: InputMaybe<Array<BlockHavingInput>>;
  average?: InputMaybe<BlockHavingAverageInput>;
  distinctCount?: InputMaybe<BlockHavingDistinctCountInput>;
  max?: InputMaybe<BlockHavingMaxInput>;
  min?: InputMaybe<BlockHavingMinInput>;
  stddevPopulation?: InputMaybe<BlockHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<BlockHavingStddevSampleInput>;
  sum?: InputMaybe<BlockHavingSumInput>;
  variancePopulation?: InputMaybe<BlockHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<BlockHavingVarianceSampleInput>;
};

export type BlockHavingMaxInput = {
  height?: InputMaybe<HavingIntFilter>;
  timestamp?: InputMaybe<HavingDatetimeFilter>;
};

export type BlockHavingMinInput = {
  height?: InputMaybe<HavingIntFilter>;
  timestamp?: InputMaybe<HavingDatetimeFilter>;
};

export type BlockHavingStddevPopulationInput = {
  height?: InputMaybe<HavingIntFilter>;
  timestamp?: InputMaybe<HavingDatetimeFilter>;
};

export type BlockHavingStddevSampleInput = {
  height?: InputMaybe<HavingIntFilter>;
  timestamp?: InputMaybe<HavingDatetimeFilter>;
};

export type BlockHavingSumInput = {
  height?: InputMaybe<HavingIntFilter>;
  timestamp?: InputMaybe<HavingDatetimeFilter>;
};

export type BlockHavingVariancePopulationInput = {
  height?: InputMaybe<HavingIntFilter>;
  timestamp?: InputMaybe<HavingDatetimeFilter>;
};

export type BlockHavingVarianceSampleInput = {
  height?: InputMaybe<HavingIntFilter>;
  timestamp?: InputMaybe<HavingDatetimeFilter>;
};

export type BlockMaxAggregates = {
  __typename?: 'BlockMaxAggregates';
  /** Maximum of height across the matching connection */
  height?: Maybe<Scalars['Int']['output']>;
  /** Maximum of timestamp across the matching connection */
  timestamp?: Maybe<Scalars['Datetime']['output']>;
};

export type BlockMinAggregates = {
  __typename?: 'BlockMinAggregates';
  /** Minimum of height across the matching connection */
  height?: Maybe<Scalars['Int']['output']>;
  /** Minimum of timestamp across the matching connection */
  timestamp?: Maybe<Scalars['Datetime']['output']>;
};

export type BlockStddevPopulationAggregates = {
  __typename?: 'BlockStddevPopulationAggregates';
  /** Population standard deviation of height across the matching connection */
  height?: Maybe<Scalars['BigFloat']['output']>;
};

export type BlockStddevSampleAggregates = {
  __typename?: 'BlockStddevSampleAggregates';
  /** Sample standard deviation of height across the matching connection */
  height?: Maybe<Scalars['BigFloat']['output']>;
};

export type BlockSumAggregates = {
  __typename?: 'BlockSumAggregates';
  /** Sum of height across the matching connection */
  height: Scalars['BigInt']['output'];
};

export type BlockVariancePopulationAggregates = {
  __typename?: 'BlockVariancePopulationAggregates';
  /** Population variance of height across the matching connection */
  height?: Maybe<Scalars['BigFloat']['output']>;
};

export type BlockVarianceSampleAggregates = {
  __typename?: 'BlockVarianceSampleAggregates';
  /** Sample variance of height across the matching connection */
  height?: Maybe<Scalars['BigFloat']['output']>;
};

/** A connection to a list of `Block` values. */
export type BlocksConnection = {
  __typename?: 'BlocksConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BlockAggregates>;
  /** A list of edges which contains the `Block` and cursor to aid in pagination. */
  edges: Array<BlocksEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BlockAggregates>>;
  /** A list of `Block` objects. */
  nodes: Array<Block>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Block` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `Block` values. */
export type BlocksConnectionGroupedAggregatesArgs = {
  groupBy: Array<BlockGroupBy>;
  having?: InputMaybe<BlockHavingInput>;
};

/** A `Block` edge in the connection. */
export type BlocksEdge = {
  __typename?: 'BlocksEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Block` at the end of the edge. */
  node: Block;
};

/** Methods to use when ordering `Block`. */
export type BlocksOrderBy =
  | 'CALLS_BY_BLOCK_ID_AVERAGE_ARGS_ASC'
  | 'CALLS_BY_BLOCK_ID_AVERAGE_ARGS_DESC'
  | 'CALLS_BY_BLOCK_ID_AVERAGE_BLOCK_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_AVERAGE_BLOCK_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_AVERAGE_ERROR_ASC'
  | 'CALLS_BY_BLOCK_ID_AVERAGE_ERROR_DESC'
  | 'CALLS_BY_BLOCK_ID_AVERAGE_EXTRINSIC_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_AVERAGE_EXTRINSIC_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_AVERAGE_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_AVERAGE_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_AVERAGE_NAME_ASC'
  | 'CALLS_BY_BLOCK_ID_AVERAGE_NAME_DESC'
  | 'CALLS_BY_BLOCK_ID_AVERAGE_ORIGIN_ASC'
  | 'CALLS_BY_BLOCK_ID_AVERAGE_ORIGIN_DESC'
  | 'CALLS_BY_BLOCK_ID_AVERAGE_PARENT_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_AVERAGE_PARENT_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_AVERAGE_POS_ASC'
  | 'CALLS_BY_BLOCK_ID_AVERAGE_POS_DESC'
  | 'CALLS_BY_BLOCK_ID_AVERAGE_SUCCESS_ASC'
  | 'CALLS_BY_BLOCK_ID_AVERAGE_SUCCESS_DESC'
  | 'CALLS_BY_BLOCK_ID_COUNT_ASC'
  | 'CALLS_BY_BLOCK_ID_COUNT_DESC'
  | 'CALLS_BY_BLOCK_ID_DISTINCT_COUNT_ARGS_ASC'
  | 'CALLS_BY_BLOCK_ID_DISTINCT_COUNT_ARGS_DESC'
  | 'CALLS_BY_BLOCK_ID_DISTINCT_COUNT_BLOCK_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_DISTINCT_COUNT_BLOCK_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_DISTINCT_COUNT_ERROR_ASC'
  | 'CALLS_BY_BLOCK_ID_DISTINCT_COUNT_ERROR_DESC'
  | 'CALLS_BY_BLOCK_ID_DISTINCT_COUNT_EXTRINSIC_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_DISTINCT_COUNT_EXTRINSIC_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_DISTINCT_COUNT_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_DISTINCT_COUNT_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_DISTINCT_COUNT_NAME_ASC'
  | 'CALLS_BY_BLOCK_ID_DISTINCT_COUNT_NAME_DESC'
  | 'CALLS_BY_BLOCK_ID_DISTINCT_COUNT_ORIGIN_ASC'
  | 'CALLS_BY_BLOCK_ID_DISTINCT_COUNT_ORIGIN_DESC'
  | 'CALLS_BY_BLOCK_ID_DISTINCT_COUNT_PARENT_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_DISTINCT_COUNT_PARENT_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_DISTINCT_COUNT_POS_ASC'
  | 'CALLS_BY_BLOCK_ID_DISTINCT_COUNT_POS_DESC'
  | 'CALLS_BY_BLOCK_ID_DISTINCT_COUNT_SUCCESS_ASC'
  | 'CALLS_BY_BLOCK_ID_DISTINCT_COUNT_SUCCESS_DESC'
  | 'CALLS_BY_BLOCK_ID_MAX_ARGS_ASC'
  | 'CALLS_BY_BLOCK_ID_MAX_ARGS_DESC'
  | 'CALLS_BY_BLOCK_ID_MAX_BLOCK_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_MAX_BLOCK_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_MAX_ERROR_ASC'
  | 'CALLS_BY_BLOCK_ID_MAX_ERROR_DESC'
  | 'CALLS_BY_BLOCK_ID_MAX_EXTRINSIC_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_MAX_EXTRINSIC_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_MAX_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_MAX_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_MAX_NAME_ASC'
  | 'CALLS_BY_BLOCK_ID_MAX_NAME_DESC'
  | 'CALLS_BY_BLOCK_ID_MAX_ORIGIN_ASC'
  | 'CALLS_BY_BLOCK_ID_MAX_ORIGIN_DESC'
  | 'CALLS_BY_BLOCK_ID_MAX_PARENT_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_MAX_PARENT_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_MAX_POS_ASC'
  | 'CALLS_BY_BLOCK_ID_MAX_POS_DESC'
  | 'CALLS_BY_BLOCK_ID_MAX_SUCCESS_ASC'
  | 'CALLS_BY_BLOCK_ID_MAX_SUCCESS_DESC'
  | 'CALLS_BY_BLOCK_ID_MIN_ARGS_ASC'
  | 'CALLS_BY_BLOCK_ID_MIN_ARGS_DESC'
  | 'CALLS_BY_BLOCK_ID_MIN_BLOCK_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_MIN_BLOCK_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_MIN_ERROR_ASC'
  | 'CALLS_BY_BLOCK_ID_MIN_ERROR_DESC'
  | 'CALLS_BY_BLOCK_ID_MIN_EXTRINSIC_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_MIN_EXTRINSIC_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_MIN_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_MIN_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_MIN_NAME_ASC'
  | 'CALLS_BY_BLOCK_ID_MIN_NAME_DESC'
  | 'CALLS_BY_BLOCK_ID_MIN_ORIGIN_ASC'
  | 'CALLS_BY_BLOCK_ID_MIN_ORIGIN_DESC'
  | 'CALLS_BY_BLOCK_ID_MIN_PARENT_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_MIN_PARENT_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_MIN_POS_ASC'
  | 'CALLS_BY_BLOCK_ID_MIN_POS_DESC'
  | 'CALLS_BY_BLOCK_ID_MIN_SUCCESS_ASC'
  | 'CALLS_BY_BLOCK_ID_MIN_SUCCESS_DESC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_POPULATION_ARGS_ASC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_POPULATION_ARGS_DESC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_POPULATION_BLOCK_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_POPULATION_BLOCK_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_POPULATION_ERROR_ASC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_POPULATION_ERROR_DESC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_POPULATION_EXTRINSIC_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_POPULATION_EXTRINSIC_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_POPULATION_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_POPULATION_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_POPULATION_NAME_ASC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_POPULATION_NAME_DESC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_POPULATION_ORIGIN_ASC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_POPULATION_ORIGIN_DESC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_POPULATION_PARENT_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_POPULATION_PARENT_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_POPULATION_POS_ASC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_POPULATION_POS_DESC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_POPULATION_SUCCESS_ASC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_POPULATION_SUCCESS_DESC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_SAMPLE_ARGS_ASC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_SAMPLE_ARGS_DESC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_SAMPLE_BLOCK_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_SAMPLE_BLOCK_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_SAMPLE_ERROR_ASC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_SAMPLE_ERROR_DESC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_SAMPLE_EXTRINSIC_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_SAMPLE_EXTRINSIC_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_SAMPLE_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_SAMPLE_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_SAMPLE_NAME_ASC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_SAMPLE_NAME_DESC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_SAMPLE_ORIGIN_ASC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_SAMPLE_ORIGIN_DESC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_SAMPLE_PARENT_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_SAMPLE_PARENT_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_SAMPLE_POS_ASC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_SAMPLE_POS_DESC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_SAMPLE_SUCCESS_ASC'
  | 'CALLS_BY_BLOCK_ID_STDDEV_SAMPLE_SUCCESS_DESC'
  | 'CALLS_BY_BLOCK_ID_SUM_ARGS_ASC'
  | 'CALLS_BY_BLOCK_ID_SUM_ARGS_DESC'
  | 'CALLS_BY_BLOCK_ID_SUM_BLOCK_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_SUM_BLOCK_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_SUM_ERROR_ASC'
  | 'CALLS_BY_BLOCK_ID_SUM_ERROR_DESC'
  | 'CALLS_BY_BLOCK_ID_SUM_EXTRINSIC_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_SUM_EXTRINSIC_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_SUM_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_SUM_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_SUM_NAME_ASC'
  | 'CALLS_BY_BLOCK_ID_SUM_NAME_DESC'
  | 'CALLS_BY_BLOCK_ID_SUM_ORIGIN_ASC'
  | 'CALLS_BY_BLOCK_ID_SUM_ORIGIN_DESC'
  | 'CALLS_BY_BLOCK_ID_SUM_PARENT_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_SUM_PARENT_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_SUM_POS_ASC'
  | 'CALLS_BY_BLOCK_ID_SUM_POS_DESC'
  | 'CALLS_BY_BLOCK_ID_SUM_SUCCESS_ASC'
  | 'CALLS_BY_BLOCK_ID_SUM_SUCCESS_DESC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_POPULATION_ARGS_ASC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_POPULATION_ARGS_DESC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_POPULATION_BLOCK_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_POPULATION_BLOCK_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_POPULATION_ERROR_ASC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_POPULATION_ERROR_DESC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_POPULATION_EXTRINSIC_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_POPULATION_EXTRINSIC_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_POPULATION_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_POPULATION_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_POPULATION_NAME_ASC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_POPULATION_NAME_DESC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_POPULATION_ORIGIN_ASC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_POPULATION_ORIGIN_DESC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_POPULATION_PARENT_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_POPULATION_PARENT_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_POPULATION_POS_ASC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_POPULATION_POS_DESC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_POPULATION_SUCCESS_ASC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_POPULATION_SUCCESS_DESC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_SAMPLE_ARGS_ASC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_SAMPLE_ARGS_DESC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_SAMPLE_BLOCK_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_SAMPLE_BLOCK_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_SAMPLE_ERROR_ASC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_SAMPLE_ERROR_DESC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_SAMPLE_EXTRINSIC_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_SAMPLE_EXTRINSIC_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_SAMPLE_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_SAMPLE_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_SAMPLE_NAME_ASC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_SAMPLE_NAME_DESC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_SAMPLE_ORIGIN_ASC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_SAMPLE_ORIGIN_DESC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_SAMPLE_PARENT_ID_ASC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_SAMPLE_PARENT_ID_DESC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_SAMPLE_POS_ASC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_SAMPLE_POS_DESC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_SAMPLE_SUCCESS_ASC'
  | 'CALLS_BY_BLOCK_ID_VARIANCE_SAMPLE_SUCCESS_DESC'
  | 'EVENTS_BY_BLOCK_ID_AVERAGE_ARGS_ASC'
  | 'EVENTS_BY_BLOCK_ID_AVERAGE_ARGS_DESC'
  | 'EVENTS_BY_BLOCK_ID_AVERAGE_BLOCK_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_AVERAGE_BLOCK_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_AVERAGE_CALL_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_AVERAGE_CALL_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_AVERAGE_EXTRINSIC_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_AVERAGE_EXTRINSIC_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_AVERAGE_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_AVERAGE_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_AVERAGE_INDEX_IN_BLOCK_ASC'
  | 'EVENTS_BY_BLOCK_ID_AVERAGE_INDEX_IN_BLOCK_DESC'
  | 'EVENTS_BY_BLOCK_ID_AVERAGE_NAME_ASC'
  | 'EVENTS_BY_BLOCK_ID_AVERAGE_NAME_DESC'
  | 'EVENTS_BY_BLOCK_ID_AVERAGE_PHASE_ASC'
  | 'EVENTS_BY_BLOCK_ID_AVERAGE_PHASE_DESC'
  | 'EVENTS_BY_BLOCK_ID_AVERAGE_POS_ASC'
  | 'EVENTS_BY_BLOCK_ID_AVERAGE_POS_DESC'
  | 'EVENTS_BY_BLOCK_ID_COUNT_ASC'
  | 'EVENTS_BY_BLOCK_ID_COUNT_DESC'
  | 'EVENTS_BY_BLOCK_ID_DISTINCT_COUNT_ARGS_ASC'
  | 'EVENTS_BY_BLOCK_ID_DISTINCT_COUNT_ARGS_DESC'
  | 'EVENTS_BY_BLOCK_ID_DISTINCT_COUNT_BLOCK_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_DISTINCT_COUNT_BLOCK_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_DISTINCT_COUNT_CALL_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_DISTINCT_COUNT_CALL_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_DISTINCT_COUNT_EXTRINSIC_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_DISTINCT_COUNT_EXTRINSIC_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_DISTINCT_COUNT_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_DISTINCT_COUNT_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_DISTINCT_COUNT_INDEX_IN_BLOCK_ASC'
  | 'EVENTS_BY_BLOCK_ID_DISTINCT_COUNT_INDEX_IN_BLOCK_DESC'
  | 'EVENTS_BY_BLOCK_ID_DISTINCT_COUNT_NAME_ASC'
  | 'EVENTS_BY_BLOCK_ID_DISTINCT_COUNT_NAME_DESC'
  | 'EVENTS_BY_BLOCK_ID_DISTINCT_COUNT_PHASE_ASC'
  | 'EVENTS_BY_BLOCK_ID_DISTINCT_COUNT_PHASE_DESC'
  | 'EVENTS_BY_BLOCK_ID_DISTINCT_COUNT_POS_ASC'
  | 'EVENTS_BY_BLOCK_ID_DISTINCT_COUNT_POS_DESC'
  | 'EVENTS_BY_BLOCK_ID_MAX_ARGS_ASC'
  | 'EVENTS_BY_BLOCK_ID_MAX_ARGS_DESC'
  | 'EVENTS_BY_BLOCK_ID_MAX_BLOCK_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_MAX_BLOCK_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_MAX_CALL_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_MAX_CALL_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_MAX_EXTRINSIC_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_MAX_EXTRINSIC_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_MAX_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_MAX_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_MAX_INDEX_IN_BLOCK_ASC'
  | 'EVENTS_BY_BLOCK_ID_MAX_INDEX_IN_BLOCK_DESC'
  | 'EVENTS_BY_BLOCK_ID_MAX_NAME_ASC'
  | 'EVENTS_BY_BLOCK_ID_MAX_NAME_DESC'
  | 'EVENTS_BY_BLOCK_ID_MAX_PHASE_ASC'
  | 'EVENTS_BY_BLOCK_ID_MAX_PHASE_DESC'
  | 'EVENTS_BY_BLOCK_ID_MAX_POS_ASC'
  | 'EVENTS_BY_BLOCK_ID_MAX_POS_DESC'
  | 'EVENTS_BY_BLOCK_ID_MIN_ARGS_ASC'
  | 'EVENTS_BY_BLOCK_ID_MIN_ARGS_DESC'
  | 'EVENTS_BY_BLOCK_ID_MIN_BLOCK_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_MIN_BLOCK_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_MIN_CALL_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_MIN_CALL_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_MIN_EXTRINSIC_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_MIN_EXTRINSIC_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_MIN_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_MIN_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_MIN_INDEX_IN_BLOCK_ASC'
  | 'EVENTS_BY_BLOCK_ID_MIN_INDEX_IN_BLOCK_DESC'
  | 'EVENTS_BY_BLOCK_ID_MIN_NAME_ASC'
  | 'EVENTS_BY_BLOCK_ID_MIN_NAME_DESC'
  | 'EVENTS_BY_BLOCK_ID_MIN_PHASE_ASC'
  | 'EVENTS_BY_BLOCK_ID_MIN_PHASE_DESC'
  | 'EVENTS_BY_BLOCK_ID_MIN_POS_ASC'
  | 'EVENTS_BY_BLOCK_ID_MIN_POS_DESC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_POPULATION_ARGS_ASC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_POPULATION_ARGS_DESC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_POPULATION_BLOCK_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_POPULATION_BLOCK_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_POPULATION_CALL_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_POPULATION_CALL_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_POPULATION_EXTRINSIC_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_POPULATION_EXTRINSIC_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_POPULATION_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_POPULATION_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_POPULATION_INDEX_IN_BLOCK_ASC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_POPULATION_INDEX_IN_BLOCK_DESC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_POPULATION_NAME_ASC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_POPULATION_NAME_DESC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_POPULATION_PHASE_ASC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_POPULATION_PHASE_DESC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_POPULATION_POS_ASC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_POPULATION_POS_DESC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_SAMPLE_ARGS_ASC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_SAMPLE_ARGS_DESC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_SAMPLE_BLOCK_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_SAMPLE_BLOCK_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_SAMPLE_CALL_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_SAMPLE_CALL_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_SAMPLE_EXTRINSIC_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_SAMPLE_EXTRINSIC_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_SAMPLE_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_SAMPLE_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_SAMPLE_INDEX_IN_BLOCK_ASC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_SAMPLE_INDEX_IN_BLOCK_DESC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_SAMPLE_NAME_ASC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_SAMPLE_NAME_DESC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_SAMPLE_PHASE_ASC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_SAMPLE_PHASE_DESC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_SAMPLE_POS_ASC'
  | 'EVENTS_BY_BLOCK_ID_STDDEV_SAMPLE_POS_DESC'
  | 'EVENTS_BY_BLOCK_ID_SUM_ARGS_ASC'
  | 'EVENTS_BY_BLOCK_ID_SUM_ARGS_DESC'
  | 'EVENTS_BY_BLOCK_ID_SUM_BLOCK_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_SUM_BLOCK_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_SUM_CALL_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_SUM_CALL_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_SUM_EXTRINSIC_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_SUM_EXTRINSIC_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_SUM_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_SUM_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_SUM_INDEX_IN_BLOCK_ASC'
  | 'EVENTS_BY_BLOCK_ID_SUM_INDEX_IN_BLOCK_DESC'
  | 'EVENTS_BY_BLOCK_ID_SUM_NAME_ASC'
  | 'EVENTS_BY_BLOCK_ID_SUM_NAME_DESC'
  | 'EVENTS_BY_BLOCK_ID_SUM_PHASE_ASC'
  | 'EVENTS_BY_BLOCK_ID_SUM_PHASE_DESC'
  | 'EVENTS_BY_BLOCK_ID_SUM_POS_ASC'
  | 'EVENTS_BY_BLOCK_ID_SUM_POS_DESC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_POPULATION_ARGS_ASC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_POPULATION_ARGS_DESC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_POPULATION_BLOCK_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_POPULATION_BLOCK_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_POPULATION_CALL_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_POPULATION_CALL_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_POPULATION_EXTRINSIC_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_POPULATION_EXTRINSIC_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_POPULATION_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_POPULATION_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_POPULATION_INDEX_IN_BLOCK_ASC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_POPULATION_INDEX_IN_BLOCK_DESC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_POPULATION_NAME_ASC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_POPULATION_NAME_DESC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_POPULATION_PHASE_ASC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_POPULATION_PHASE_DESC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_POPULATION_POS_ASC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_POPULATION_POS_DESC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_SAMPLE_ARGS_ASC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_SAMPLE_ARGS_DESC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_SAMPLE_BLOCK_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_SAMPLE_BLOCK_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_SAMPLE_CALL_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_SAMPLE_CALL_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_SAMPLE_EXTRINSIC_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_SAMPLE_EXTRINSIC_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_SAMPLE_ID_ASC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_SAMPLE_ID_DESC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_SAMPLE_INDEX_IN_BLOCK_ASC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_SAMPLE_INDEX_IN_BLOCK_DESC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_SAMPLE_NAME_ASC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_SAMPLE_NAME_DESC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_SAMPLE_PHASE_ASC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_SAMPLE_PHASE_DESC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_SAMPLE_POS_ASC'
  | 'EVENTS_BY_BLOCK_ID_VARIANCE_SAMPLE_POS_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_AVERAGE_BLOCK_ID_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_AVERAGE_BLOCK_ID_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_AVERAGE_CALL_ID_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_AVERAGE_CALL_ID_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_AVERAGE_ERROR_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_AVERAGE_ERROR_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_AVERAGE_FEE_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_AVERAGE_FEE_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_AVERAGE_HASH_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_AVERAGE_HASH_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_AVERAGE_ID_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_AVERAGE_ID_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_AVERAGE_INDEX_IN_BLOCK_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_AVERAGE_INDEX_IN_BLOCK_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_AVERAGE_POS_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_AVERAGE_POS_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_AVERAGE_SIGNATURE_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_AVERAGE_SIGNATURE_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_AVERAGE_SUCCESS_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_AVERAGE_SUCCESS_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_AVERAGE_TIP_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_AVERAGE_TIP_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_AVERAGE_VERSION_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_AVERAGE_VERSION_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_COUNT_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_COUNT_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_DISTINCT_COUNT_BLOCK_ID_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_DISTINCT_COUNT_BLOCK_ID_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_DISTINCT_COUNT_CALL_ID_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_DISTINCT_COUNT_CALL_ID_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_DISTINCT_COUNT_ERROR_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_DISTINCT_COUNT_ERROR_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_DISTINCT_COUNT_FEE_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_DISTINCT_COUNT_FEE_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_DISTINCT_COUNT_HASH_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_DISTINCT_COUNT_HASH_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_DISTINCT_COUNT_ID_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_DISTINCT_COUNT_ID_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_DISTINCT_COUNT_INDEX_IN_BLOCK_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_DISTINCT_COUNT_INDEX_IN_BLOCK_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_DISTINCT_COUNT_POS_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_DISTINCT_COUNT_POS_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_DISTINCT_COUNT_SIGNATURE_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_DISTINCT_COUNT_SIGNATURE_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_DISTINCT_COUNT_SUCCESS_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_DISTINCT_COUNT_SUCCESS_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_DISTINCT_COUNT_TIP_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_DISTINCT_COUNT_TIP_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_DISTINCT_COUNT_VERSION_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_DISTINCT_COUNT_VERSION_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_MAX_BLOCK_ID_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_MAX_BLOCK_ID_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_MAX_CALL_ID_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_MAX_CALL_ID_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_MAX_ERROR_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_MAX_ERROR_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_MAX_FEE_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_MAX_FEE_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_MAX_HASH_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_MAX_HASH_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_MAX_ID_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_MAX_ID_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_MAX_INDEX_IN_BLOCK_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_MAX_INDEX_IN_BLOCK_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_MAX_POS_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_MAX_POS_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_MAX_SIGNATURE_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_MAX_SIGNATURE_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_MAX_SUCCESS_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_MAX_SUCCESS_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_MAX_TIP_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_MAX_TIP_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_MAX_VERSION_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_MAX_VERSION_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_MIN_BLOCK_ID_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_MIN_BLOCK_ID_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_MIN_CALL_ID_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_MIN_CALL_ID_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_MIN_ERROR_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_MIN_ERROR_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_MIN_FEE_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_MIN_FEE_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_MIN_HASH_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_MIN_HASH_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_MIN_ID_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_MIN_ID_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_MIN_INDEX_IN_BLOCK_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_MIN_INDEX_IN_BLOCK_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_MIN_POS_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_MIN_POS_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_MIN_SIGNATURE_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_MIN_SIGNATURE_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_MIN_SUCCESS_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_MIN_SUCCESS_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_MIN_TIP_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_MIN_TIP_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_MIN_VERSION_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_MIN_VERSION_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_POPULATION_BLOCK_ID_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_POPULATION_BLOCK_ID_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_POPULATION_CALL_ID_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_POPULATION_CALL_ID_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_POPULATION_ERROR_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_POPULATION_ERROR_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_POPULATION_FEE_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_POPULATION_FEE_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_POPULATION_HASH_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_POPULATION_HASH_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_POPULATION_ID_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_POPULATION_ID_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_POPULATION_INDEX_IN_BLOCK_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_POPULATION_INDEX_IN_BLOCK_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_POPULATION_POS_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_POPULATION_POS_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_POPULATION_SIGNATURE_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_POPULATION_SIGNATURE_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_POPULATION_SUCCESS_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_POPULATION_SUCCESS_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_POPULATION_TIP_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_POPULATION_TIP_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_POPULATION_VERSION_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_POPULATION_VERSION_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_SAMPLE_BLOCK_ID_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_SAMPLE_BLOCK_ID_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_SAMPLE_CALL_ID_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_SAMPLE_CALL_ID_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_SAMPLE_ERROR_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_SAMPLE_ERROR_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_SAMPLE_FEE_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_SAMPLE_FEE_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_SAMPLE_HASH_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_SAMPLE_HASH_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_SAMPLE_ID_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_SAMPLE_ID_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_SAMPLE_INDEX_IN_BLOCK_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_SAMPLE_INDEX_IN_BLOCK_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_SAMPLE_POS_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_SAMPLE_POS_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_SAMPLE_SIGNATURE_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_SAMPLE_SIGNATURE_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_SAMPLE_SUCCESS_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_SAMPLE_SUCCESS_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_SAMPLE_TIP_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_SAMPLE_TIP_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_SAMPLE_VERSION_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_STDDEV_SAMPLE_VERSION_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_SUM_BLOCK_ID_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_SUM_BLOCK_ID_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_SUM_CALL_ID_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_SUM_CALL_ID_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_SUM_ERROR_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_SUM_ERROR_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_SUM_FEE_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_SUM_FEE_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_SUM_HASH_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_SUM_HASH_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_SUM_ID_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_SUM_ID_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_SUM_INDEX_IN_BLOCK_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_SUM_INDEX_IN_BLOCK_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_SUM_POS_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_SUM_POS_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_SUM_SIGNATURE_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_SUM_SIGNATURE_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_SUM_SUCCESS_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_SUM_SUCCESS_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_SUM_TIP_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_SUM_TIP_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_SUM_VERSION_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_SUM_VERSION_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_POPULATION_BLOCK_ID_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_POPULATION_BLOCK_ID_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_POPULATION_CALL_ID_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_POPULATION_CALL_ID_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_POPULATION_ERROR_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_POPULATION_ERROR_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_POPULATION_FEE_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_POPULATION_FEE_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_POPULATION_HASH_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_POPULATION_HASH_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_POPULATION_ID_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_POPULATION_ID_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_POPULATION_INDEX_IN_BLOCK_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_POPULATION_INDEX_IN_BLOCK_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_POPULATION_POS_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_POPULATION_POS_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_POPULATION_SIGNATURE_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_POPULATION_SIGNATURE_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_POPULATION_SUCCESS_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_POPULATION_SUCCESS_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_POPULATION_TIP_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_POPULATION_TIP_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_POPULATION_VERSION_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_POPULATION_VERSION_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_SAMPLE_BLOCK_ID_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_SAMPLE_BLOCK_ID_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_SAMPLE_CALL_ID_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_SAMPLE_CALL_ID_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_SAMPLE_ERROR_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_SAMPLE_ERROR_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_SAMPLE_FEE_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_SAMPLE_FEE_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_SAMPLE_HASH_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_SAMPLE_HASH_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_SAMPLE_ID_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_SAMPLE_ID_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_SAMPLE_INDEX_IN_BLOCK_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_SAMPLE_INDEX_IN_BLOCK_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_SAMPLE_POS_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_SAMPLE_POS_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_SAMPLE_SIGNATURE_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_SAMPLE_SIGNATURE_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_SAMPLE_SUCCESS_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_SAMPLE_SUCCESS_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_SAMPLE_TIP_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_SAMPLE_TIP_DESC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_SAMPLE_VERSION_ASC'
  | 'EXTRINSICS_BY_BLOCK_ID_VARIANCE_SAMPLE_VERSION_DESC'
  | 'EXTRINSICS_ROOT_ASC'
  | 'EXTRINSICS_ROOT_DESC'
  | 'HASH_ASC'
  | 'HASH_DESC'
  | 'HEIGHT_ASC'
  | 'HEIGHT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PARENT_HASH_ASC'
  | 'PARENT_HASH_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SPEC_ID_ASC'
  | 'SPEC_ID_DESC'
  | 'STATE_ROOT_ASC'
  | 'STATE_ROOT_DESC'
  | 'TIMESTAMP_ASC'
  | 'TIMESTAMP_DESC'
  | 'VALIDATOR_ASC'
  | 'VALIDATOR_DESC';

/** A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’ */
export type BooleanFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Boolean']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Boolean']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Boolean']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};

export type BoostBalance = {
  __typename?: 'BoostBalance';
  availableAmount: Scalars['BigFloat']['output'];
  availableAmountValueUsd: Scalars['BigFloat']['output'];
  /** Reads a single `BoostPool` that is related to this `BoostBalance`. */
  boostPoolByPoolId: BoostPool;
  /** Reads a single `LpAccount` that is related to this `BoostBalance`. */
  lpAccountByLpIdSs58: LpAccount;
  lpIdSs58: Scalars['String']['output'];
  poolId: Scalars['Int']['output'];
  poolShare: Scalars['Float']['output'];
  unavailableAmount: Scalars['BigFloat']['output'];
  unavailableAmountValueUsd: Scalars['BigFloat']['output'];
};

export type BoostBalanceAggregates = {
  __typename?: 'BoostBalanceAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<BoostBalanceAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<BoostBalanceDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<BoostBalanceMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<BoostBalanceMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<BoostBalanceStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<BoostBalanceStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<BoostBalanceSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<BoostBalanceVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<BoostBalanceVarianceSampleAggregates>;
};

/** A filter to be used against aggregates of `BoostBalance` object types. */
export type BoostBalanceAggregatesFilter = {
  /** Mean average aggregate over matching `BoostBalance` objects. */
  average?: InputMaybe<BoostBalanceAverageAggregateFilter>;
  /** Distinct count aggregate over matching `BoostBalance` objects. */
  distinctCount?: InputMaybe<BoostBalanceDistinctCountAggregateFilter>;
  /** A filter that must pass for the relevant `BoostBalance` object to be included within the aggregate. */
  filter?: InputMaybe<BoostBalanceFilter>;
  /** Maximum aggregate over matching `BoostBalance` objects. */
  max?: InputMaybe<BoostBalanceMaxAggregateFilter>;
  /** Minimum aggregate over matching `BoostBalance` objects. */
  min?: InputMaybe<BoostBalanceMinAggregateFilter>;
  /** Population standard deviation aggregate over matching `BoostBalance` objects. */
  stddevPopulation?: InputMaybe<BoostBalanceStddevPopulationAggregateFilter>;
  /** Sample standard deviation aggregate over matching `BoostBalance` objects. */
  stddevSample?: InputMaybe<BoostBalanceStddevSampleAggregateFilter>;
  /** Sum aggregate over matching `BoostBalance` objects. */
  sum?: InputMaybe<BoostBalanceSumAggregateFilter>;
  /** Population variance aggregate over matching `BoostBalance` objects. */
  variancePopulation?: InputMaybe<BoostBalanceVariancePopulationAggregateFilter>;
  /** Sample variance aggregate over matching `BoostBalance` objects. */
  varianceSample?: InputMaybe<BoostBalanceVarianceSampleAggregateFilter>;
};

export type BoostBalanceAverageAggregateFilter = {
  availableAmount?: InputMaybe<BigFloatFilter>;
  availableAmountValueUsd?: InputMaybe<BigFloatFilter>;
  poolId?: InputMaybe<BigFloatFilter>;
  poolShare?: InputMaybe<FloatFilter>;
  unavailableAmount?: InputMaybe<BigFloatFilter>;
  unavailableAmountValueUsd?: InputMaybe<BigFloatFilter>;
};

export type BoostBalanceAverageAggregates = {
  __typename?: 'BoostBalanceAverageAggregates';
  /** Mean average of availableAmount across the matching connection */
  availableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of availableAmountValueUsd across the matching connection */
  availableAmountValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of poolId across the matching connection */
  poolId?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of poolShare across the matching connection */
  poolShare?: Maybe<Scalars['Float']['output']>;
  /** Mean average of unavailableAmount across the matching connection */
  unavailableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of unavailableAmountValueUsd across the matching connection */
  unavailableAmountValueUsd?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `BoostBalance` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type BoostBalanceCondition = {
  /** Checks for equality with the object’s `availableAmount` field. */
  availableAmount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `availableAmountValueUsd` field. */
  availableAmountValueUsd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `lpIdSs58` field. */
  lpIdSs58?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `poolId` field. */
  poolId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `poolShare` field. */
  poolShare?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `unavailableAmount` field. */
  unavailableAmount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `unavailableAmountValueUsd` field. */
  unavailableAmountValueUsd?: InputMaybe<Scalars['BigFloat']['input']>;
};

export type BoostBalanceDistinctCountAggregateFilter = {
  availableAmount?: InputMaybe<BigIntFilter>;
  availableAmountValueUsd?: InputMaybe<BigIntFilter>;
  lpIdSs58?: InputMaybe<BigIntFilter>;
  poolId?: InputMaybe<BigIntFilter>;
  poolShare?: InputMaybe<BigIntFilter>;
  unavailableAmount?: InputMaybe<BigIntFilter>;
  unavailableAmountValueUsd?: InputMaybe<BigIntFilter>;
};

export type BoostBalanceDistinctCountAggregates = {
  __typename?: 'BoostBalanceDistinctCountAggregates';
  /** Distinct count of availableAmount across the matching connection */
  availableAmount?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of availableAmountValueUsd across the matching connection */
  availableAmountValueUsd?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of lpIdSs58 across the matching connection */
  lpIdSs58?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of poolId across the matching connection */
  poolId?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of poolShare across the matching connection */
  poolShare?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of unavailableAmount across the matching connection */
  unavailableAmount?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of unavailableAmountValueUsd across the matching connection */
  unavailableAmountValueUsd?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `BoostBalance` object types. All fields are combined with a logical ‘and.’ */
export type BoostBalanceFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<BoostBalanceFilter>>;
  /** Filter by the object’s `availableAmount` field. */
  availableAmount?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `availableAmountValueUsd` field. */
  availableAmountValueUsd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `boostPoolByPoolId` relation. */
  boostPoolByPoolId?: InputMaybe<BoostPoolFilter>;
  /** Filter by the object’s `lpAccountByLpIdSs58` relation. */
  lpAccountByLpIdSs58?: InputMaybe<LpAccountFilter>;
  /** Filter by the object’s `lpIdSs58` field. */
  lpIdSs58?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<BoostBalanceFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<BoostBalanceFilter>>;
  /** Filter by the object’s `poolId` field. */
  poolId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `poolShare` field. */
  poolShare?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `unavailableAmount` field. */
  unavailableAmount?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `unavailableAmountValueUsd` field. */
  unavailableAmountValueUsd?: InputMaybe<BigFloatFilter>;
};

/** Grouping methods for `BoostBalance` for usage during aggregation. */
export type BoostBalanceGroupBy =
  | 'AVAILABLE_AMOUNT'
  | 'AVAILABLE_AMOUNT_VALUE_USD'
  | 'LP_ID_SS58'
  | 'POOL_ID'
  | 'POOL_SHARE'
  | 'UNAVAILABLE_AMOUNT'
  | 'UNAVAILABLE_AMOUNT_VALUE_USD';

export type BoostBalanceHavingAverageInput = {
  availableAmount?: InputMaybe<HavingBigfloatFilter>;
  availableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
  poolId?: InputMaybe<HavingIntFilter>;
  poolShare?: InputMaybe<HavingFloatFilter>;
  unavailableAmount?: InputMaybe<HavingBigfloatFilter>;
  unavailableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type BoostBalanceHavingDistinctCountInput = {
  availableAmount?: InputMaybe<HavingBigfloatFilter>;
  availableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
  poolId?: InputMaybe<HavingIntFilter>;
  poolShare?: InputMaybe<HavingFloatFilter>;
  unavailableAmount?: InputMaybe<HavingBigfloatFilter>;
  unavailableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
};

/** Conditions for `BoostBalance` aggregates. */
export type BoostBalanceHavingInput = {
  AND?: InputMaybe<Array<BoostBalanceHavingInput>>;
  OR?: InputMaybe<Array<BoostBalanceHavingInput>>;
  average?: InputMaybe<BoostBalanceHavingAverageInput>;
  distinctCount?: InputMaybe<BoostBalanceHavingDistinctCountInput>;
  max?: InputMaybe<BoostBalanceHavingMaxInput>;
  min?: InputMaybe<BoostBalanceHavingMinInput>;
  stddevPopulation?: InputMaybe<BoostBalanceHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<BoostBalanceHavingStddevSampleInput>;
  sum?: InputMaybe<BoostBalanceHavingSumInput>;
  variancePopulation?: InputMaybe<BoostBalanceHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<BoostBalanceHavingVarianceSampleInput>;
};

export type BoostBalanceHavingMaxInput = {
  availableAmount?: InputMaybe<HavingBigfloatFilter>;
  availableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
  poolId?: InputMaybe<HavingIntFilter>;
  poolShare?: InputMaybe<HavingFloatFilter>;
  unavailableAmount?: InputMaybe<HavingBigfloatFilter>;
  unavailableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type BoostBalanceHavingMinInput = {
  availableAmount?: InputMaybe<HavingBigfloatFilter>;
  availableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
  poolId?: InputMaybe<HavingIntFilter>;
  poolShare?: InputMaybe<HavingFloatFilter>;
  unavailableAmount?: InputMaybe<HavingBigfloatFilter>;
  unavailableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type BoostBalanceHavingStddevPopulationInput = {
  availableAmount?: InputMaybe<HavingBigfloatFilter>;
  availableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
  poolId?: InputMaybe<HavingIntFilter>;
  poolShare?: InputMaybe<HavingFloatFilter>;
  unavailableAmount?: InputMaybe<HavingBigfloatFilter>;
  unavailableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type BoostBalanceHavingStddevSampleInput = {
  availableAmount?: InputMaybe<HavingBigfloatFilter>;
  availableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
  poolId?: InputMaybe<HavingIntFilter>;
  poolShare?: InputMaybe<HavingFloatFilter>;
  unavailableAmount?: InputMaybe<HavingBigfloatFilter>;
  unavailableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type BoostBalanceHavingSumInput = {
  availableAmount?: InputMaybe<HavingBigfloatFilter>;
  availableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
  poolId?: InputMaybe<HavingIntFilter>;
  poolShare?: InputMaybe<HavingFloatFilter>;
  unavailableAmount?: InputMaybe<HavingBigfloatFilter>;
  unavailableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type BoostBalanceHavingVariancePopulationInput = {
  availableAmount?: InputMaybe<HavingBigfloatFilter>;
  availableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
  poolId?: InputMaybe<HavingIntFilter>;
  poolShare?: InputMaybe<HavingFloatFilter>;
  unavailableAmount?: InputMaybe<HavingBigfloatFilter>;
  unavailableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type BoostBalanceHavingVarianceSampleInput = {
  availableAmount?: InputMaybe<HavingBigfloatFilter>;
  availableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
  poolId?: InputMaybe<HavingIntFilter>;
  poolShare?: InputMaybe<HavingFloatFilter>;
  unavailableAmount?: InputMaybe<HavingBigfloatFilter>;
  unavailableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type BoostBalanceMaxAggregateFilter = {
  availableAmount?: InputMaybe<BigFloatFilter>;
  availableAmountValueUsd?: InputMaybe<BigFloatFilter>;
  poolId?: InputMaybe<IntFilter>;
  poolShare?: InputMaybe<FloatFilter>;
  unavailableAmount?: InputMaybe<BigFloatFilter>;
  unavailableAmountValueUsd?: InputMaybe<BigFloatFilter>;
};

export type BoostBalanceMaxAggregates = {
  __typename?: 'BoostBalanceMaxAggregates';
  /** Maximum of availableAmount across the matching connection */
  availableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of availableAmountValueUsd across the matching connection */
  availableAmountValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of poolId across the matching connection */
  poolId?: Maybe<Scalars['Int']['output']>;
  /** Maximum of poolShare across the matching connection */
  poolShare?: Maybe<Scalars['Float']['output']>;
  /** Maximum of unavailableAmount across the matching connection */
  unavailableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of unavailableAmountValueUsd across the matching connection */
  unavailableAmountValueUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type BoostBalanceMinAggregateFilter = {
  availableAmount?: InputMaybe<BigFloatFilter>;
  availableAmountValueUsd?: InputMaybe<BigFloatFilter>;
  poolId?: InputMaybe<IntFilter>;
  poolShare?: InputMaybe<FloatFilter>;
  unavailableAmount?: InputMaybe<BigFloatFilter>;
  unavailableAmountValueUsd?: InputMaybe<BigFloatFilter>;
};

export type BoostBalanceMinAggregates = {
  __typename?: 'BoostBalanceMinAggregates';
  /** Minimum of availableAmount across the matching connection */
  availableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of availableAmountValueUsd across the matching connection */
  availableAmountValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of poolId across the matching connection */
  poolId?: Maybe<Scalars['Int']['output']>;
  /** Minimum of poolShare across the matching connection */
  poolShare?: Maybe<Scalars['Float']['output']>;
  /** Minimum of unavailableAmount across the matching connection */
  unavailableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of unavailableAmountValueUsd across the matching connection */
  unavailableAmountValueUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type BoostBalanceStddevPopulationAggregateFilter = {
  availableAmount?: InputMaybe<BigFloatFilter>;
  availableAmountValueUsd?: InputMaybe<BigFloatFilter>;
  poolId?: InputMaybe<BigFloatFilter>;
  poolShare?: InputMaybe<FloatFilter>;
  unavailableAmount?: InputMaybe<BigFloatFilter>;
  unavailableAmountValueUsd?: InputMaybe<BigFloatFilter>;
};

export type BoostBalanceStddevPopulationAggregates = {
  __typename?: 'BoostBalanceStddevPopulationAggregates';
  /** Population standard deviation of availableAmount across the matching connection */
  availableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of availableAmountValueUsd across the matching connection */
  availableAmountValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of poolId across the matching connection */
  poolId?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of poolShare across the matching connection */
  poolShare?: Maybe<Scalars['Float']['output']>;
  /** Population standard deviation of unavailableAmount across the matching connection */
  unavailableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of unavailableAmountValueUsd across the matching connection */
  unavailableAmountValueUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type BoostBalanceStddevSampleAggregateFilter = {
  availableAmount?: InputMaybe<BigFloatFilter>;
  availableAmountValueUsd?: InputMaybe<BigFloatFilter>;
  poolId?: InputMaybe<BigFloatFilter>;
  poolShare?: InputMaybe<FloatFilter>;
  unavailableAmount?: InputMaybe<BigFloatFilter>;
  unavailableAmountValueUsd?: InputMaybe<BigFloatFilter>;
};

export type BoostBalanceStddevSampleAggregates = {
  __typename?: 'BoostBalanceStddevSampleAggregates';
  /** Sample standard deviation of availableAmount across the matching connection */
  availableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of availableAmountValueUsd across the matching connection */
  availableAmountValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of poolId across the matching connection */
  poolId?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of poolShare across the matching connection */
  poolShare?: Maybe<Scalars['Float']['output']>;
  /** Sample standard deviation of unavailableAmount across the matching connection */
  unavailableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of unavailableAmountValueUsd across the matching connection */
  unavailableAmountValueUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type BoostBalanceSumAggregateFilter = {
  availableAmount?: InputMaybe<BigFloatFilter>;
  availableAmountValueUsd?: InputMaybe<BigFloatFilter>;
  poolId?: InputMaybe<BigIntFilter>;
  poolShare?: InputMaybe<FloatFilter>;
  unavailableAmount?: InputMaybe<BigFloatFilter>;
  unavailableAmountValueUsd?: InputMaybe<BigFloatFilter>;
};

export type BoostBalanceSumAggregates = {
  __typename?: 'BoostBalanceSumAggregates';
  /** Sum of availableAmount across the matching connection */
  availableAmount: Scalars['BigFloat']['output'];
  /** Sum of availableAmountValueUsd across the matching connection */
  availableAmountValueUsd: Scalars['BigFloat']['output'];
  /** Sum of poolId across the matching connection */
  poolId: Scalars['BigInt']['output'];
  /** Sum of poolShare across the matching connection */
  poolShare: Scalars['Float']['output'];
  /** Sum of unavailableAmount across the matching connection */
  unavailableAmount: Scalars['BigFloat']['output'];
  /** Sum of unavailableAmountValueUsd across the matching connection */
  unavailableAmountValueUsd: Scalars['BigFloat']['output'];
};

export type BoostBalanceVariancePopulationAggregateFilter = {
  availableAmount?: InputMaybe<BigFloatFilter>;
  availableAmountValueUsd?: InputMaybe<BigFloatFilter>;
  poolId?: InputMaybe<BigFloatFilter>;
  poolShare?: InputMaybe<FloatFilter>;
  unavailableAmount?: InputMaybe<BigFloatFilter>;
  unavailableAmountValueUsd?: InputMaybe<BigFloatFilter>;
};

export type BoostBalanceVariancePopulationAggregates = {
  __typename?: 'BoostBalanceVariancePopulationAggregates';
  /** Population variance of availableAmount across the matching connection */
  availableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of availableAmountValueUsd across the matching connection */
  availableAmountValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of poolId across the matching connection */
  poolId?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of poolShare across the matching connection */
  poolShare?: Maybe<Scalars['Float']['output']>;
  /** Population variance of unavailableAmount across the matching connection */
  unavailableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of unavailableAmountValueUsd across the matching connection */
  unavailableAmountValueUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type BoostBalanceVarianceSampleAggregateFilter = {
  availableAmount?: InputMaybe<BigFloatFilter>;
  availableAmountValueUsd?: InputMaybe<BigFloatFilter>;
  poolId?: InputMaybe<BigFloatFilter>;
  poolShare?: InputMaybe<FloatFilter>;
  unavailableAmount?: InputMaybe<BigFloatFilter>;
  unavailableAmountValueUsd?: InputMaybe<BigFloatFilter>;
};

export type BoostBalanceVarianceSampleAggregates = {
  __typename?: 'BoostBalanceVarianceSampleAggregates';
  /** Sample variance of availableAmount across the matching connection */
  availableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of availableAmountValueUsd across the matching connection */
  availableAmountValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of poolId across the matching connection */
  poolId?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of poolShare across the matching connection */
  poolShare?: Maybe<Scalars['Float']['output']>;
  /** Sample variance of unavailableAmount across the matching connection */
  unavailableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of unavailableAmountValueUsd across the matching connection */
  unavailableAmountValueUsd?: Maybe<Scalars['BigFloat']['output']>;
};

/** A connection to a list of `BoostBalance` values. */
export type BoostBalancesConnection = {
  __typename?: 'BoostBalancesConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BoostBalanceAggregates>;
  /** A list of edges which contains the `BoostBalance` and cursor to aid in pagination. */
  edges: Array<BoostBalancesEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BoostBalanceAggregates>>;
  /** A list of `BoostBalance` objects. */
  nodes: Array<BoostBalance>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `BoostBalance` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `BoostBalance` values. */
export type BoostBalancesConnectionGroupedAggregatesArgs = {
  groupBy: Array<BoostBalanceGroupBy>;
  having?: InputMaybe<BoostBalanceHavingInput>;
};

/** A `BoostBalance` edge in the connection. */
export type BoostBalancesEdge = {
  __typename?: 'BoostBalancesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `BoostBalance` at the end of the edge. */
  node: BoostBalance;
};

/** Methods to use when ordering `BoostBalance`. */
export type BoostBalancesOrderBy =
  | 'AVAILABLE_AMOUNT_ASC'
  | 'AVAILABLE_AMOUNT_DESC'
  | 'AVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'AVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'LP_ID_SS58_ASC'
  | 'LP_ID_SS58_DESC'
  | 'NATURAL'
  | 'POOL_ID_ASC'
  | 'POOL_ID_DESC'
  | 'POOL_SHARE_ASC'
  | 'POOL_SHARE_DESC'
  | 'UNAVAILABLE_AMOUNT_ASC'
  | 'UNAVAILABLE_AMOUNT_DESC'
  | 'UNAVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'UNAVAILABLE_AMOUNT_VALUE_USD_DESC';

export type BoostDelayChainflipBlock = Node & {
  __typename?: 'BoostDelayChainflipBlock';
  chain: ChainflipChain;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  numBlocks: Scalars['Int']['output'];
};

export type BoostDelayChainflipBlockAggregates = {
  __typename?: 'BoostDelayChainflipBlockAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<BoostDelayChainflipBlockAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<BoostDelayChainflipBlockDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<BoostDelayChainflipBlockMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<BoostDelayChainflipBlockMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<BoostDelayChainflipBlockStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<BoostDelayChainflipBlockStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<BoostDelayChainflipBlockSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<BoostDelayChainflipBlockVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<BoostDelayChainflipBlockVarianceSampleAggregates>;
};

export type BoostDelayChainflipBlockAverageAggregates = {
  __typename?: 'BoostDelayChainflipBlockAverageAggregates';
  /** Mean average of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of numBlocks across the matching connection */
  numBlocks?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `BoostDelayChainflipBlock` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type BoostDelayChainflipBlockCondition = {
  /** Checks for equality with the object’s `chain` field. */
  chain?: InputMaybe<ChainflipChain>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `numBlocks` field. */
  numBlocks?: InputMaybe<Scalars['Int']['input']>;
};

export type BoostDelayChainflipBlockDistinctCountAggregates = {
  __typename?: 'BoostDelayChainflipBlockDistinctCountAggregates';
  /** Distinct count of chain across the matching connection */
  chain?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of id across the matching connection */
  id?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of numBlocks across the matching connection */
  numBlocks?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `BoostDelayChainflipBlock` object types. All fields are combined with a logical ‘and.’ */
export type BoostDelayChainflipBlockFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<BoostDelayChainflipBlockFilter>>;
  /** Filter by the object’s `chain` field. */
  chain?: InputMaybe<ChainflipChainFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<BoostDelayChainflipBlockFilter>;
  /** Filter by the object’s `numBlocks` field. */
  numBlocks?: InputMaybe<IntFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<BoostDelayChainflipBlockFilter>>;
};

export type BoostDelayChainflipBlockMaxAggregates = {
  __typename?: 'BoostDelayChainflipBlockMaxAggregates';
  /** Maximum of id across the matching connection */
  id?: Maybe<Scalars['Int']['output']>;
  /** Maximum of numBlocks across the matching connection */
  numBlocks?: Maybe<Scalars['Int']['output']>;
};

export type BoostDelayChainflipBlockMinAggregates = {
  __typename?: 'BoostDelayChainflipBlockMinAggregates';
  /** Minimum of id across the matching connection */
  id?: Maybe<Scalars['Int']['output']>;
  /** Minimum of numBlocks across the matching connection */
  numBlocks?: Maybe<Scalars['Int']['output']>;
};

export type BoostDelayChainflipBlockStddevPopulationAggregates = {
  __typename?: 'BoostDelayChainflipBlockStddevPopulationAggregates';
  /** Population standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of numBlocks across the matching connection */
  numBlocks?: Maybe<Scalars['BigFloat']['output']>;
};

export type BoostDelayChainflipBlockStddevSampleAggregates = {
  __typename?: 'BoostDelayChainflipBlockStddevSampleAggregates';
  /** Sample standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of numBlocks across the matching connection */
  numBlocks?: Maybe<Scalars['BigFloat']['output']>;
};

export type BoostDelayChainflipBlockSumAggregates = {
  __typename?: 'BoostDelayChainflipBlockSumAggregates';
  /** Sum of id across the matching connection */
  id: Scalars['BigInt']['output'];
  /** Sum of numBlocks across the matching connection */
  numBlocks: Scalars['BigInt']['output'];
};

export type BoostDelayChainflipBlockVariancePopulationAggregates = {
  __typename?: 'BoostDelayChainflipBlockVariancePopulationAggregates';
  /** Population variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of numBlocks across the matching connection */
  numBlocks?: Maybe<Scalars['BigFloat']['output']>;
};

export type BoostDelayChainflipBlockVarianceSampleAggregates = {
  __typename?: 'BoostDelayChainflipBlockVarianceSampleAggregates';
  /** Sample variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of numBlocks across the matching connection */
  numBlocks?: Maybe<Scalars['BigFloat']['output']>;
};

/** A connection to a list of `BoostDelayChainflipBlock` values. */
export type BoostDelayChainflipBlocksConnection = {
  __typename?: 'BoostDelayChainflipBlocksConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BoostDelayChainflipBlockAggregates>;
  /** A list of edges which contains the `BoostDelayChainflipBlock` and cursor to aid in pagination. */
  edges: Array<BoostDelayChainflipBlocksEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BoostDelayChainflipBlockAggregates>>;
  /** A list of `BoostDelayChainflipBlock` objects. */
  nodes: Array<BoostDelayChainflipBlock>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `BoostDelayChainflipBlock` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `BoostDelayChainflipBlock` values. */
export type BoostDelayChainflipBlocksConnectionGroupedAggregatesArgs = {
  groupBy: Array<BoostDelayChainflipBlocksGroupBy>;
  having?: InputMaybe<BoostDelayChainflipBlocksHavingInput>;
};

/** A `BoostDelayChainflipBlock` edge in the connection. */
export type BoostDelayChainflipBlocksEdge = {
  __typename?: 'BoostDelayChainflipBlocksEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `BoostDelayChainflipBlock` at the end of the edge. */
  node: BoostDelayChainflipBlock;
};

/** Grouping methods for `BoostDelayChainflipBlock` for usage during aggregation. */
export type BoostDelayChainflipBlocksGroupBy =
  | 'NUM_BLOCKS';

export type BoostDelayChainflipBlocksHavingAverageInput = {
  id?: InputMaybe<HavingIntFilter>;
  numBlocks?: InputMaybe<HavingIntFilter>;
};

export type BoostDelayChainflipBlocksHavingDistinctCountInput = {
  id?: InputMaybe<HavingIntFilter>;
  numBlocks?: InputMaybe<HavingIntFilter>;
};

/** Conditions for `BoostDelayChainflipBlock` aggregates. */
export type BoostDelayChainflipBlocksHavingInput = {
  AND?: InputMaybe<Array<BoostDelayChainflipBlocksHavingInput>>;
  OR?: InputMaybe<Array<BoostDelayChainflipBlocksHavingInput>>;
  average?: InputMaybe<BoostDelayChainflipBlocksHavingAverageInput>;
  distinctCount?: InputMaybe<BoostDelayChainflipBlocksHavingDistinctCountInput>;
  max?: InputMaybe<BoostDelayChainflipBlocksHavingMaxInput>;
  min?: InputMaybe<BoostDelayChainflipBlocksHavingMinInput>;
  stddevPopulation?: InputMaybe<BoostDelayChainflipBlocksHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<BoostDelayChainflipBlocksHavingStddevSampleInput>;
  sum?: InputMaybe<BoostDelayChainflipBlocksHavingSumInput>;
  variancePopulation?: InputMaybe<BoostDelayChainflipBlocksHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<BoostDelayChainflipBlocksHavingVarianceSampleInput>;
};

export type BoostDelayChainflipBlocksHavingMaxInput = {
  id?: InputMaybe<HavingIntFilter>;
  numBlocks?: InputMaybe<HavingIntFilter>;
};

export type BoostDelayChainflipBlocksHavingMinInput = {
  id?: InputMaybe<HavingIntFilter>;
  numBlocks?: InputMaybe<HavingIntFilter>;
};

export type BoostDelayChainflipBlocksHavingStddevPopulationInput = {
  id?: InputMaybe<HavingIntFilter>;
  numBlocks?: InputMaybe<HavingIntFilter>;
};

export type BoostDelayChainflipBlocksHavingStddevSampleInput = {
  id?: InputMaybe<HavingIntFilter>;
  numBlocks?: InputMaybe<HavingIntFilter>;
};

export type BoostDelayChainflipBlocksHavingSumInput = {
  id?: InputMaybe<HavingIntFilter>;
  numBlocks?: InputMaybe<HavingIntFilter>;
};

export type BoostDelayChainflipBlocksHavingVariancePopulationInput = {
  id?: InputMaybe<HavingIntFilter>;
  numBlocks?: InputMaybe<HavingIntFilter>;
};

export type BoostDelayChainflipBlocksHavingVarianceSampleInput = {
  id?: InputMaybe<HavingIntFilter>;
  numBlocks?: InputMaybe<HavingIntFilter>;
};

/** Methods to use when ordering `BoostDelayChainflipBlock`. */
export type BoostDelayChainflipBlocksOrderBy =
  | 'CHAIN_ASC'
  | 'CHAIN_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'NUM_BLOCKS_ASC'
  | 'NUM_BLOCKS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

export type BoostPool = Node & {
  __typename?: 'BoostPool';
  asset: ChainflipAsset;
  availableAmount: Scalars['BigFloat']['output'];
  availableAmountValueUsd: Scalars['BigFloat']['output'];
  /** Reads and enables pagination through a set of `BoostBalance`. */
  boostBalancesByPoolId: BoostBalancesConnection;
  chain: ChainflipChain;
  feeTierPips: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  unavailableAmount: Scalars['BigFloat']['output'];
  unavailableAmountValueUsd: Scalars['BigFloat']['output'];
};


export type BoostPoolBoostBalancesByPoolIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<BoostBalanceCondition>;
  filter?: InputMaybe<BoostBalanceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BoostBalancesOrderBy>>;
};

export type BoostPoolAggregates = {
  __typename?: 'BoostPoolAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<BoostPoolAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<BoostPoolDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<BoostPoolMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<BoostPoolMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<BoostPoolStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<BoostPoolStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<BoostPoolSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<BoostPoolVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<BoostPoolVarianceSampleAggregates>;
};

export type BoostPoolAverageAggregates = {
  __typename?: 'BoostPoolAverageAggregates';
  /** Mean average of availableAmount across the matching connection */
  availableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of availableAmountValueUsd across the matching connection */
  availableAmountValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of feeTierPips across the matching connection */
  feeTierPips?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of unavailableAmount across the matching connection */
  unavailableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of unavailableAmountValueUsd across the matching connection */
  unavailableAmountValueUsd?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `BoostPool` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type BoostPoolCondition = {
  /** Checks for equality with the object’s `asset` field. */
  asset?: InputMaybe<ChainflipAsset>;
  /** Checks for equality with the object’s `availableAmount` field. */
  availableAmount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `availableAmountValueUsd` field. */
  availableAmountValueUsd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `chain` field. */
  chain?: InputMaybe<ChainflipChain>;
  /** Checks for equality with the object’s `feeTierPips` field. */
  feeTierPips?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `unavailableAmount` field. */
  unavailableAmount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `unavailableAmountValueUsd` field. */
  unavailableAmountValueUsd?: InputMaybe<Scalars['BigFloat']['input']>;
};

export type BoostPoolDistinctCountAggregates = {
  __typename?: 'BoostPoolDistinctCountAggregates';
  /** Distinct count of asset across the matching connection */
  asset?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of availableAmount across the matching connection */
  availableAmount?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of availableAmountValueUsd across the matching connection */
  availableAmountValueUsd?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of chain across the matching connection */
  chain?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of feeTierPips across the matching connection */
  feeTierPips?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of id across the matching connection */
  id?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of unavailableAmount across the matching connection */
  unavailableAmount?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of unavailableAmountValueUsd across the matching connection */
  unavailableAmountValueUsd?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `BoostPool` object types. All fields are combined with a logical ‘and.’ */
export type BoostPoolFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<BoostPoolFilter>>;
  /** Filter by the object’s `asset` field. */
  asset?: InputMaybe<ChainflipAssetFilter>;
  /** Filter by the object’s `availableAmount` field. */
  availableAmount?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `availableAmountValueUsd` field. */
  availableAmountValueUsd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `boostBalancesByPoolId` relation. */
  boostBalancesByPoolId?: InputMaybe<BoostPoolToManyBoostBalanceFilter>;
  /** Some related `boostBalancesByPoolId` exist. */
  boostBalancesByPoolIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `chain` field. */
  chain?: InputMaybe<ChainflipChainFilter>;
  /** Filter by the object’s `feeTierPips` field. */
  feeTierPips?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<BoostPoolFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<BoostPoolFilter>>;
  /** Filter by the object’s `unavailableAmount` field. */
  unavailableAmount?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `unavailableAmountValueUsd` field. */
  unavailableAmountValueUsd?: InputMaybe<BigFloatFilter>;
};

/** Grouping methods for `BoostPool` for usage during aggregation. */
export type BoostPoolGroupBy =
  | 'ASSET'
  | 'AVAILABLE_AMOUNT'
  | 'AVAILABLE_AMOUNT_VALUE_USD'
  | 'CHAIN'
  | 'FEE_TIER_PIPS'
  | 'UNAVAILABLE_AMOUNT'
  | 'UNAVAILABLE_AMOUNT_VALUE_USD';

export type BoostPoolHavingAverageInput = {
  availableAmount?: InputMaybe<HavingBigfloatFilter>;
  availableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
  feeTierPips?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingIntFilter>;
  unavailableAmount?: InputMaybe<HavingBigfloatFilter>;
  unavailableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type BoostPoolHavingDistinctCountInput = {
  availableAmount?: InputMaybe<HavingBigfloatFilter>;
  availableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
  feeTierPips?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingIntFilter>;
  unavailableAmount?: InputMaybe<HavingBigfloatFilter>;
  unavailableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
};

/** Conditions for `BoostPool` aggregates. */
export type BoostPoolHavingInput = {
  AND?: InputMaybe<Array<BoostPoolHavingInput>>;
  OR?: InputMaybe<Array<BoostPoolHavingInput>>;
  average?: InputMaybe<BoostPoolHavingAverageInput>;
  distinctCount?: InputMaybe<BoostPoolHavingDistinctCountInput>;
  max?: InputMaybe<BoostPoolHavingMaxInput>;
  min?: InputMaybe<BoostPoolHavingMinInput>;
  stddevPopulation?: InputMaybe<BoostPoolHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<BoostPoolHavingStddevSampleInput>;
  sum?: InputMaybe<BoostPoolHavingSumInput>;
  variancePopulation?: InputMaybe<BoostPoolHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<BoostPoolHavingVarianceSampleInput>;
};

export type BoostPoolHavingMaxInput = {
  availableAmount?: InputMaybe<HavingBigfloatFilter>;
  availableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
  feeTierPips?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingIntFilter>;
  unavailableAmount?: InputMaybe<HavingBigfloatFilter>;
  unavailableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type BoostPoolHavingMinInput = {
  availableAmount?: InputMaybe<HavingBigfloatFilter>;
  availableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
  feeTierPips?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingIntFilter>;
  unavailableAmount?: InputMaybe<HavingBigfloatFilter>;
  unavailableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type BoostPoolHavingStddevPopulationInput = {
  availableAmount?: InputMaybe<HavingBigfloatFilter>;
  availableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
  feeTierPips?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingIntFilter>;
  unavailableAmount?: InputMaybe<HavingBigfloatFilter>;
  unavailableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type BoostPoolHavingStddevSampleInput = {
  availableAmount?: InputMaybe<HavingBigfloatFilter>;
  availableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
  feeTierPips?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingIntFilter>;
  unavailableAmount?: InputMaybe<HavingBigfloatFilter>;
  unavailableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type BoostPoolHavingSumInput = {
  availableAmount?: InputMaybe<HavingBigfloatFilter>;
  availableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
  feeTierPips?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingIntFilter>;
  unavailableAmount?: InputMaybe<HavingBigfloatFilter>;
  unavailableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type BoostPoolHavingVariancePopulationInput = {
  availableAmount?: InputMaybe<HavingBigfloatFilter>;
  availableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
  feeTierPips?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingIntFilter>;
  unavailableAmount?: InputMaybe<HavingBigfloatFilter>;
  unavailableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type BoostPoolHavingVarianceSampleInput = {
  availableAmount?: InputMaybe<HavingBigfloatFilter>;
  availableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
  feeTierPips?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingIntFilter>;
  unavailableAmount?: InputMaybe<HavingBigfloatFilter>;
  unavailableAmountValueUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type BoostPoolMaxAggregates = {
  __typename?: 'BoostPoolMaxAggregates';
  /** Maximum of availableAmount across the matching connection */
  availableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of availableAmountValueUsd across the matching connection */
  availableAmountValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of feeTierPips across the matching connection */
  feeTierPips?: Maybe<Scalars['Int']['output']>;
  /** Maximum of id across the matching connection */
  id?: Maybe<Scalars['Int']['output']>;
  /** Maximum of unavailableAmount across the matching connection */
  unavailableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of unavailableAmountValueUsd across the matching connection */
  unavailableAmountValueUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type BoostPoolMinAggregates = {
  __typename?: 'BoostPoolMinAggregates';
  /** Minimum of availableAmount across the matching connection */
  availableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of availableAmountValueUsd across the matching connection */
  availableAmountValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of feeTierPips across the matching connection */
  feeTierPips?: Maybe<Scalars['Int']['output']>;
  /** Minimum of id across the matching connection */
  id?: Maybe<Scalars['Int']['output']>;
  /** Minimum of unavailableAmount across the matching connection */
  unavailableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of unavailableAmountValueUsd across the matching connection */
  unavailableAmountValueUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type BoostPoolStddevPopulationAggregates = {
  __typename?: 'BoostPoolStddevPopulationAggregates';
  /** Population standard deviation of availableAmount across the matching connection */
  availableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of availableAmountValueUsd across the matching connection */
  availableAmountValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of feeTierPips across the matching connection */
  feeTierPips?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of unavailableAmount across the matching connection */
  unavailableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of unavailableAmountValueUsd across the matching connection */
  unavailableAmountValueUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type BoostPoolStddevSampleAggregates = {
  __typename?: 'BoostPoolStddevSampleAggregates';
  /** Sample standard deviation of availableAmount across the matching connection */
  availableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of availableAmountValueUsd across the matching connection */
  availableAmountValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of feeTierPips across the matching connection */
  feeTierPips?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of unavailableAmount across the matching connection */
  unavailableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of unavailableAmountValueUsd across the matching connection */
  unavailableAmountValueUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type BoostPoolSumAggregates = {
  __typename?: 'BoostPoolSumAggregates';
  /** Sum of availableAmount across the matching connection */
  availableAmount: Scalars['BigFloat']['output'];
  /** Sum of availableAmountValueUsd across the matching connection */
  availableAmountValueUsd: Scalars['BigFloat']['output'];
  /** Sum of feeTierPips across the matching connection */
  feeTierPips: Scalars['BigInt']['output'];
  /** Sum of id across the matching connection */
  id: Scalars['BigInt']['output'];
  /** Sum of unavailableAmount across the matching connection */
  unavailableAmount: Scalars['BigFloat']['output'];
  /** Sum of unavailableAmountValueUsd across the matching connection */
  unavailableAmountValueUsd: Scalars['BigFloat']['output'];
};

/** A filter to be used against many `BoostBalance` object types. All fields are combined with a logical ‘and.’ */
export type BoostPoolToManyBoostBalanceFilter = {
  /** Aggregates across related `BoostBalance` match the filter criteria. */
  aggregates?: InputMaybe<BoostBalanceAggregatesFilter>;
  /** Every related `BoostBalance` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<BoostBalanceFilter>;
  /** No related `BoostBalance` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<BoostBalanceFilter>;
  /** Some related `BoostBalance` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<BoostBalanceFilter>;
};

export type BoostPoolVariancePopulationAggregates = {
  __typename?: 'BoostPoolVariancePopulationAggregates';
  /** Population variance of availableAmount across the matching connection */
  availableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of availableAmountValueUsd across the matching connection */
  availableAmountValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of feeTierPips across the matching connection */
  feeTierPips?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of unavailableAmount across the matching connection */
  unavailableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of unavailableAmountValueUsd across the matching connection */
  unavailableAmountValueUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type BoostPoolVarianceSampleAggregates = {
  __typename?: 'BoostPoolVarianceSampleAggregates';
  /** Sample variance of availableAmount across the matching connection */
  availableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of availableAmountValueUsd across the matching connection */
  availableAmountValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of feeTierPips across the matching connection */
  feeTierPips?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of unavailableAmount across the matching connection */
  unavailableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of unavailableAmountValueUsd across the matching connection */
  unavailableAmountValueUsd?: Maybe<Scalars['BigFloat']['output']>;
};

/** A connection to a list of `BoostPool` values. */
export type BoostPoolsConnection = {
  __typename?: 'BoostPoolsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BoostPoolAggregates>;
  /** A list of edges which contains the `BoostPool` and cursor to aid in pagination. */
  edges: Array<BoostPoolsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BoostPoolAggregates>>;
  /** A list of `BoostPool` objects. */
  nodes: Array<BoostPool>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `BoostPool` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `BoostPool` values. */
export type BoostPoolsConnectionGroupedAggregatesArgs = {
  groupBy: Array<BoostPoolGroupBy>;
  having?: InputMaybe<BoostPoolHavingInput>;
};

/** A `BoostPool` edge in the connection. */
export type BoostPoolsEdge = {
  __typename?: 'BoostPoolsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `BoostPool` at the end of the edge. */
  node: BoostPool;
};

/** Methods to use when ordering `BoostPool`. */
export type BoostPoolsOrderBy =
  | 'ASSET_ASC'
  | 'ASSET_DESC'
  | 'AVAILABLE_AMOUNT_ASC'
  | 'AVAILABLE_AMOUNT_DESC'
  | 'AVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'AVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_AVERAGE_AVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_AVERAGE_AVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_AVERAGE_AVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_AVERAGE_AVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_AVERAGE_LP_ID_SS58_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_AVERAGE_LP_ID_SS58_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_AVERAGE_POOL_ID_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_AVERAGE_POOL_ID_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_AVERAGE_POOL_SHARE_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_AVERAGE_POOL_SHARE_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_AVERAGE_UNAVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_AVERAGE_UNAVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_AVERAGE_UNAVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_AVERAGE_UNAVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_COUNT_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_COUNT_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_DISTINCT_COUNT_AVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_DISTINCT_COUNT_AVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_DISTINCT_COUNT_AVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_DISTINCT_COUNT_AVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_DISTINCT_COUNT_LP_ID_SS58_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_DISTINCT_COUNT_LP_ID_SS58_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_DISTINCT_COUNT_POOL_ID_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_DISTINCT_COUNT_POOL_ID_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_DISTINCT_COUNT_POOL_SHARE_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_DISTINCT_COUNT_POOL_SHARE_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_DISTINCT_COUNT_UNAVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_DISTINCT_COUNT_UNAVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_DISTINCT_COUNT_UNAVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_DISTINCT_COUNT_UNAVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_MAX_AVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_MAX_AVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_MAX_AVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_MAX_AVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_MAX_LP_ID_SS58_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_MAX_LP_ID_SS58_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_MAX_POOL_ID_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_MAX_POOL_ID_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_MAX_POOL_SHARE_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_MAX_POOL_SHARE_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_MAX_UNAVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_MAX_UNAVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_MAX_UNAVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_MAX_UNAVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_MIN_AVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_MIN_AVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_MIN_AVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_MIN_AVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_MIN_LP_ID_SS58_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_MIN_LP_ID_SS58_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_MIN_POOL_ID_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_MIN_POOL_ID_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_MIN_POOL_SHARE_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_MIN_POOL_SHARE_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_MIN_UNAVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_MIN_UNAVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_MIN_UNAVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_MIN_UNAVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_STDDEV_POPULATION_AVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_STDDEV_POPULATION_AVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_STDDEV_POPULATION_AVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_STDDEV_POPULATION_AVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_STDDEV_POPULATION_LP_ID_SS58_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_STDDEV_POPULATION_LP_ID_SS58_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_STDDEV_POPULATION_POOL_ID_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_STDDEV_POPULATION_POOL_ID_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_STDDEV_POPULATION_POOL_SHARE_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_STDDEV_POPULATION_POOL_SHARE_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_STDDEV_POPULATION_UNAVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_STDDEV_POPULATION_UNAVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_STDDEV_POPULATION_UNAVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_STDDEV_POPULATION_UNAVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_STDDEV_SAMPLE_AVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_STDDEV_SAMPLE_AVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_STDDEV_SAMPLE_AVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_STDDEV_SAMPLE_AVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_STDDEV_SAMPLE_LP_ID_SS58_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_STDDEV_SAMPLE_LP_ID_SS58_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_STDDEV_SAMPLE_POOL_ID_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_STDDEV_SAMPLE_POOL_ID_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_STDDEV_SAMPLE_POOL_SHARE_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_STDDEV_SAMPLE_POOL_SHARE_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_STDDEV_SAMPLE_UNAVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_STDDEV_SAMPLE_UNAVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_STDDEV_SAMPLE_UNAVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_STDDEV_SAMPLE_UNAVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_SUM_AVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_SUM_AVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_SUM_AVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_SUM_AVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_SUM_LP_ID_SS58_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_SUM_LP_ID_SS58_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_SUM_POOL_ID_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_SUM_POOL_ID_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_SUM_POOL_SHARE_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_SUM_POOL_SHARE_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_SUM_UNAVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_SUM_UNAVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_SUM_UNAVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_SUM_UNAVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_VARIANCE_POPULATION_AVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_VARIANCE_POPULATION_AVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_VARIANCE_POPULATION_AVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_VARIANCE_POPULATION_AVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_VARIANCE_POPULATION_LP_ID_SS58_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_VARIANCE_POPULATION_LP_ID_SS58_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_VARIANCE_POPULATION_POOL_ID_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_VARIANCE_POPULATION_POOL_ID_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_VARIANCE_POPULATION_POOL_SHARE_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_VARIANCE_POPULATION_POOL_SHARE_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_VARIANCE_POPULATION_UNAVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_VARIANCE_POPULATION_UNAVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_VARIANCE_POPULATION_UNAVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_VARIANCE_POPULATION_UNAVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_VARIANCE_SAMPLE_AVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_VARIANCE_SAMPLE_AVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_VARIANCE_SAMPLE_AVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_VARIANCE_SAMPLE_AVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_VARIANCE_SAMPLE_LP_ID_SS58_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_VARIANCE_SAMPLE_LP_ID_SS58_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_VARIANCE_SAMPLE_POOL_ID_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_VARIANCE_SAMPLE_POOL_ID_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_VARIANCE_SAMPLE_POOL_SHARE_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_VARIANCE_SAMPLE_POOL_SHARE_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_VARIANCE_SAMPLE_UNAVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_VARIANCE_SAMPLE_UNAVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_POOL_ID_VARIANCE_SAMPLE_UNAVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_POOL_ID_VARIANCE_SAMPLE_UNAVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'CHAIN_ASC'
  | 'CHAIN_DESC'
  | 'FEE_TIER_PIPS_ASC'
  | 'FEE_TIER_PIPS_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'UNAVAILABLE_AMOUNT_ASC'
  | 'UNAVAILABLE_AMOUNT_DESC'
  | 'UNAVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'UNAVAILABLE_AMOUNT_VALUE_USD_DESC';

export type BoostSafeMode = Node & {
  __typename?: 'BoostSafeMode';
  addBoostFundsEnabled: Scalars['Boolean']['output'];
  boostDepositsEnabled: Scalars['Boolean']['output'];
  chain: ChainflipChain;
  depositsEnabled: Scalars['Boolean']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  stopBoostingEnabled: Scalars['Boolean']['output'];
};

export type BoostSafeModeAggregates = {
  __typename?: 'BoostSafeModeAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<BoostSafeModeAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<BoostSafeModeDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<BoostSafeModeMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<BoostSafeModeMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<BoostSafeModeStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<BoostSafeModeStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<BoostSafeModeSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<BoostSafeModeVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<BoostSafeModeVarianceSampleAggregates>;
};

export type BoostSafeModeAverageAggregates = {
  __typename?: 'BoostSafeModeAverageAggregates';
  /** Mean average of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `BoostSafeMode` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type BoostSafeModeCondition = {
  /** Checks for equality with the object’s `addBoostFundsEnabled` field. */
  addBoostFundsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `boostDepositsEnabled` field. */
  boostDepositsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `chain` field. */
  chain?: InputMaybe<ChainflipChain>;
  /** Checks for equality with the object’s `depositsEnabled` field. */
  depositsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `stopBoostingEnabled` field. */
  stopBoostingEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

export type BoostSafeModeDistinctCountAggregates = {
  __typename?: 'BoostSafeModeDistinctCountAggregates';
  /** Distinct count of addBoostFundsEnabled across the matching connection */
  addBoostFundsEnabled?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of boostDepositsEnabled across the matching connection */
  boostDepositsEnabled?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of chain across the matching connection */
  chain?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of depositsEnabled across the matching connection */
  depositsEnabled?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of id across the matching connection */
  id?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of stopBoostingEnabled across the matching connection */
  stopBoostingEnabled?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `BoostSafeMode` object types. All fields are combined with a logical ‘and.’ */
export type BoostSafeModeFilter = {
  /** Filter by the object’s `addBoostFundsEnabled` field. */
  addBoostFundsEnabled?: InputMaybe<BooleanFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<BoostSafeModeFilter>>;
  /** Filter by the object’s `boostDepositsEnabled` field. */
  boostDepositsEnabled?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `chain` field. */
  chain?: InputMaybe<ChainflipChainFilter>;
  /** Filter by the object’s `depositsEnabled` field. */
  depositsEnabled?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<BoostSafeModeFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<BoostSafeModeFilter>>;
  /** Filter by the object’s `stopBoostingEnabled` field. */
  stopBoostingEnabled?: InputMaybe<BooleanFilter>;
};

/** Grouping methods for `BoostSafeMode` for usage during aggregation. */
export type BoostSafeModeGroupBy =
  | 'ADD_BOOST_FUNDS_ENABLED'
  | 'BOOST_DEPOSITS_ENABLED'
  | 'DEPOSITS_ENABLED'
  | 'STOP_BOOSTING_ENABLED';

export type BoostSafeModeHavingAverageInput = {
  id?: InputMaybe<HavingIntFilter>;
};

export type BoostSafeModeHavingDistinctCountInput = {
  id?: InputMaybe<HavingIntFilter>;
};

/** Conditions for `BoostSafeMode` aggregates. */
export type BoostSafeModeHavingInput = {
  AND?: InputMaybe<Array<BoostSafeModeHavingInput>>;
  OR?: InputMaybe<Array<BoostSafeModeHavingInput>>;
  average?: InputMaybe<BoostSafeModeHavingAverageInput>;
  distinctCount?: InputMaybe<BoostSafeModeHavingDistinctCountInput>;
  max?: InputMaybe<BoostSafeModeHavingMaxInput>;
  min?: InputMaybe<BoostSafeModeHavingMinInput>;
  stddevPopulation?: InputMaybe<BoostSafeModeHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<BoostSafeModeHavingStddevSampleInput>;
  sum?: InputMaybe<BoostSafeModeHavingSumInput>;
  variancePopulation?: InputMaybe<BoostSafeModeHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<BoostSafeModeHavingVarianceSampleInput>;
};

export type BoostSafeModeHavingMaxInput = {
  id?: InputMaybe<HavingIntFilter>;
};

export type BoostSafeModeHavingMinInput = {
  id?: InputMaybe<HavingIntFilter>;
};

export type BoostSafeModeHavingStddevPopulationInput = {
  id?: InputMaybe<HavingIntFilter>;
};

export type BoostSafeModeHavingStddevSampleInput = {
  id?: InputMaybe<HavingIntFilter>;
};

export type BoostSafeModeHavingSumInput = {
  id?: InputMaybe<HavingIntFilter>;
};

export type BoostSafeModeHavingVariancePopulationInput = {
  id?: InputMaybe<HavingIntFilter>;
};

export type BoostSafeModeHavingVarianceSampleInput = {
  id?: InputMaybe<HavingIntFilter>;
};

export type BoostSafeModeMaxAggregates = {
  __typename?: 'BoostSafeModeMaxAggregates';
  /** Maximum of id across the matching connection */
  id?: Maybe<Scalars['Int']['output']>;
};

export type BoostSafeModeMinAggregates = {
  __typename?: 'BoostSafeModeMinAggregates';
  /** Minimum of id across the matching connection */
  id?: Maybe<Scalars['Int']['output']>;
};

export type BoostSafeModeStddevPopulationAggregates = {
  __typename?: 'BoostSafeModeStddevPopulationAggregates';
  /** Population standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
};

export type BoostSafeModeStddevSampleAggregates = {
  __typename?: 'BoostSafeModeStddevSampleAggregates';
  /** Sample standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
};

export type BoostSafeModeSumAggregates = {
  __typename?: 'BoostSafeModeSumAggregates';
  /** Sum of id across the matching connection */
  id: Scalars['BigInt']['output'];
};

export type BoostSafeModeVariancePopulationAggregates = {
  __typename?: 'BoostSafeModeVariancePopulationAggregates';
  /** Population variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
};

export type BoostSafeModeVarianceSampleAggregates = {
  __typename?: 'BoostSafeModeVarianceSampleAggregates';
  /** Sample variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
};

/** A connection to a list of `BoostSafeMode` values. */
export type BoostSafeModesConnection = {
  __typename?: 'BoostSafeModesConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BoostSafeModeAggregates>;
  /** A list of edges which contains the `BoostSafeMode` and cursor to aid in pagination. */
  edges: Array<BoostSafeModesEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BoostSafeModeAggregates>>;
  /** A list of `BoostSafeMode` objects. */
  nodes: Array<BoostSafeMode>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `BoostSafeMode` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `BoostSafeMode` values. */
export type BoostSafeModesConnectionGroupedAggregatesArgs = {
  groupBy: Array<BoostSafeModeGroupBy>;
  having?: InputMaybe<BoostSafeModeHavingInput>;
};

/** A `BoostSafeMode` edge in the connection. */
export type BoostSafeModesEdge = {
  __typename?: 'BoostSafeModesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `BoostSafeMode` at the end of the edge. */
  node: BoostSafeMode;
};

/** Methods to use when ordering `BoostSafeMode`. */
export type BoostSafeModesOrderBy =
  | 'ADD_BOOST_FUNDS_ENABLED_ASC'
  | 'ADD_BOOST_FUNDS_ENABLED_DESC'
  | 'BOOST_DEPOSITS_ENABLED_ASC'
  | 'BOOST_DEPOSITS_ENABLED_DESC'
  | 'CHAIN_ASC'
  | 'CHAIN_DESC'
  | 'DEPOSITS_ENABLED_ASC'
  | 'DEPOSITS_ENABLED_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'STOP_BOOSTING_ENABLED_ASC'
  | 'STOP_BOOSTING_ENABLED_DESC';

export type BrokerAccount = Node & {
  __typename?: 'BrokerAccount';
  /** Reads a single `Account` that is related to this `BrokerAccount`. */
  accountByIdSs58: Account;
  alias?: Maybe<Scalars['String']['output']>;
  bondedFlipBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Reads a single `BrokerAccount` that is related to this `BrokerAccount`. */
  brokerAccountByDelegateBrokerId?: Maybe<BrokerAccount>;
  /** Reads and enables pagination through a set of `BrokerAccount`. */
  brokerAccountsByDelegateBrokerId: BrokerAccountsConnection;
  brokerVaultDepositAddress?: Maybe<Scalars['String']['output']>;
  delegateBrokerId?: Maybe<Scalars['String']['output']>;
  earnedFeesUsdc: Scalars['BigFloat']['output'];
  flipBalance: Scalars['BigFloat']['output'];
  idSs58: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  registrationId?: Maybe<Scalars['Int']['output']>;
  withdrawalAddress?: Maybe<Scalars['String']['output']>;
};


export type BrokerAccountBrokerAccountsByDelegateBrokerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<BrokerAccountCondition>;
  filter?: InputMaybe<BrokerAccountFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BrokerAccountsOrderBy>>;
};

export type BrokerAccountAggregates = {
  __typename?: 'BrokerAccountAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<BrokerAccountAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<BrokerAccountDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<BrokerAccountMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<BrokerAccountMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<BrokerAccountStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<BrokerAccountStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<BrokerAccountSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<BrokerAccountVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<BrokerAccountVarianceSampleAggregates>;
};

/** A filter to be used against aggregates of `BrokerAccount` object types. */
export type BrokerAccountAggregatesFilter = {
  /** Mean average aggregate over matching `BrokerAccount` objects. */
  average?: InputMaybe<BrokerAccountAverageAggregateFilter>;
  /** Distinct count aggregate over matching `BrokerAccount` objects. */
  distinctCount?: InputMaybe<BrokerAccountDistinctCountAggregateFilter>;
  /** A filter that must pass for the relevant `BrokerAccount` object to be included within the aggregate. */
  filter?: InputMaybe<BrokerAccountFilter>;
  /** Maximum aggregate over matching `BrokerAccount` objects. */
  max?: InputMaybe<BrokerAccountMaxAggregateFilter>;
  /** Minimum aggregate over matching `BrokerAccount` objects. */
  min?: InputMaybe<BrokerAccountMinAggregateFilter>;
  /** Population standard deviation aggregate over matching `BrokerAccount` objects. */
  stddevPopulation?: InputMaybe<BrokerAccountStddevPopulationAggregateFilter>;
  /** Sample standard deviation aggregate over matching `BrokerAccount` objects. */
  stddevSample?: InputMaybe<BrokerAccountStddevSampleAggregateFilter>;
  /** Sum aggregate over matching `BrokerAccount` objects. */
  sum?: InputMaybe<BrokerAccountSumAggregateFilter>;
  /** Population variance aggregate over matching `BrokerAccount` objects. */
  variancePopulation?: InputMaybe<BrokerAccountVariancePopulationAggregateFilter>;
  /** Sample variance aggregate over matching `BrokerAccount` objects. */
  varianceSample?: InputMaybe<BrokerAccountVarianceSampleAggregateFilter>;
};

export type BrokerAccountAverageAggregateFilter = {
  bondedFlipBalance?: InputMaybe<BigFloatFilter>;
  earnedFeesUsdc?: InputMaybe<BigFloatFilter>;
  flipBalance?: InputMaybe<BigFloatFilter>;
  registrationId?: InputMaybe<BigFloatFilter>;
};

export type BrokerAccountAverageAggregates = {
  __typename?: 'BrokerAccountAverageAggregates';
  /** Mean average of bondedFlipBalance across the matching connection */
  bondedFlipBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of earnedFeesUsdc across the matching connection */
  earnedFeesUsdc?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of flipBalance across the matching connection */
  flipBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of registrationId across the matching connection */
  registrationId?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `BrokerAccount` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type BrokerAccountCondition = {
  /** Checks for equality with the object’s `alias` field. */
  alias?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `bondedFlipBalance` field. */
  bondedFlipBalance?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `brokerVaultDepositAddress` field. */
  brokerVaultDepositAddress?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `delegateBrokerId` field. */
  delegateBrokerId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `earnedFeesUsdc` field. */
  earnedFeesUsdc?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `flipBalance` field. */
  flipBalance?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `idSs58` field. */
  idSs58?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `registrationId` field. */
  registrationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `withdrawalAddress` field. */
  withdrawalAddress?: InputMaybe<Scalars['String']['input']>;
};

export type BrokerAccountDistinctCountAggregateFilter = {
  alias?: InputMaybe<BigIntFilter>;
  bondedFlipBalance?: InputMaybe<BigIntFilter>;
  brokerVaultDepositAddress?: InputMaybe<BigIntFilter>;
  delegateBrokerId?: InputMaybe<BigIntFilter>;
  earnedFeesUsdc?: InputMaybe<BigIntFilter>;
  flipBalance?: InputMaybe<BigIntFilter>;
  idSs58?: InputMaybe<BigIntFilter>;
  registrationId?: InputMaybe<BigIntFilter>;
  withdrawalAddress?: InputMaybe<BigIntFilter>;
};

export type BrokerAccountDistinctCountAggregates = {
  __typename?: 'BrokerAccountDistinctCountAggregates';
  /** Distinct count of alias across the matching connection */
  alias?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of bondedFlipBalance across the matching connection */
  bondedFlipBalance?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of brokerVaultDepositAddress across the matching connection */
  brokerVaultDepositAddress?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of delegateBrokerId across the matching connection */
  delegateBrokerId?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of earnedFeesUsdc across the matching connection */
  earnedFeesUsdc?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of flipBalance across the matching connection */
  flipBalance?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of idSs58 across the matching connection */
  idSs58?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of registrationId across the matching connection */
  registrationId?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of withdrawalAddress across the matching connection */
  withdrawalAddress?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `BrokerAccount` object types. All fields are combined with a logical ‘and.’ */
export type BrokerAccountFilter = {
  /** Filter by the object’s `accountByIdSs58` relation. */
  accountByIdSs58?: InputMaybe<AccountFilter>;
  /** Filter by the object’s `alias` field. */
  alias?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<BrokerAccountFilter>>;
  /** Filter by the object’s `bondedFlipBalance` field. */
  bondedFlipBalance?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `brokerAccountByDelegateBrokerId` relation. */
  brokerAccountByDelegateBrokerId?: InputMaybe<BrokerAccountFilter>;
  /** A related `brokerAccountByDelegateBrokerId` exists. */
  brokerAccountByDelegateBrokerIdExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `brokerAccountsByDelegateBrokerId` relation. */
  brokerAccountsByDelegateBrokerId?: InputMaybe<BrokerAccountToManyBrokerAccountFilter>;
  /** Some related `brokerAccountsByDelegateBrokerId` exist. */
  brokerAccountsByDelegateBrokerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `brokerVaultDepositAddress` field. */
  brokerVaultDepositAddress?: InputMaybe<StringFilter>;
  /** Filter by the object’s `delegateBrokerId` field. */
  delegateBrokerId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `earnedFeesUsdc` field. */
  earnedFeesUsdc?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `flipBalance` field. */
  flipBalance?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `idSs58` field. */
  idSs58?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<BrokerAccountFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<BrokerAccountFilter>>;
  /** Filter by the object’s `registrationId` field. */
  registrationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `withdrawalAddress` field. */
  withdrawalAddress?: InputMaybe<StringFilter>;
};

/** Grouping methods for `BrokerAccount` for usage during aggregation. */
export type BrokerAccountGroupBy =
  | 'ALIAS'
  | 'BONDED_FLIP_BALANCE'
  | 'BROKER_VAULT_DEPOSIT_ADDRESS'
  | 'DELEGATE_BROKER_ID'
  | 'EARNED_FEES_USDC'
  | 'FLIP_BALANCE'
  | 'REGISTRATION_ID'
  | 'WITHDRAWAL_ADDRESS';

export type BrokerAccountHavingAverageInput = {
  bondedFlipBalance?: InputMaybe<HavingBigfloatFilter>;
  earnedFeesUsdc?: InputMaybe<HavingBigfloatFilter>;
  flipBalance?: InputMaybe<HavingBigfloatFilter>;
  registrationId?: InputMaybe<HavingIntFilter>;
};

export type BrokerAccountHavingDistinctCountInput = {
  bondedFlipBalance?: InputMaybe<HavingBigfloatFilter>;
  earnedFeesUsdc?: InputMaybe<HavingBigfloatFilter>;
  flipBalance?: InputMaybe<HavingBigfloatFilter>;
  registrationId?: InputMaybe<HavingIntFilter>;
};

/** Conditions for `BrokerAccount` aggregates. */
export type BrokerAccountHavingInput = {
  AND?: InputMaybe<Array<BrokerAccountHavingInput>>;
  OR?: InputMaybe<Array<BrokerAccountHavingInput>>;
  average?: InputMaybe<BrokerAccountHavingAverageInput>;
  distinctCount?: InputMaybe<BrokerAccountHavingDistinctCountInput>;
  max?: InputMaybe<BrokerAccountHavingMaxInput>;
  min?: InputMaybe<BrokerAccountHavingMinInput>;
  stddevPopulation?: InputMaybe<BrokerAccountHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<BrokerAccountHavingStddevSampleInput>;
  sum?: InputMaybe<BrokerAccountHavingSumInput>;
  variancePopulation?: InputMaybe<BrokerAccountHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<BrokerAccountHavingVarianceSampleInput>;
};

export type BrokerAccountHavingMaxInput = {
  bondedFlipBalance?: InputMaybe<HavingBigfloatFilter>;
  earnedFeesUsdc?: InputMaybe<HavingBigfloatFilter>;
  flipBalance?: InputMaybe<HavingBigfloatFilter>;
  registrationId?: InputMaybe<HavingIntFilter>;
};

export type BrokerAccountHavingMinInput = {
  bondedFlipBalance?: InputMaybe<HavingBigfloatFilter>;
  earnedFeesUsdc?: InputMaybe<HavingBigfloatFilter>;
  flipBalance?: InputMaybe<HavingBigfloatFilter>;
  registrationId?: InputMaybe<HavingIntFilter>;
};

export type BrokerAccountHavingStddevPopulationInput = {
  bondedFlipBalance?: InputMaybe<HavingBigfloatFilter>;
  earnedFeesUsdc?: InputMaybe<HavingBigfloatFilter>;
  flipBalance?: InputMaybe<HavingBigfloatFilter>;
  registrationId?: InputMaybe<HavingIntFilter>;
};

export type BrokerAccountHavingStddevSampleInput = {
  bondedFlipBalance?: InputMaybe<HavingBigfloatFilter>;
  earnedFeesUsdc?: InputMaybe<HavingBigfloatFilter>;
  flipBalance?: InputMaybe<HavingBigfloatFilter>;
  registrationId?: InputMaybe<HavingIntFilter>;
};

export type BrokerAccountHavingSumInput = {
  bondedFlipBalance?: InputMaybe<HavingBigfloatFilter>;
  earnedFeesUsdc?: InputMaybe<HavingBigfloatFilter>;
  flipBalance?: InputMaybe<HavingBigfloatFilter>;
  registrationId?: InputMaybe<HavingIntFilter>;
};

export type BrokerAccountHavingVariancePopulationInput = {
  bondedFlipBalance?: InputMaybe<HavingBigfloatFilter>;
  earnedFeesUsdc?: InputMaybe<HavingBigfloatFilter>;
  flipBalance?: InputMaybe<HavingBigfloatFilter>;
  registrationId?: InputMaybe<HavingIntFilter>;
};

export type BrokerAccountHavingVarianceSampleInput = {
  bondedFlipBalance?: InputMaybe<HavingBigfloatFilter>;
  earnedFeesUsdc?: InputMaybe<HavingBigfloatFilter>;
  flipBalance?: InputMaybe<HavingBigfloatFilter>;
  registrationId?: InputMaybe<HavingIntFilter>;
};

export type BrokerAccountMaxAggregateFilter = {
  bondedFlipBalance?: InputMaybe<BigFloatFilter>;
  earnedFeesUsdc?: InputMaybe<BigFloatFilter>;
  flipBalance?: InputMaybe<BigFloatFilter>;
  registrationId?: InputMaybe<IntFilter>;
};

export type BrokerAccountMaxAggregates = {
  __typename?: 'BrokerAccountMaxAggregates';
  /** Maximum of bondedFlipBalance across the matching connection */
  bondedFlipBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of earnedFeesUsdc across the matching connection */
  earnedFeesUsdc?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of flipBalance across the matching connection */
  flipBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of registrationId across the matching connection */
  registrationId?: Maybe<Scalars['Int']['output']>;
};

export type BrokerAccountMinAggregateFilter = {
  bondedFlipBalance?: InputMaybe<BigFloatFilter>;
  earnedFeesUsdc?: InputMaybe<BigFloatFilter>;
  flipBalance?: InputMaybe<BigFloatFilter>;
  registrationId?: InputMaybe<IntFilter>;
};

export type BrokerAccountMinAggregates = {
  __typename?: 'BrokerAccountMinAggregates';
  /** Minimum of bondedFlipBalance across the matching connection */
  bondedFlipBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of earnedFeesUsdc across the matching connection */
  earnedFeesUsdc?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of flipBalance across the matching connection */
  flipBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of registrationId across the matching connection */
  registrationId?: Maybe<Scalars['Int']['output']>;
};

export type BrokerAccountStddevPopulationAggregateFilter = {
  bondedFlipBalance?: InputMaybe<BigFloatFilter>;
  earnedFeesUsdc?: InputMaybe<BigFloatFilter>;
  flipBalance?: InputMaybe<BigFloatFilter>;
  registrationId?: InputMaybe<BigFloatFilter>;
};

export type BrokerAccountStddevPopulationAggregates = {
  __typename?: 'BrokerAccountStddevPopulationAggregates';
  /** Population standard deviation of bondedFlipBalance across the matching connection */
  bondedFlipBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of earnedFeesUsdc across the matching connection */
  earnedFeesUsdc?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of flipBalance across the matching connection */
  flipBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of registrationId across the matching connection */
  registrationId?: Maybe<Scalars['BigFloat']['output']>;
};

export type BrokerAccountStddevSampleAggregateFilter = {
  bondedFlipBalance?: InputMaybe<BigFloatFilter>;
  earnedFeesUsdc?: InputMaybe<BigFloatFilter>;
  flipBalance?: InputMaybe<BigFloatFilter>;
  registrationId?: InputMaybe<BigFloatFilter>;
};

export type BrokerAccountStddevSampleAggregates = {
  __typename?: 'BrokerAccountStddevSampleAggregates';
  /** Sample standard deviation of bondedFlipBalance across the matching connection */
  bondedFlipBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of earnedFeesUsdc across the matching connection */
  earnedFeesUsdc?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of flipBalance across the matching connection */
  flipBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of registrationId across the matching connection */
  registrationId?: Maybe<Scalars['BigFloat']['output']>;
};

export type BrokerAccountSumAggregateFilter = {
  bondedFlipBalance?: InputMaybe<BigFloatFilter>;
  earnedFeesUsdc?: InputMaybe<BigFloatFilter>;
  flipBalance?: InputMaybe<BigFloatFilter>;
  registrationId?: InputMaybe<BigIntFilter>;
};

export type BrokerAccountSumAggregates = {
  __typename?: 'BrokerAccountSumAggregates';
  /** Sum of bondedFlipBalance across the matching connection */
  bondedFlipBalance: Scalars['BigFloat']['output'];
  /** Sum of earnedFeesUsdc across the matching connection */
  earnedFeesUsdc: Scalars['BigFloat']['output'];
  /** Sum of flipBalance across the matching connection */
  flipBalance: Scalars['BigFloat']['output'];
  /** Sum of registrationId across the matching connection */
  registrationId: Scalars['BigInt']['output'];
};

/** A filter to be used against many `BrokerAccount` object types. All fields are combined with a logical ‘and.’ */
export type BrokerAccountToManyBrokerAccountFilter = {
  /** Aggregates across related `BrokerAccount` match the filter criteria. */
  aggregates?: InputMaybe<BrokerAccountAggregatesFilter>;
  /** Every related `BrokerAccount` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<BrokerAccountFilter>;
  /** No related `BrokerAccount` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<BrokerAccountFilter>;
  /** Some related `BrokerAccount` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<BrokerAccountFilter>;
};

export type BrokerAccountVariancePopulationAggregateFilter = {
  bondedFlipBalance?: InputMaybe<BigFloatFilter>;
  earnedFeesUsdc?: InputMaybe<BigFloatFilter>;
  flipBalance?: InputMaybe<BigFloatFilter>;
  registrationId?: InputMaybe<BigFloatFilter>;
};

export type BrokerAccountVariancePopulationAggregates = {
  __typename?: 'BrokerAccountVariancePopulationAggregates';
  /** Population variance of bondedFlipBalance across the matching connection */
  bondedFlipBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of earnedFeesUsdc across the matching connection */
  earnedFeesUsdc?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of flipBalance across the matching connection */
  flipBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of registrationId across the matching connection */
  registrationId?: Maybe<Scalars['BigFloat']['output']>;
};

export type BrokerAccountVarianceSampleAggregateFilter = {
  bondedFlipBalance?: InputMaybe<BigFloatFilter>;
  earnedFeesUsdc?: InputMaybe<BigFloatFilter>;
  flipBalance?: InputMaybe<BigFloatFilter>;
  registrationId?: InputMaybe<BigFloatFilter>;
};

export type BrokerAccountVarianceSampleAggregates = {
  __typename?: 'BrokerAccountVarianceSampleAggregates';
  /** Sample variance of bondedFlipBalance across the matching connection */
  bondedFlipBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of earnedFeesUsdc across the matching connection */
  earnedFeesUsdc?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of flipBalance across the matching connection */
  flipBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of registrationId across the matching connection */
  registrationId?: Maybe<Scalars['BigFloat']['output']>;
};

/** A connection to a list of `BrokerAccount` values. */
export type BrokerAccountsConnection = {
  __typename?: 'BrokerAccountsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<BrokerAccountAggregates>;
  /** A list of edges which contains the `BrokerAccount` and cursor to aid in pagination. */
  edges: Array<BrokerAccountsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<BrokerAccountAggregates>>;
  /** A list of `BrokerAccount` objects. */
  nodes: Array<BrokerAccount>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `BrokerAccount` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `BrokerAccount` values. */
export type BrokerAccountsConnectionGroupedAggregatesArgs = {
  groupBy: Array<BrokerAccountGroupBy>;
  having?: InputMaybe<BrokerAccountHavingInput>;
};

/** A `BrokerAccount` edge in the connection. */
export type BrokerAccountsEdge = {
  __typename?: 'BrokerAccountsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `BrokerAccount` at the end of the edge. */
  node: BrokerAccount;
};

/** Methods to use when ordering `BrokerAccount`. */
export type BrokerAccountsOrderBy =
  | 'ALIAS_ASC'
  | 'ALIAS_DESC'
  | 'BONDED_FLIP_BALANCE_ASC'
  | 'BONDED_FLIP_BALANCE_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_AVERAGE_ALIAS_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_AVERAGE_ALIAS_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_AVERAGE_BONDED_FLIP_BALANCE_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_AVERAGE_BONDED_FLIP_BALANCE_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_AVERAGE_BROKER_VAULT_DEPOSIT_ADDRESS_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_AVERAGE_BROKER_VAULT_DEPOSIT_ADDRESS_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_AVERAGE_DELEGATE_BROKER_ID_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_AVERAGE_DELEGATE_BROKER_ID_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_AVERAGE_EARNED_FEES_USDC_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_AVERAGE_EARNED_FEES_USDC_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_AVERAGE_FLIP_BALANCE_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_AVERAGE_FLIP_BALANCE_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_AVERAGE_ID_SS58_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_AVERAGE_ID_SS58_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_AVERAGE_REGISTRATION_ID_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_AVERAGE_REGISTRATION_ID_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_AVERAGE_WITHDRAWAL_ADDRESS_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_AVERAGE_WITHDRAWAL_ADDRESS_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_COUNT_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_COUNT_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_DISTINCT_COUNT_ALIAS_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_DISTINCT_COUNT_ALIAS_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_DISTINCT_COUNT_BONDED_FLIP_BALANCE_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_DISTINCT_COUNT_BONDED_FLIP_BALANCE_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_DISTINCT_COUNT_BROKER_VAULT_DEPOSIT_ADDRESS_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_DISTINCT_COUNT_BROKER_VAULT_DEPOSIT_ADDRESS_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_DISTINCT_COUNT_DELEGATE_BROKER_ID_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_DISTINCT_COUNT_DELEGATE_BROKER_ID_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_DISTINCT_COUNT_EARNED_FEES_USDC_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_DISTINCT_COUNT_EARNED_FEES_USDC_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_DISTINCT_COUNT_FLIP_BALANCE_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_DISTINCT_COUNT_FLIP_BALANCE_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_DISTINCT_COUNT_ID_SS58_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_DISTINCT_COUNT_ID_SS58_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_DISTINCT_COUNT_REGISTRATION_ID_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_DISTINCT_COUNT_REGISTRATION_ID_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_DISTINCT_COUNT_WITHDRAWAL_ADDRESS_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_DISTINCT_COUNT_WITHDRAWAL_ADDRESS_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MAX_ALIAS_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MAX_ALIAS_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MAX_BONDED_FLIP_BALANCE_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MAX_BONDED_FLIP_BALANCE_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MAX_BROKER_VAULT_DEPOSIT_ADDRESS_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MAX_BROKER_VAULT_DEPOSIT_ADDRESS_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MAX_DELEGATE_BROKER_ID_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MAX_DELEGATE_BROKER_ID_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MAX_EARNED_FEES_USDC_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MAX_EARNED_FEES_USDC_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MAX_FLIP_BALANCE_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MAX_FLIP_BALANCE_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MAX_ID_SS58_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MAX_ID_SS58_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MAX_REGISTRATION_ID_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MAX_REGISTRATION_ID_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MAX_WITHDRAWAL_ADDRESS_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MAX_WITHDRAWAL_ADDRESS_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MIN_ALIAS_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MIN_ALIAS_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MIN_BONDED_FLIP_BALANCE_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MIN_BONDED_FLIP_BALANCE_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MIN_BROKER_VAULT_DEPOSIT_ADDRESS_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MIN_BROKER_VAULT_DEPOSIT_ADDRESS_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MIN_DELEGATE_BROKER_ID_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MIN_DELEGATE_BROKER_ID_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MIN_EARNED_FEES_USDC_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MIN_EARNED_FEES_USDC_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MIN_FLIP_BALANCE_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MIN_FLIP_BALANCE_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MIN_ID_SS58_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MIN_ID_SS58_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MIN_REGISTRATION_ID_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MIN_REGISTRATION_ID_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MIN_WITHDRAWAL_ADDRESS_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_MIN_WITHDRAWAL_ADDRESS_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_POPULATION_ALIAS_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_POPULATION_ALIAS_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_POPULATION_BONDED_FLIP_BALANCE_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_POPULATION_BONDED_FLIP_BALANCE_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_POPULATION_BROKER_VAULT_DEPOSIT_ADDRESS_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_POPULATION_BROKER_VAULT_DEPOSIT_ADDRESS_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_POPULATION_DELEGATE_BROKER_ID_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_POPULATION_DELEGATE_BROKER_ID_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_POPULATION_EARNED_FEES_USDC_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_POPULATION_EARNED_FEES_USDC_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_POPULATION_FLIP_BALANCE_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_POPULATION_FLIP_BALANCE_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_POPULATION_ID_SS58_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_POPULATION_ID_SS58_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_POPULATION_REGISTRATION_ID_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_POPULATION_REGISTRATION_ID_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_POPULATION_WITHDRAWAL_ADDRESS_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_POPULATION_WITHDRAWAL_ADDRESS_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_SAMPLE_ALIAS_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_SAMPLE_ALIAS_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_SAMPLE_BONDED_FLIP_BALANCE_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_SAMPLE_BONDED_FLIP_BALANCE_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_SAMPLE_BROKER_VAULT_DEPOSIT_ADDRESS_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_SAMPLE_BROKER_VAULT_DEPOSIT_ADDRESS_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_SAMPLE_DELEGATE_BROKER_ID_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_SAMPLE_DELEGATE_BROKER_ID_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_SAMPLE_EARNED_FEES_USDC_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_SAMPLE_EARNED_FEES_USDC_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_SAMPLE_FLIP_BALANCE_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_SAMPLE_FLIP_BALANCE_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_SAMPLE_ID_SS58_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_SAMPLE_ID_SS58_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_SAMPLE_REGISTRATION_ID_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_SAMPLE_REGISTRATION_ID_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_SAMPLE_WITHDRAWAL_ADDRESS_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_STDDEV_SAMPLE_WITHDRAWAL_ADDRESS_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_SUM_ALIAS_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_SUM_ALIAS_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_SUM_BONDED_FLIP_BALANCE_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_SUM_BONDED_FLIP_BALANCE_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_SUM_BROKER_VAULT_DEPOSIT_ADDRESS_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_SUM_BROKER_VAULT_DEPOSIT_ADDRESS_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_SUM_DELEGATE_BROKER_ID_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_SUM_DELEGATE_BROKER_ID_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_SUM_EARNED_FEES_USDC_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_SUM_EARNED_FEES_USDC_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_SUM_FLIP_BALANCE_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_SUM_FLIP_BALANCE_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_SUM_ID_SS58_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_SUM_ID_SS58_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_SUM_REGISTRATION_ID_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_SUM_REGISTRATION_ID_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_SUM_WITHDRAWAL_ADDRESS_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_SUM_WITHDRAWAL_ADDRESS_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_POPULATION_ALIAS_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_POPULATION_ALIAS_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_POPULATION_BONDED_FLIP_BALANCE_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_POPULATION_BONDED_FLIP_BALANCE_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_POPULATION_BROKER_VAULT_DEPOSIT_ADDRESS_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_POPULATION_BROKER_VAULT_DEPOSIT_ADDRESS_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_POPULATION_DELEGATE_BROKER_ID_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_POPULATION_DELEGATE_BROKER_ID_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_POPULATION_EARNED_FEES_USDC_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_POPULATION_EARNED_FEES_USDC_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_POPULATION_FLIP_BALANCE_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_POPULATION_FLIP_BALANCE_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_POPULATION_ID_SS58_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_POPULATION_ID_SS58_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_POPULATION_REGISTRATION_ID_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_POPULATION_REGISTRATION_ID_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_POPULATION_WITHDRAWAL_ADDRESS_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_POPULATION_WITHDRAWAL_ADDRESS_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_SAMPLE_ALIAS_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_SAMPLE_ALIAS_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_SAMPLE_BONDED_FLIP_BALANCE_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_SAMPLE_BONDED_FLIP_BALANCE_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_SAMPLE_BROKER_VAULT_DEPOSIT_ADDRESS_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_SAMPLE_BROKER_VAULT_DEPOSIT_ADDRESS_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_SAMPLE_DELEGATE_BROKER_ID_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_SAMPLE_DELEGATE_BROKER_ID_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_SAMPLE_EARNED_FEES_USDC_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_SAMPLE_EARNED_FEES_USDC_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_SAMPLE_FLIP_BALANCE_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_SAMPLE_FLIP_BALANCE_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_SAMPLE_ID_SS58_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_SAMPLE_ID_SS58_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_SAMPLE_REGISTRATION_ID_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_SAMPLE_REGISTRATION_ID_DESC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_SAMPLE_WITHDRAWAL_ADDRESS_ASC'
  | 'BROKER_ACCOUNTS_BY_DELEGATE_BROKER_ID_VARIANCE_SAMPLE_WITHDRAWAL_ADDRESS_DESC'
  | 'BROKER_VAULT_DEPOSIT_ADDRESS_ASC'
  | 'BROKER_VAULT_DEPOSIT_ADDRESS_DESC'
  | 'DELEGATE_BROKER_ID_ASC'
  | 'DELEGATE_BROKER_ID_DESC'
  | 'EARNED_FEES_USDC_ASC'
  | 'EARNED_FEES_USDC_DESC'
  | 'FLIP_BALANCE_ASC'
  | 'FLIP_BALANCE_DESC'
  | 'ID_SS58_ASC'
  | 'ID_SS58_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'REGISTRATION_ID_ASC'
  | 'REGISTRATION_ID_DESC'
  | 'WITHDRAWAL_ADDRESS_ASC'
  | 'WITHDRAWAL_ADDRESS_DESC';

export type Call = Node & {
  __typename?: 'Call';
  args?: Maybe<Scalars['JSON']['output']>;
  /** Reads a single `Block` that is related to this `Call`. */
  blockByBlockId: Block;
  blockId: Scalars['String']['output'];
  /** Reads a single `Call` that is related to this `Call`. */
  callByParentId?: Maybe<Call>;
  /** Reads and enables pagination through a set of `Call`. */
  callsByParentId: CallsConnection;
  error?: Maybe<Scalars['JSON']['output']>;
  /** Reads and enables pagination through a set of `Event`. */
  eventsByCallId: EventsConnection;
  /** Reads a single `Extrinsic` that is related to this `Call`. */
  extrinsicByExtrinsicId: Extrinsic;
  extrinsicId: Scalars['String']['output'];
  /** Reads a single `FrontierEthereumTransaction` that is related to this `Call`. */
  frontierEthereumTransactionByCallId?: Maybe<FrontierEthereumTransaction>;
  /**
   * Reads and enables pagination through a set of `FrontierEthereumTransaction`.
   * @deprecated Please use frontierEthereumTransactionByCallId instead
   */
  frontierEthereumTransactionsByCallId: FrontierEthereumTransactionsConnection;
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  origin?: Maybe<Scalars['JSON']['output']>;
  parentId?: Maybe<Scalars['String']['output']>;
  pos: Scalars['Int']['output'];
  success: Scalars['Boolean']['output'];
};


export type CallCallsByParentIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CallCondition>;
  filter?: InputMaybe<CallFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CallsOrderBy>>;
};


export type CallEventsByCallIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventCondition>;
  filter?: InputMaybe<EventFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};


export type CallFrontierEthereumTransactionsByCallIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FrontierEthereumTransactionCondition>;
  filter?: InputMaybe<FrontierEthereumTransactionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FrontierEthereumTransactionsOrderBy>>;
};

export type CallAggregates = {
  __typename?: 'CallAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<CallAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<CallDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<CallMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<CallMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<CallStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<CallStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<CallSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<CallVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<CallVarianceSampleAggregates>;
};

export type CallAverageAggregates = {
  __typename?: 'CallAverageAggregates';
  /** Mean average of pos across the matching connection */
  pos?: Maybe<Scalars['BigFloat']['output']>;
};

/** A condition to be used against `Call` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CallCondition = {
  /** Checks for equality with the object’s `args` field. */
  args?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `blockId` field. */
  blockId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `error` field. */
  error?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `extrinsicId` field. */
  extrinsicId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `origin` field. */
  origin?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `parentId` field. */
  parentId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pos` field. */
  pos?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `success` field. */
  success?: InputMaybe<Scalars['Boolean']['input']>;
};

export type CallDistinctCountAggregates = {
  __typename?: 'CallDistinctCountAggregates';
  /** Distinct count of args across the matching connection */
  args?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of blockId across the matching connection */
  blockId?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of error across the matching connection */
  error?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of extrinsicId across the matching connection */
  extrinsicId?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of id across the matching connection */
  id?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of name across the matching connection */
  name?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of origin across the matching connection */
  origin?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of parentId across the matching connection */
  parentId?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of pos across the matching connection */
  pos?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of success across the matching connection */
  success?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `Call` object types. All fields are combined with a logical ‘and.’ */
export type CallFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CallFilter>>;
  /** Filter by the object’s `args` field. */
  args?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `blockId` field. */
  blockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `error` field. */
  error?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `extrinsicId` field. */
  extrinsicId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CallFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CallFilter>>;
  /** Filter by the object’s `origin` field. */
  origin?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `parentId` field. */
  parentId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pos` field. */
  pos?: InputMaybe<IntFilter>;
  /** Filter by the object’s `success` field. */
  success?: InputMaybe<BooleanFilter>;
};

/** Grouping methods for `Call` for usage during aggregation. */
export type CallGroupBy =
  | 'ARGS'
  | 'BLOCK_ID'
  | 'ERROR'
  | 'EXTRINSIC_ID'
  | 'NAME'
  | 'ORIGIN'
  | 'PARENT_ID'
  | 'POS'
  | 'SUCCESS';

export type CallHavingAverageInput = {
  pos?: InputMaybe<HavingIntFilter>;
};

export type CallHavingDistinctCountInput = {
  pos?: InputMaybe<HavingIntFilter>;
};

/** Conditions for `Call` aggregates. */
export type CallHavingInput = {
  AND?: InputMaybe<Array<CallHavingInput>>;
  OR?: InputMaybe<Array<CallHavingInput>>;
  average?: InputMaybe<CallHavingAverageInput>;
  distinctCount?: InputMaybe<CallHavingDistinctCountInput>;
  max?: InputMaybe<CallHavingMaxInput>;
  min?: InputMaybe<CallHavingMinInput>;
  stddevPopulation?: InputMaybe<CallHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<CallHavingStddevSampleInput>;
  sum?: InputMaybe<CallHavingSumInput>;
  variancePopulation?: InputMaybe<CallHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<CallHavingVarianceSampleInput>;
};

export type CallHavingMaxInput = {
  pos?: InputMaybe<HavingIntFilter>;
};

export type CallHavingMinInput = {
  pos?: InputMaybe<HavingIntFilter>;
};

export type CallHavingStddevPopulationInput = {
  pos?: InputMaybe<HavingIntFilter>;
};

export type CallHavingStddevSampleInput = {
  pos?: InputMaybe<HavingIntFilter>;
};

export type CallHavingSumInput = {
  pos?: InputMaybe<HavingIntFilter>;
};

export type CallHavingVariancePopulationInput = {
  pos?: InputMaybe<HavingIntFilter>;
};

export type CallHavingVarianceSampleInput = {
  pos?: InputMaybe<HavingIntFilter>;
};

export type CallMaxAggregates = {
  __typename?: 'CallMaxAggregates';
  /** Maximum of pos across the matching connection */
  pos?: Maybe<Scalars['Int']['output']>;
};

export type CallMinAggregates = {
  __typename?: 'CallMinAggregates';
  /** Minimum of pos across the matching connection */
  pos?: Maybe<Scalars['Int']['output']>;
};

export type CallStddevPopulationAggregates = {
  __typename?: 'CallStddevPopulationAggregates';
  /** Population standard deviation of pos across the matching connection */
  pos?: Maybe<Scalars['BigFloat']['output']>;
};

export type CallStddevSampleAggregates = {
  __typename?: 'CallStddevSampleAggregates';
  /** Sample standard deviation of pos across the matching connection */
  pos?: Maybe<Scalars['BigFloat']['output']>;
};

export type CallSumAggregates = {
  __typename?: 'CallSumAggregates';
  /** Sum of pos across the matching connection */
  pos: Scalars['BigInt']['output'];
};

export type CallVariancePopulationAggregates = {
  __typename?: 'CallVariancePopulationAggregates';
  /** Population variance of pos across the matching connection */
  pos?: Maybe<Scalars['BigFloat']['output']>;
};

export type CallVarianceSampleAggregates = {
  __typename?: 'CallVarianceSampleAggregates';
  /** Sample variance of pos across the matching connection */
  pos?: Maybe<Scalars['BigFloat']['output']>;
};

/** A connection to a list of `Call` values. */
export type CallsConnection = {
  __typename?: 'CallsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<CallAggregates>;
  /** A list of edges which contains the `Call` and cursor to aid in pagination. */
  edges: Array<CallsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<CallAggregates>>;
  /** A list of `Call` objects. */
  nodes: Array<Call>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Call` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `Call` values. */
export type CallsConnectionGroupedAggregatesArgs = {
  groupBy: Array<CallGroupBy>;
  having?: InputMaybe<CallHavingInput>;
};

/** A `Call` edge in the connection. */
export type CallsEdge = {
  __typename?: 'CallsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Call` at the end of the edge. */
  node: Call;
};

/** Methods to use when ordering `Call`. */
export type CallsOrderBy =
  | 'ARGS_ASC'
  | 'ARGS_DESC'
  | 'BLOCK_ID_ASC'
  | 'BLOCK_ID_DESC'
  | 'CALLS_BY_PARENT_ID_AVERAGE_ARGS_ASC'
  | 'CALLS_BY_PARENT_ID_AVERAGE_ARGS_DESC'
  | 'CALLS_BY_PARENT_ID_AVERAGE_BLOCK_ID_ASC'
  | 'CALLS_BY_PARENT_ID_AVERAGE_BLOCK_ID_DESC'
  | 'CALLS_BY_PARENT_ID_AVERAGE_ERROR_ASC'
  | 'CALLS_BY_PARENT_ID_AVERAGE_ERROR_DESC'
  | 'CALLS_BY_PARENT_ID_AVERAGE_EXTRINSIC_ID_ASC'
  | 'CALLS_BY_PARENT_ID_AVERAGE_EXTRINSIC_ID_DESC'
  | 'CALLS_BY_PARENT_ID_AVERAGE_ID_ASC'
  | 'CALLS_BY_PARENT_ID_AVERAGE_ID_DESC'
  | 'CALLS_BY_PARENT_ID_AVERAGE_NAME_ASC'
  | 'CALLS_BY_PARENT_ID_AVERAGE_NAME_DESC'
  | 'CALLS_BY_PARENT_ID_AVERAGE_ORIGIN_ASC'
  | 'CALLS_BY_PARENT_ID_AVERAGE_ORIGIN_DESC'
  | 'CALLS_BY_PARENT_ID_AVERAGE_PARENT_ID_ASC'
  | 'CALLS_BY_PARENT_ID_AVERAGE_PARENT_ID_DESC'
  | 'CALLS_BY_PARENT_ID_AVERAGE_POS_ASC'
  | 'CALLS_BY_PARENT_ID_AVERAGE_POS_DESC'
  | 'CALLS_BY_PARENT_ID_AVERAGE_SUCCESS_ASC'
  | 'CALLS_BY_PARENT_ID_AVERAGE_SUCCESS_DESC'
  | 'CALLS_BY_PARENT_ID_COUNT_ASC'
  | 'CALLS_BY_PARENT_ID_COUNT_DESC'
  | 'CALLS_BY_PARENT_ID_DISTINCT_COUNT_ARGS_ASC'
  | 'CALLS_BY_PARENT_ID_DISTINCT_COUNT_ARGS_DESC'
  | 'CALLS_BY_PARENT_ID_DISTINCT_COUNT_BLOCK_ID_ASC'
  | 'CALLS_BY_PARENT_ID_DISTINCT_COUNT_BLOCK_ID_DESC'
  | 'CALLS_BY_PARENT_ID_DISTINCT_COUNT_ERROR_ASC'
  | 'CALLS_BY_PARENT_ID_DISTINCT_COUNT_ERROR_DESC'
  | 'CALLS_BY_PARENT_ID_DISTINCT_COUNT_EXTRINSIC_ID_ASC'
  | 'CALLS_BY_PARENT_ID_DISTINCT_COUNT_EXTRINSIC_ID_DESC'
  | 'CALLS_BY_PARENT_ID_DISTINCT_COUNT_ID_ASC'
  | 'CALLS_BY_PARENT_ID_DISTINCT_COUNT_ID_DESC'
  | 'CALLS_BY_PARENT_ID_DISTINCT_COUNT_NAME_ASC'
  | 'CALLS_BY_PARENT_ID_DISTINCT_COUNT_NAME_DESC'
  | 'CALLS_BY_PARENT_ID_DISTINCT_COUNT_ORIGIN_ASC'
  | 'CALLS_BY_PARENT_ID_DISTINCT_COUNT_ORIGIN_DESC'
  | 'CALLS_BY_PARENT_ID_DISTINCT_COUNT_PARENT_ID_ASC'
  | 'CALLS_BY_PARENT_ID_DISTINCT_COUNT_PARENT_ID_DESC'
  | 'CALLS_BY_PARENT_ID_DISTINCT_COUNT_POS_ASC'
  | 'CALLS_BY_PARENT_ID_DISTINCT_COUNT_POS_DESC'
  | 'CALLS_BY_PARENT_ID_DISTINCT_COUNT_SUCCESS_ASC'
  | 'CALLS_BY_PARENT_ID_DISTINCT_COUNT_SUCCESS_DESC'
  | 'CALLS_BY_PARENT_ID_MAX_ARGS_ASC'
  | 'CALLS_BY_PARENT_ID_MAX_ARGS_DESC'
  | 'CALLS_BY_PARENT_ID_MAX_BLOCK_ID_ASC'
  | 'CALLS_BY_PARENT_ID_MAX_BLOCK_ID_DESC'
  | 'CALLS_BY_PARENT_ID_MAX_ERROR_ASC'
  | 'CALLS_BY_PARENT_ID_MAX_ERROR_DESC'
  | 'CALLS_BY_PARENT_ID_MAX_EXTRINSIC_ID_ASC'
  | 'CALLS_BY_PARENT_ID_MAX_EXTRINSIC_ID_DESC'
  | 'CALLS_BY_PARENT_ID_MAX_ID_ASC'
  | 'CALLS_BY_PARENT_ID_MAX_ID_DESC'
  | 'CALLS_BY_PARENT_ID_MAX_NAME_ASC'
  | 'CALLS_BY_PARENT_ID_MAX_NAME_DESC'
  | 'CALLS_BY_PARENT_ID_MAX_ORIGIN_ASC'
  | 'CALLS_BY_PARENT_ID_MAX_ORIGIN_DESC'
  | 'CALLS_BY_PARENT_ID_MAX_PARENT_ID_ASC'
  | 'CALLS_BY_PARENT_ID_MAX_PARENT_ID_DESC'
  | 'CALLS_BY_PARENT_ID_MAX_POS_ASC'
  | 'CALLS_BY_PARENT_ID_MAX_POS_DESC'
  | 'CALLS_BY_PARENT_ID_MAX_SUCCESS_ASC'
  | 'CALLS_BY_PARENT_ID_MAX_SUCCESS_DESC'
  | 'CALLS_BY_PARENT_ID_MIN_ARGS_ASC'
  | 'CALLS_BY_PARENT_ID_MIN_ARGS_DESC'
  | 'CALLS_BY_PARENT_ID_MIN_BLOCK_ID_ASC'
  | 'CALLS_BY_PARENT_ID_MIN_BLOCK_ID_DESC'
  | 'CALLS_BY_PARENT_ID_MIN_ERROR_ASC'
  | 'CALLS_BY_PARENT_ID_MIN_ERROR_DESC'
  | 'CALLS_BY_PARENT_ID_MIN_EXTRINSIC_ID_ASC'
  | 'CALLS_BY_PARENT_ID_MIN_EXTRINSIC_ID_DESC'
  | 'CALLS_BY_PARENT_ID_MIN_ID_ASC'
  | 'CALLS_BY_PARENT_ID_MIN_ID_DESC'
  | 'CALLS_BY_PARENT_ID_MIN_NAME_ASC'
  | 'CALLS_BY_PARENT_ID_MIN_NAME_DESC'
  | 'CALLS_BY_PARENT_ID_MIN_ORIGIN_ASC'
  | 'CALLS_BY_PARENT_ID_MIN_ORIGIN_DESC'
  | 'CALLS_BY_PARENT_ID_MIN_PARENT_ID_ASC'
  | 'CALLS_BY_PARENT_ID_MIN_PARENT_ID_DESC'
  | 'CALLS_BY_PARENT_ID_MIN_POS_ASC'
  | 'CALLS_BY_PARENT_ID_MIN_POS_DESC'
  | 'CALLS_BY_PARENT_ID_MIN_SUCCESS_ASC'
  | 'CALLS_BY_PARENT_ID_MIN_SUCCESS_DESC'
  | 'CALLS_BY_PARENT_ID_STDDEV_POPULATION_ARGS_ASC'
  | 'CALLS_BY_PARENT_ID_STDDEV_POPULATION_ARGS_DESC'
  | 'CALLS_BY_PARENT_ID_STDDEV_POPULATION_BLOCK_ID_ASC'
  | 'CALLS_BY_PARENT_ID_STDDEV_POPULATION_BLOCK_ID_DESC'
  | 'CALLS_BY_PARENT_ID_STDDEV_POPULATION_ERROR_ASC'
  | 'CALLS_BY_PARENT_ID_STDDEV_POPULATION_ERROR_DESC'
  | 'CALLS_BY_PARENT_ID_STDDEV_POPULATION_EXTRINSIC_ID_ASC'
  | 'CALLS_BY_PARENT_ID_STDDEV_POPULATION_EXTRINSIC_ID_DESC'
  | 'CALLS_BY_PARENT_ID_STDDEV_POPULATION_ID_ASC'
  | 'CALLS_BY_PARENT_ID_STDDEV_POPULATION_ID_DESC'
  | 'CALLS_BY_PARENT_ID_STDDEV_POPULATION_NAME_ASC'
  | 'CALLS_BY_PARENT_ID_STDDEV_POPULATION_NAME_DESC'
  | 'CALLS_BY_PARENT_ID_STDDEV_POPULATION_ORIGIN_ASC'
  | 'CALLS_BY_PARENT_ID_STDDEV_POPULATION_ORIGIN_DESC'
  | 'CALLS_BY_PARENT_ID_STDDEV_POPULATION_PARENT_ID_ASC'
  | 'CALLS_BY_PARENT_ID_STDDEV_POPULATION_PARENT_ID_DESC'
  | 'CALLS_BY_PARENT_ID_STDDEV_POPULATION_POS_ASC'
  | 'CALLS_BY_PARENT_ID_STDDEV_POPULATION_POS_DESC'
  | 'CALLS_BY_PARENT_ID_STDDEV_POPULATION_SUCCESS_ASC'
  | 'CALLS_BY_PARENT_ID_STDDEV_POPULATION_SUCCESS_DESC'
  | 'CALLS_BY_PARENT_ID_STDDEV_SAMPLE_ARGS_ASC'
  | 'CALLS_BY_PARENT_ID_STDDEV_SAMPLE_ARGS_DESC'
  | 'CALLS_BY_PARENT_ID_STDDEV_SAMPLE_BLOCK_ID_ASC'
  | 'CALLS_BY_PARENT_ID_STDDEV_SAMPLE_BLOCK_ID_DESC'
  | 'CALLS_BY_PARENT_ID_STDDEV_SAMPLE_ERROR_ASC'
  | 'CALLS_BY_PARENT_ID_STDDEV_SAMPLE_ERROR_DESC'
  | 'CALLS_BY_PARENT_ID_STDDEV_SAMPLE_EXTRINSIC_ID_ASC'
  | 'CALLS_BY_PARENT_ID_STDDEV_SAMPLE_EXTRINSIC_ID_DESC'
  | 'CALLS_BY_PARENT_ID_STDDEV_SAMPLE_ID_ASC'
  | 'CALLS_BY_PARENT_ID_STDDEV_SAMPLE_ID_DESC'
  | 'CALLS_BY_PARENT_ID_STDDEV_SAMPLE_NAME_ASC'
  | 'CALLS_BY_PARENT_ID_STDDEV_SAMPLE_NAME_DESC'
  | 'CALLS_BY_PARENT_ID_STDDEV_SAMPLE_ORIGIN_ASC'
  | 'CALLS_BY_PARENT_ID_STDDEV_SAMPLE_ORIGIN_DESC'
  | 'CALLS_BY_PARENT_ID_STDDEV_SAMPLE_PARENT_ID_ASC'
  | 'CALLS_BY_PARENT_ID_STDDEV_SAMPLE_PARENT_ID_DESC'
  | 'CALLS_BY_PARENT_ID_STDDEV_SAMPLE_POS_ASC'
  | 'CALLS_BY_PARENT_ID_STDDEV_SAMPLE_POS_DESC'
  | 'CALLS_BY_PARENT_ID_STDDEV_SAMPLE_SUCCESS_ASC'
  | 'CALLS_BY_PARENT_ID_STDDEV_SAMPLE_SUCCESS_DESC'
  | 'CALLS_BY_PARENT_ID_SUM_ARGS_ASC'
  | 'CALLS_BY_PARENT_ID_SUM_ARGS_DESC'
  | 'CALLS_BY_PARENT_ID_SUM_BLOCK_ID_ASC'
  | 'CALLS_BY_PARENT_ID_SUM_BLOCK_ID_DESC'
  | 'CALLS_BY_PARENT_ID_SUM_ERROR_ASC'
  | 'CALLS_BY_PARENT_ID_SUM_ERROR_DESC'
  | 'CALLS_BY_PARENT_ID_SUM_EXTRINSIC_ID_ASC'
  | 'CALLS_BY_PARENT_ID_SUM_EXTRINSIC_ID_DESC'
  | 'CALLS_BY_PARENT_ID_SUM_ID_ASC'
  | 'CALLS_BY_PARENT_ID_SUM_ID_DESC'
  | 'CALLS_BY_PARENT_ID_SUM_NAME_ASC'
  | 'CALLS_BY_PARENT_ID_SUM_NAME_DESC'
  | 'CALLS_BY_PARENT_ID_SUM_ORIGIN_ASC'
  | 'CALLS_BY_PARENT_ID_SUM_ORIGIN_DESC'
  | 'CALLS_BY_PARENT_ID_SUM_PARENT_ID_ASC'
  | 'CALLS_BY_PARENT_ID_SUM_PARENT_ID_DESC'
  | 'CALLS_BY_PARENT_ID_SUM_POS_ASC'
  | 'CALLS_BY_PARENT_ID_SUM_POS_DESC'
  | 'CALLS_BY_PARENT_ID_SUM_SUCCESS_ASC'
  | 'CALLS_BY_PARENT_ID_SUM_SUCCESS_DESC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_POPULATION_ARGS_ASC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_POPULATION_ARGS_DESC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_POPULATION_BLOCK_ID_ASC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_POPULATION_BLOCK_ID_DESC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_POPULATION_ERROR_ASC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_POPULATION_ERROR_DESC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_POPULATION_EXTRINSIC_ID_ASC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_POPULATION_EXTRINSIC_ID_DESC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_POPULATION_ID_ASC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_POPULATION_ID_DESC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_POPULATION_NAME_ASC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_POPULATION_NAME_DESC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_POPULATION_ORIGIN_ASC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_POPULATION_ORIGIN_DESC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_POPULATION_PARENT_ID_ASC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_POPULATION_PARENT_ID_DESC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_POPULATION_POS_ASC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_POPULATION_POS_DESC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_POPULATION_SUCCESS_ASC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_POPULATION_SUCCESS_DESC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_SAMPLE_ARGS_ASC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_SAMPLE_ARGS_DESC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_SAMPLE_BLOCK_ID_ASC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_SAMPLE_BLOCK_ID_DESC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_SAMPLE_ERROR_ASC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_SAMPLE_ERROR_DESC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_SAMPLE_EXTRINSIC_ID_ASC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_SAMPLE_EXTRINSIC_ID_DESC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_SAMPLE_ID_ASC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_SAMPLE_ID_DESC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_SAMPLE_NAME_ASC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_SAMPLE_NAME_DESC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_SAMPLE_ORIGIN_ASC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_SAMPLE_ORIGIN_DESC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_SAMPLE_PARENT_ID_ASC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_SAMPLE_PARENT_ID_DESC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_SAMPLE_POS_ASC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_SAMPLE_POS_DESC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_SAMPLE_SUCCESS_ASC'
  | 'CALLS_BY_PARENT_ID_VARIANCE_SAMPLE_SUCCESS_DESC'
  | 'ERROR_ASC'
  | 'ERROR_DESC'
  | 'EVENTS_BY_CALL_ID_AVERAGE_ARGS_ASC'
  | 'EVENTS_BY_CALL_ID_AVERAGE_ARGS_DESC'
  | 'EVENTS_BY_CALL_ID_AVERAGE_BLOCK_ID_ASC'
  | 'EVENTS_BY_CALL_ID_AVERAGE_BLOCK_ID_DESC'
  | 'EVENTS_BY_CALL_ID_AVERAGE_CALL_ID_ASC'
  | 'EVENTS_BY_CALL_ID_AVERAGE_CALL_ID_DESC'
  | 'EVENTS_BY_CALL_ID_AVERAGE_EXTRINSIC_ID_ASC'
  | 'EVENTS_BY_CALL_ID_AVERAGE_EXTRINSIC_ID_DESC'
  | 'EVENTS_BY_CALL_ID_AVERAGE_ID_ASC'
  | 'EVENTS_BY_CALL_ID_AVERAGE_ID_DESC'
  | 'EVENTS_BY_CALL_ID_AVERAGE_INDEX_IN_BLOCK_ASC'
  | 'EVENTS_BY_CALL_ID_AVERAGE_INDEX_IN_BLOCK_DESC'
  | 'EVENTS_BY_CALL_ID_AVERAGE_NAME_ASC'
  | 'EVENTS_BY_CALL_ID_AVERAGE_NAME_DESC'
  | 'EVENTS_BY_CALL_ID_AVERAGE_PHASE_ASC'
  | 'EVENTS_BY_CALL_ID_AVERAGE_PHASE_DESC'
  | 'EVENTS_BY_CALL_ID_AVERAGE_POS_ASC'
  | 'EVENTS_BY_CALL_ID_AVERAGE_POS_DESC'
  | 'EVENTS_BY_CALL_ID_COUNT_ASC'
  | 'EVENTS_BY_CALL_ID_COUNT_DESC'
  | 'EVENTS_BY_CALL_ID_DISTINCT_COUNT_ARGS_ASC'
  | 'EVENTS_BY_CALL_ID_DISTINCT_COUNT_ARGS_DESC'
  | 'EVENTS_BY_CALL_ID_DISTINCT_COUNT_BLOCK_ID_ASC'
  | 'EVENTS_BY_CALL_ID_DISTINCT_COUNT_BLOCK_ID_DESC'
  | 'EVENTS_BY_CALL_ID_DISTINCT_COUNT_CALL_ID_ASC'
  | 'EVENTS_BY_CALL_ID_DISTINCT_COUNT_CALL_ID_DESC'
  | 'EVENTS_BY_CALL_ID_DISTINCT_COUNT_EXTRINSIC_ID_ASC'
  | 'EVENTS_BY_CALL_ID_DISTINCT_COUNT_EXTRINSIC_ID_DESC'
  | 'EVENTS_BY_CALL_ID_DISTINCT_COUNT_ID_ASC'
  | 'EVENTS_BY_CALL_ID_DISTINCT_COUNT_ID_DESC'
  | 'EVENTS_BY_CALL_ID_DISTINCT_COUNT_INDEX_IN_BLOCK_ASC'
  | 'EVENTS_BY_CALL_ID_DISTINCT_COUNT_INDEX_IN_BLOCK_DESC'
  | 'EVENTS_BY_CALL_ID_DISTINCT_COUNT_NAME_ASC'
  | 'EVENTS_BY_CALL_ID_DISTINCT_COUNT_NAME_DESC'
  | 'EVENTS_BY_CALL_ID_DISTINCT_COUNT_PHASE_ASC'
  | 'EVENTS_BY_CALL_ID_DISTINCT_COUNT_PHASE_DESC'
  | 'EVENTS_BY_CALL_ID_DISTINCT_COUNT_POS_ASC'
  | 'EVENTS_BY_CALL_ID_DISTINCT_COUNT_POS_DESC'
  | 'EVENTS_BY_CALL_ID_MAX_ARGS_ASC'
  | 'EVENTS_BY_CALL_ID_MAX_ARGS_DESC'
  | 'EVENTS_BY_CALL_ID_MAX_BLOCK_ID_ASC'
  | 'EVENTS_BY_CALL_ID_MAX_BLOCK_ID_DESC'
  | 'EVENTS_BY_CALL_ID_MAX_CALL_ID_ASC'
  | 'EVENTS_BY_CALL_ID_MAX_CALL_ID_DESC'
  | 'EVENTS_BY_CALL_ID_MAX_EXTRINSIC_ID_ASC'
  | 'EVENTS_BY_CALL_ID_MAX_EXTRINSIC_ID_DESC'
  | 'EVENTS_BY_CALL_ID_MAX_ID_ASC'
  | 'EVENTS_BY_CALL_ID_MAX_ID_DESC'
  | 'EVENTS_BY_CALL_ID_MAX_INDEX_IN_BLOCK_ASC'
  | 'EVENTS_BY_CALL_ID_MAX_INDEX_IN_BLOCK_DESC'
  | 'EVENTS_BY_CALL_ID_MAX_NAME_ASC'
  | 'EVENTS_BY_CALL_ID_MAX_NAME_DESC'
  | 'EVENTS_BY_CALL_ID_MAX_PHASE_ASC'
  | 'EVENTS_BY_CALL_ID_MAX_PHASE_DESC'
  | 'EVENTS_BY_CALL_ID_MAX_POS_ASC'
  | 'EVENTS_BY_CALL_ID_MAX_POS_DESC'
  | 'EVENTS_BY_CALL_ID_MIN_ARGS_ASC'
  | 'EVENTS_BY_CALL_ID_MIN_ARGS_DESC'
  | 'EVENTS_BY_CALL_ID_MIN_BLOCK_ID_ASC'
  | 'EVENTS_BY_CALL_ID_MIN_BLOCK_ID_DESC'
  | 'EVENTS_BY_CALL_ID_MIN_CALL_ID_ASC'
  | 'EVENTS_BY_CALL_ID_MIN_CALL_ID_DESC'
  | 'EVENTS_BY_CALL_ID_MIN_EXTRINSIC_ID_ASC'
  | 'EVENTS_BY_CALL_ID_MIN_EXTRINSIC_ID_DESC'
  | 'EVENTS_BY_CALL_ID_MIN_ID_ASC'
  | 'EVENTS_BY_CALL_ID_MIN_ID_DESC'
  | 'EVENTS_BY_CALL_ID_MIN_INDEX_IN_BLOCK_ASC'
  | 'EVENTS_BY_CALL_ID_MIN_INDEX_IN_BLOCK_DESC'
  | 'EVENTS_BY_CALL_ID_MIN_NAME_ASC'
  | 'EVENTS_BY_CALL_ID_MIN_NAME_DESC'
  | 'EVENTS_BY_CALL_ID_MIN_PHASE_ASC'
  | 'EVENTS_BY_CALL_ID_MIN_PHASE_DESC'
  | 'EVENTS_BY_CALL_ID_MIN_POS_ASC'
  | 'EVENTS_BY_CALL_ID_MIN_POS_DESC'
  | 'EVENTS_BY_CALL_ID_STDDEV_POPULATION_ARGS_ASC'
  | 'EVENTS_BY_CALL_ID_STDDEV_POPULATION_ARGS_DESC'
  | 'EVENTS_BY_CALL_ID_STDDEV_POPULATION_BLOCK_ID_ASC'
  | 'EVENTS_BY_CALL_ID_STDDEV_POPULATION_BLOCK_ID_DESC'
  | 'EVENTS_BY_CALL_ID_STDDEV_POPULATION_CALL_ID_ASC'
  | 'EVENTS_BY_CALL_ID_STDDEV_POPULATION_CALL_ID_DESC'
  | 'EVENTS_BY_CALL_ID_STDDEV_POPULATION_EXTRINSIC_ID_ASC'
  | 'EVENTS_BY_CALL_ID_STDDEV_POPULATION_EXTRINSIC_ID_DESC'
  | 'EVENTS_BY_CALL_ID_STDDEV_POPULATION_ID_ASC'
  | 'EVENTS_BY_CALL_ID_STDDEV_POPULATION_ID_DESC'
  | 'EVENTS_BY_CALL_ID_STDDEV_POPULATION_INDEX_IN_BLOCK_ASC'
  | 'EVENTS_BY_CALL_ID_STDDEV_POPULATION_INDEX_IN_BLOCK_DESC'
  | 'EVENTS_BY_CALL_ID_STDDEV_POPULATION_NAME_ASC'
  | 'EVENTS_BY_CALL_ID_STDDEV_POPULATION_NAME_DESC'
  | 'EVENTS_BY_CALL_ID_STDDEV_POPULATION_PHASE_ASC'
  | 'EVENTS_BY_CALL_ID_STDDEV_POPULATION_PHASE_DESC'
  | 'EVENTS_BY_CALL_ID_STDDEV_POPULATION_POS_ASC'
  | 'EVENTS_BY_CALL_ID_STDDEV_POPULATION_POS_DESC'
  | 'EVENTS_BY_CALL_ID_STDDEV_SAMPLE_ARGS_ASC'
  | 'EVENTS_BY_CALL_ID_STDDEV_SAMPLE_ARGS_DESC'
  | 'EVENTS_BY_CALL_ID_STDDEV_SAMPLE_BLOCK_ID_ASC'
  | 'EVENTS_BY_CALL_ID_STDDEV_SAMPLE_BLOCK_ID_DESC'
  | 'EVENTS_BY_CALL_ID_STDDEV_SAMPLE_CALL_ID_ASC'
  | 'EVENTS_BY_CALL_ID_STDDEV_SAMPLE_CALL_ID_DESC'
  | 'EVENTS_BY_CALL_ID_STDDEV_SAMPLE_EXTRINSIC_ID_ASC'
  | 'EVENTS_BY_CALL_ID_STDDEV_SAMPLE_EXTRINSIC_ID_DESC'
  | 'EVENTS_BY_CALL_ID_STDDEV_SAMPLE_ID_ASC'
  | 'EVENTS_BY_CALL_ID_STDDEV_SAMPLE_ID_DESC'
  | 'EVENTS_BY_CALL_ID_STDDEV_SAMPLE_INDEX_IN_BLOCK_ASC'
  | 'EVENTS_BY_CALL_ID_STDDEV_SAMPLE_INDEX_IN_BLOCK_DESC'
  | 'EVENTS_BY_CALL_ID_STDDEV_SAMPLE_NAME_ASC'
  | 'EVENTS_BY_CALL_ID_STDDEV_SAMPLE_NAME_DESC'
  | 'EVENTS_BY_CALL_ID_STDDEV_SAMPLE_PHASE_ASC'
  | 'EVENTS_BY_CALL_ID_STDDEV_SAMPLE_PHASE_DESC'
  | 'EVENTS_BY_CALL_ID_STDDEV_SAMPLE_POS_ASC'
  | 'EVENTS_BY_CALL_ID_STDDEV_SAMPLE_POS_DESC'
  | 'EVENTS_BY_CALL_ID_SUM_ARGS_ASC'
  | 'EVENTS_BY_CALL_ID_SUM_ARGS_DESC'
  | 'EVENTS_BY_CALL_ID_SUM_BLOCK_ID_ASC'
  | 'EVENTS_BY_CALL_ID_SUM_BLOCK_ID_DESC'
  | 'EVENTS_BY_CALL_ID_SUM_CALL_ID_ASC'
  | 'EVENTS_BY_CALL_ID_SUM_CALL_ID_DESC'
  | 'EVENTS_BY_CALL_ID_SUM_EXTRINSIC_ID_ASC'
  | 'EVENTS_BY_CALL_ID_SUM_EXTRINSIC_ID_DESC'
  | 'EVENTS_BY_CALL_ID_SUM_ID_ASC'
  | 'EVENTS_BY_CALL_ID_SUM_ID_DESC'
  | 'EVENTS_BY_CALL_ID_SUM_INDEX_IN_BLOCK_ASC'
  | 'EVENTS_BY_CALL_ID_SUM_INDEX_IN_BLOCK_DESC'
  | 'EVENTS_BY_CALL_ID_SUM_NAME_ASC'
  | 'EVENTS_BY_CALL_ID_SUM_NAME_DESC'
  | 'EVENTS_BY_CALL_ID_SUM_PHASE_ASC'
  | 'EVENTS_BY_CALL_ID_SUM_PHASE_DESC'
  | 'EVENTS_BY_CALL_ID_SUM_POS_ASC'
  | 'EVENTS_BY_CALL_ID_SUM_POS_DESC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_POPULATION_ARGS_ASC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_POPULATION_ARGS_DESC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_POPULATION_BLOCK_ID_ASC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_POPULATION_BLOCK_ID_DESC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_POPULATION_CALL_ID_ASC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_POPULATION_CALL_ID_DESC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_POPULATION_EXTRINSIC_ID_ASC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_POPULATION_EXTRINSIC_ID_DESC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_POPULATION_ID_ASC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_POPULATION_ID_DESC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_POPULATION_INDEX_IN_BLOCK_ASC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_POPULATION_INDEX_IN_BLOCK_DESC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_POPULATION_NAME_ASC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_POPULATION_NAME_DESC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_POPULATION_PHASE_ASC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_POPULATION_PHASE_DESC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_POPULATION_POS_ASC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_POPULATION_POS_DESC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_SAMPLE_ARGS_ASC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_SAMPLE_ARGS_DESC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_SAMPLE_BLOCK_ID_ASC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_SAMPLE_BLOCK_ID_DESC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_SAMPLE_CALL_ID_ASC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_SAMPLE_CALL_ID_DESC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_SAMPLE_EXTRINSIC_ID_ASC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_SAMPLE_EXTRINSIC_ID_DESC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_SAMPLE_ID_ASC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_SAMPLE_ID_DESC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_SAMPLE_INDEX_IN_BLOCK_ASC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_SAMPLE_INDEX_IN_BLOCK_DESC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_SAMPLE_NAME_ASC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_SAMPLE_NAME_DESC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_SAMPLE_PHASE_ASC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_SAMPLE_PHASE_DESC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_SAMPLE_POS_ASC'
  | 'EVENTS_BY_CALL_ID_VARIANCE_SAMPLE_POS_DESC'
  | 'EXTRINSIC_ID_ASC'
  | 'EXTRINSIC_ID_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'NATURAL'
  | 'ORIGIN_ASC'
  | 'ORIGIN_DESC'
  | 'PARENT_ID_ASC'
  | 'PARENT_ID_DESC'
  | 'POS_ASC'
  | 'POS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SUCCESS_ASC'
  | 'SUCCESS_DESC';

export type ChainflipAsset =
  | 'ArbEth'
  | 'ArbUsdc'
  | 'Btc'
  | 'Dot'
  | 'Eth'
  | 'Flip'
  | 'HubDot'
  | 'HubUsdc'
  | 'HubUsdt'
  | 'Sol'
  | 'SolUsdc'
  | 'Usdc'
  | 'Usdt';

/** A filter to be used against ChainflipAsset fields. All fields are combined with a logical ‘and.’ */
export type ChainflipAssetFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<ChainflipAsset>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<ChainflipAsset>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<ChainflipAsset>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<ChainflipAsset>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<ChainflipAsset>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<ChainflipAsset>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<ChainflipAsset>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<ChainflipAsset>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<ChainflipAsset>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<ChainflipAsset>>;
};

export type ChainflipChain =
  | 'Arbitrum'
  | 'Assethub'
  | 'Bitcoin'
  | 'Ethereum'
  | 'Polkadot'
  | 'Solana';

/** A filter to be used against ChainflipChain fields. All fields are combined with a logical ‘and.’ */
export type ChainflipChainFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<ChainflipChain>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<ChainflipChain>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<ChainflipChain>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<ChainflipChain>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<ChainflipChain>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<ChainflipChain>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<ChainflipChain>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<ChainflipChain>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<ChainflipChain>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<ChainflipChain>>;
};

export type Circulation = Node & {
  __typename?: 'Circulation';
  circulatingSupply: Scalars['BigFloat']['output'];
  circulatingSupplyNotStaked: Scalars['BigFloat']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  totalLocked: Scalars['BigFloat']['output'];
  totalStaked: Scalars['BigFloat']['output'];
  totalSupply: Scalars['BigFloat']['output'];
};

export type CirculationAggregates = {
  __typename?: 'CirculationAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<CirculationAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<CirculationDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<CirculationMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<CirculationMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<CirculationStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<CirculationStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<CirculationSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<CirculationVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<CirculationVarianceSampleAggregates>;
};

export type CirculationAverageAggregates = {
  __typename?: 'CirculationAverageAggregates';
  /** Mean average of circulatingSupply across the matching connection */
  circulatingSupply?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of circulatingSupplyNotStaked across the matching connection */
  circulatingSupplyNotStaked?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of totalLocked across the matching connection */
  totalLocked?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of totalStaked across the matching connection */
  totalStaked?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of totalSupply across the matching connection */
  totalSupply?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `Circulation` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type CirculationCondition = {
  /** Checks for equality with the object’s `circulatingSupply` field. */
  circulatingSupply?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `circulatingSupplyNotStaked` field. */
  circulatingSupplyNotStaked?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `totalLocked` field. */
  totalLocked?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalStaked` field. */
  totalStaked?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalSupply` field. */
  totalSupply?: InputMaybe<Scalars['BigFloat']['input']>;
};

export type CirculationDistinctCountAggregates = {
  __typename?: 'CirculationDistinctCountAggregates';
  /** Distinct count of circulatingSupply across the matching connection */
  circulatingSupply?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of circulatingSupplyNotStaked across the matching connection */
  circulatingSupplyNotStaked?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of id across the matching connection */
  id?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of totalLocked across the matching connection */
  totalLocked?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of totalStaked across the matching connection */
  totalStaked?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of totalSupply across the matching connection */
  totalSupply?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `Circulation` object types. All fields are combined with a logical ‘and.’ */
export type CirculationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CirculationFilter>>;
  /** Filter by the object’s `circulatingSupply` field. */
  circulatingSupply?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `circulatingSupplyNotStaked` field. */
  circulatingSupplyNotStaked?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CirculationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CirculationFilter>>;
  /** Filter by the object’s `totalLocked` field. */
  totalLocked?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalStaked` field. */
  totalStaked?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalSupply` field. */
  totalSupply?: InputMaybe<BigFloatFilter>;
};

/** Grouping methods for `Circulation` for usage during aggregation. */
export type CirculationGroupBy =
  | 'CIRCULATING_SUPPLY'
  | 'CIRCULATING_SUPPLY_NOT_STAKED'
  | 'TOTAL_LOCKED'
  | 'TOTAL_STAKED'
  | 'TOTAL_SUPPLY';

export type CirculationHavingAverageInput = {
  circulatingSupply?: InputMaybe<HavingBigfloatFilter>;
  circulatingSupplyNotStaked?: InputMaybe<HavingBigfloatFilter>;
  id?: InputMaybe<HavingIntFilter>;
  totalLocked?: InputMaybe<HavingBigfloatFilter>;
  totalStaked?: InputMaybe<HavingBigfloatFilter>;
  totalSupply?: InputMaybe<HavingBigfloatFilter>;
};

export type CirculationHavingDistinctCountInput = {
  circulatingSupply?: InputMaybe<HavingBigfloatFilter>;
  circulatingSupplyNotStaked?: InputMaybe<HavingBigfloatFilter>;
  id?: InputMaybe<HavingIntFilter>;
  totalLocked?: InputMaybe<HavingBigfloatFilter>;
  totalStaked?: InputMaybe<HavingBigfloatFilter>;
  totalSupply?: InputMaybe<HavingBigfloatFilter>;
};

/** Conditions for `Circulation` aggregates. */
export type CirculationHavingInput = {
  AND?: InputMaybe<Array<CirculationHavingInput>>;
  OR?: InputMaybe<Array<CirculationHavingInput>>;
  average?: InputMaybe<CirculationHavingAverageInput>;
  distinctCount?: InputMaybe<CirculationHavingDistinctCountInput>;
  max?: InputMaybe<CirculationHavingMaxInput>;
  min?: InputMaybe<CirculationHavingMinInput>;
  stddevPopulation?: InputMaybe<CirculationHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<CirculationHavingStddevSampleInput>;
  sum?: InputMaybe<CirculationHavingSumInput>;
  variancePopulation?: InputMaybe<CirculationHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<CirculationHavingVarianceSampleInput>;
};

export type CirculationHavingMaxInput = {
  circulatingSupply?: InputMaybe<HavingBigfloatFilter>;
  circulatingSupplyNotStaked?: InputMaybe<HavingBigfloatFilter>;
  id?: InputMaybe<HavingIntFilter>;
  totalLocked?: InputMaybe<HavingBigfloatFilter>;
  totalStaked?: InputMaybe<HavingBigfloatFilter>;
  totalSupply?: InputMaybe<HavingBigfloatFilter>;
};

export type CirculationHavingMinInput = {
  circulatingSupply?: InputMaybe<HavingBigfloatFilter>;
  circulatingSupplyNotStaked?: InputMaybe<HavingBigfloatFilter>;
  id?: InputMaybe<HavingIntFilter>;
  totalLocked?: InputMaybe<HavingBigfloatFilter>;
  totalStaked?: InputMaybe<HavingBigfloatFilter>;
  totalSupply?: InputMaybe<HavingBigfloatFilter>;
};

export type CirculationHavingStddevPopulationInput = {
  circulatingSupply?: InputMaybe<HavingBigfloatFilter>;
  circulatingSupplyNotStaked?: InputMaybe<HavingBigfloatFilter>;
  id?: InputMaybe<HavingIntFilter>;
  totalLocked?: InputMaybe<HavingBigfloatFilter>;
  totalStaked?: InputMaybe<HavingBigfloatFilter>;
  totalSupply?: InputMaybe<HavingBigfloatFilter>;
};

export type CirculationHavingStddevSampleInput = {
  circulatingSupply?: InputMaybe<HavingBigfloatFilter>;
  circulatingSupplyNotStaked?: InputMaybe<HavingBigfloatFilter>;
  id?: InputMaybe<HavingIntFilter>;
  totalLocked?: InputMaybe<HavingBigfloatFilter>;
  totalStaked?: InputMaybe<HavingBigfloatFilter>;
  totalSupply?: InputMaybe<HavingBigfloatFilter>;
};

export type CirculationHavingSumInput = {
  circulatingSupply?: InputMaybe<HavingBigfloatFilter>;
  circulatingSupplyNotStaked?: InputMaybe<HavingBigfloatFilter>;
  id?: InputMaybe<HavingIntFilter>;
  totalLocked?: InputMaybe<HavingBigfloatFilter>;
  totalStaked?: InputMaybe<HavingBigfloatFilter>;
  totalSupply?: InputMaybe<HavingBigfloatFilter>;
};

export type CirculationHavingVariancePopulationInput = {
  circulatingSupply?: InputMaybe<HavingBigfloatFilter>;
  circulatingSupplyNotStaked?: InputMaybe<HavingBigfloatFilter>;
  id?: InputMaybe<HavingIntFilter>;
  totalLocked?: InputMaybe<HavingBigfloatFilter>;
  totalStaked?: InputMaybe<HavingBigfloatFilter>;
  totalSupply?: InputMaybe<HavingBigfloatFilter>;
};

export type CirculationHavingVarianceSampleInput = {
  circulatingSupply?: InputMaybe<HavingBigfloatFilter>;
  circulatingSupplyNotStaked?: InputMaybe<HavingBigfloatFilter>;
  id?: InputMaybe<HavingIntFilter>;
  totalLocked?: InputMaybe<HavingBigfloatFilter>;
  totalStaked?: InputMaybe<HavingBigfloatFilter>;
  totalSupply?: InputMaybe<HavingBigfloatFilter>;
};

export type CirculationMaxAggregates = {
  __typename?: 'CirculationMaxAggregates';
  /** Maximum of circulatingSupply across the matching connection */
  circulatingSupply?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of circulatingSupplyNotStaked across the matching connection */
  circulatingSupplyNotStaked?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of id across the matching connection */
  id?: Maybe<Scalars['Int']['output']>;
  /** Maximum of totalLocked across the matching connection */
  totalLocked?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of totalStaked across the matching connection */
  totalStaked?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of totalSupply across the matching connection */
  totalSupply?: Maybe<Scalars['BigFloat']['output']>;
};

export type CirculationMinAggregates = {
  __typename?: 'CirculationMinAggregates';
  /** Minimum of circulatingSupply across the matching connection */
  circulatingSupply?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of circulatingSupplyNotStaked across the matching connection */
  circulatingSupplyNotStaked?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of id across the matching connection */
  id?: Maybe<Scalars['Int']['output']>;
  /** Minimum of totalLocked across the matching connection */
  totalLocked?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of totalStaked across the matching connection */
  totalStaked?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of totalSupply across the matching connection */
  totalSupply?: Maybe<Scalars['BigFloat']['output']>;
};

export type CirculationStddevPopulationAggregates = {
  __typename?: 'CirculationStddevPopulationAggregates';
  /** Population standard deviation of circulatingSupply across the matching connection */
  circulatingSupply?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of circulatingSupplyNotStaked across the matching connection */
  circulatingSupplyNotStaked?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of totalLocked across the matching connection */
  totalLocked?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of totalStaked across the matching connection */
  totalStaked?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of totalSupply across the matching connection */
  totalSupply?: Maybe<Scalars['BigFloat']['output']>;
};

export type CirculationStddevSampleAggregates = {
  __typename?: 'CirculationStddevSampleAggregates';
  /** Sample standard deviation of circulatingSupply across the matching connection */
  circulatingSupply?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of circulatingSupplyNotStaked across the matching connection */
  circulatingSupplyNotStaked?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of totalLocked across the matching connection */
  totalLocked?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of totalStaked across the matching connection */
  totalStaked?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of totalSupply across the matching connection */
  totalSupply?: Maybe<Scalars['BigFloat']['output']>;
};

export type CirculationSumAggregates = {
  __typename?: 'CirculationSumAggregates';
  /** Sum of circulatingSupply across the matching connection */
  circulatingSupply: Scalars['BigFloat']['output'];
  /** Sum of circulatingSupplyNotStaked across the matching connection */
  circulatingSupplyNotStaked: Scalars['BigFloat']['output'];
  /** Sum of id across the matching connection */
  id: Scalars['BigInt']['output'];
  /** Sum of totalLocked across the matching connection */
  totalLocked: Scalars['BigFloat']['output'];
  /** Sum of totalStaked across the matching connection */
  totalStaked: Scalars['BigFloat']['output'];
  /** Sum of totalSupply across the matching connection */
  totalSupply: Scalars['BigFloat']['output'];
};

export type CirculationVariancePopulationAggregates = {
  __typename?: 'CirculationVariancePopulationAggregates';
  /** Population variance of circulatingSupply across the matching connection */
  circulatingSupply?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of circulatingSupplyNotStaked across the matching connection */
  circulatingSupplyNotStaked?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of totalLocked across the matching connection */
  totalLocked?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of totalStaked across the matching connection */
  totalStaked?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of totalSupply across the matching connection */
  totalSupply?: Maybe<Scalars['BigFloat']['output']>;
};

export type CirculationVarianceSampleAggregates = {
  __typename?: 'CirculationVarianceSampleAggregates';
  /** Sample variance of circulatingSupply across the matching connection */
  circulatingSupply?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of circulatingSupplyNotStaked across the matching connection */
  circulatingSupplyNotStaked?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of totalLocked across the matching connection */
  totalLocked?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of totalStaked across the matching connection */
  totalStaked?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of totalSupply across the matching connection */
  totalSupply?: Maybe<Scalars['BigFloat']['output']>;
};

/** A connection to a list of `Circulation` values. */
export type CirculationsConnection = {
  __typename?: 'CirculationsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<CirculationAggregates>;
  /** A list of edges which contains the `Circulation` and cursor to aid in pagination. */
  edges: Array<CirculationsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<CirculationAggregates>>;
  /** A list of `Circulation` objects. */
  nodes: Array<Circulation>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Circulation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `Circulation` values. */
export type CirculationsConnectionGroupedAggregatesArgs = {
  groupBy: Array<CirculationGroupBy>;
  having?: InputMaybe<CirculationHavingInput>;
};

/** A `Circulation` edge in the connection. */
export type CirculationsEdge = {
  __typename?: 'CirculationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Circulation` at the end of the edge. */
  node: Circulation;
};

/** Methods to use when ordering `Circulation`. */
export type CirculationsOrderBy =
  | 'CIRCULATING_SUPPLY_ASC'
  | 'CIRCULATING_SUPPLY_DESC'
  | 'CIRCULATING_SUPPLY_NOT_STAKED_ASC'
  | 'CIRCULATING_SUPPLY_NOT_STAKED_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TOTAL_LOCKED_ASC'
  | 'TOTAL_LOCKED_DESC'
  | 'TOTAL_STAKED_ASC'
  | 'TOTAL_STAKED_DESC'
  | 'TOTAL_SUPPLY_ASC'
  | 'TOTAL_SUPPLY_DESC';

export type ContractsContractEmitted = Node & {
  __typename?: 'ContractsContractEmitted';
  contract: Scalars['String']['output'];
  /** Reads a single `Event` that is related to this `ContractsContractEmitted`. */
  eventByEventId: Event;
  eventId: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

export type ContractsContractEmittedAggregates = {
  __typename?: 'ContractsContractEmittedAggregates';
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<ContractsContractEmittedDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/**
 * A condition to be used against `ContractsContractEmitted` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ContractsContractEmittedCondition = {
  /** Checks for equality with the object’s `contract` field. */
  contract?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `eventId` field. */
  eventId?: InputMaybe<Scalars['String']['input']>;
};

export type ContractsContractEmittedDistinctCountAggregates = {
  __typename?: 'ContractsContractEmittedDistinctCountAggregates';
  /** Distinct count of contract across the matching connection */
  contract?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of eventId across the matching connection */
  eventId?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `ContractsContractEmitted` object types. All fields are combined with a logical ‘and.’ */
export type ContractsContractEmittedFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ContractsContractEmittedFilter>>;
  /** Filter by the object’s `contract` field. */
  contract?: InputMaybe<StringFilter>;
  /** Filter by the object’s `eventId` field. */
  eventId?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ContractsContractEmittedFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ContractsContractEmittedFilter>>;
};

/** Grouping methods for `ContractsContractEmitted` for usage during aggregation. */
export type ContractsContractEmittedGroupBy =
  | 'CONTRACT';

/** Conditions for `ContractsContractEmitted` aggregates. */
export type ContractsContractEmittedHavingInput = {
  AND?: InputMaybe<Array<ContractsContractEmittedHavingInput>>;
  OR?: InputMaybe<Array<ContractsContractEmittedHavingInput>>;
};

/** A connection to a list of `ContractsContractEmitted` values. */
export type ContractsContractEmittedsConnection = {
  __typename?: 'ContractsContractEmittedsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<ContractsContractEmittedAggregates>;
  /** A list of edges which contains the `ContractsContractEmitted` and cursor to aid in pagination. */
  edges: Array<ContractsContractEmittedsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<ContractsContractEmittedAggregates>>;
  /** A list of `ContractsContractEmitted` objects. */
  nodes: Array<ContractsContractEmitted>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ContractsContractEmitted` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `ContractsContractEmitted` values. */
export type ContractsContractEmittedsConnectionGroupedAggregatesArgs = {
  groupBy: Array<ContractsContractEmittedGroupBy>;
  having?: InputMaybe<ContractsContractEmittedHavingInput>;
};

/** A `ContractsContractEmitted` edge in the connection. */
export type ContractsContractEmittedsEdge = {
  __typename?: 'ContractsContractEmittedsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ContractsContractEmitted` at the end of the edge. */
  node: ContractsContractEmitted;
};

/** Methods to use when ordering `ContractsContractEmitted`. */
export type ContractsContractEmittedsOrderBy =
  | 'CONTRACT_ASC'
  | 'CONTRACT_DESC'
  | 'EVENT_ID_ASC'
  | 'EVENT_ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’ */
export type DatetimeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Datetime']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Datetime']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Datetime']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Datetime']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Datetime']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Datetime']['input']>>;
};

export type Delegation = {
  __typename?: 'Delegation';
  /** Reads a single `Account` that is related to this `Delegation`. */
  accountByDelegatorIdSs58: Account;
  activeAmount: Scalars['BigFloat']['output'];
  delegatorIdSs58: Scalars['String']['output'];
  /** Reads a single `Operator` that is related to this `Delegation`. */
  operatorByOperatorIdSs58: Operator;
  operatorIdSs58: Scalars['String']['output'];
  upcomingAmount: Scalars['BigFloat']['output'];
};

export type DelegationAggregates = {
  __typename?: 'DelegationAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<DelegationAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<DelegationDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<DelegationMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<DelegationMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<DelegationStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<DelegationStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<DelegationSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<DelegationVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<DelegationVarianceSampleAggregates>;
};

/** A filter to be used against aggregates of `Delegation` object types. */
export type DelegationAggregatesFilter = {
  /** Mean average aggregate over matching `Delegation` objects. */
  average?: InputMaybe<DelegationAverageAggregateFilter>;
  /** Distinct count aggregate over matching `Delegation` objects. */
  distinctCount?: InputMaybe<DelegationDistinctCountAggregateFilter>;
  /** A filter that must pass for the relevant `Delegation` object to be included within the aggregate. */
  filter?: InputMaybe<DelegationFilter>;
  /** Maximum aggregate over matching `Delegation` objects. */
  max?: InputMaybe<DelegationMaxAggregateFilter>;
  /** Minimum aggregate over matching `Delegation` objects. */
  min?: InputMaybe<DelegationMinAggregateFilter>;
  /** Population standard deviation aggregate over matching `Delegation` objects. */
  stddevPopulation?: InputMaybe<DelegationStddevPopulationAggregateFilter>;
  /** Sample standard deviation aggregate over matching `Delegation` objects. */
  stddevSample?: InputMaybe<DelegationStddevSampleAggregateFilter>;
  /** Sum aggregate over matching `Delegation` objects. */
  sum?: InputMaybe<DelegationSumAggregateFilter>;
  /** Population variance aggregate over matching `Delegation` objects. */
  variancePopulation?: InputMaybe<DelegationVariancePopulationAggregateFilter>;
  /** Sample variance aggregate over matching `Delegation` objects. */
  varianceSample?: InputMaybe<DelegationVarianceSampleAggregateFilter>;
};

export type DelegationAverageAggregateFilter = {
  activeAmount?: InputMaybe<BigFloatFilter>;
  upcomingAmount?: InputMaybe<BigFloatFilter>;
};

export type DelegationAverageAggregates = {
  __typename?: 'DelegationAverageAggregates';
  /** Mean average of activeAmount across the matching connection */
  activeAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of upcomingAmount across the matching connection */
  upcomingAmount?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `Delegation` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type DelegationCondition = {
  /** Checks for equality with the object’s `activeAmount` field. */
  activeAmount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `delegatorIdSs58` field. */
  delegatorIdSs58?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `operatorIdSs58` field. */
  operatorIdSs58?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `upcomingAmount` field. */
  upcomingAmount?: InputMaybe<Scalars['BigFloat']['input']>;
};

export type DelegationDistinctCountAggregateFilter = {
  activeAmount?: InputMaybe<BigIntFilter>;
  delegatorIdSs58?: InputMaybe<BigIntFilter>;
  operatorIdSs58?: InputMaybe<BigIntFilter>;
  upcomingAmount?: InputMaybe<BigIntFilter>;
};

export type DelegationDistinctCountAggregates = {
  __typename?: 'DelegationDistinctCountAggregates';
  /** Distinct count of activeAmount across the matching connection */
  activeAmount?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of delegatorIdSs58 across the matching connection */
  delegatorIdSs58?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of operatorIdSs58 across the matching connection */
  operatorIdSs58?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of upcomingAmount across the matching connection */
  upcomingAmount?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `Delegation` object types. All fields are combined with a logical ‘and.’ */
export type DelegationFilter = {
  /** Filter by the object’s `accountByDelegatorIdSs58` relation. */
  accountByDelegatorIdSs58?: InputMaybe<AccountFilter>;
  /** Filter by the object’s `activeAmount` field. */
  activeAmount?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DelegationFilter>>;
  /** Filter by the object’s `delegatorIdSs58` field. */
  delegatorIdSs58?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DelegationFilter>;
  /** Filter by the object’s `operatorByOperatorIdSs58` relation. */
  operatorByOperatorIdSs58?: InputMaybe<OperatorFilter>;
  /** Filter by the object’s `operatorIdSs58` field. */
  operatorIdSs58?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DelegationFilter>>;
  /** Filter by the object’s `upcomingAmount` field. */
  upcomingAmount?: InputMaybe<BigFloatFilter>;
};

/** Grouping methods for `Delegation` for usage during aggregation. */
export type DelegationGroupBy =
  | 'ACTIVE_AMOUNT'
  | 'DELEGATOR_ID_SS58'
  | 'OPERATOR_ID_SS58'
  | 'UPCOMING_AMOUNT';

export type DelegationHavingAverageInput = {
  activeAmount?: InputMaybe<HavingBigfloatFilter>;
  upcomingAmount?: InputMaybe<HavingBigfloatFilter>;
};

export type DelegationHavingDistinctCountInput = {
  activeAmount?: InputMaybe<HavingBigfloatFilter>;
  upcomingAmount?: InputMaybe<HavingBigfloatFilter>;
};

/** Conditions for `Delegation` aggregates. */
export type DelegationHavingInput = {
  AND?: InputMaybe<Array<DelegationHavingInput>>;
  OR?: InputMaybe<Array<DelegationHavingInput>>;
  average?: InputMaybe<DelegationHavingAverageInput>;
  distinctCount?: InputMaybe<DelegationHavingDistinctCountInput>;
  max?: InputMaybe<DelegationHavingMaxInput>;
  min?: InputMaybe<DelegationHavingMinInput>;
  stddevPopulation?: InputMaybe<DelegationHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<DelegationHavingStddevSampleInput>;
  sum?: InputMaybe<DelegationHavingSumInput>;
  variancePopulation?: InputMaybe<DelegationHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<DelegationHavingVarianceSampleInput>;
};

export type DelegationHavingMaxInput = {
  activeAmount?: InputMaybe<HavingBigfloatFilter>;
  upcomingAmount?: InputMaybe<HavingBigfloatFilter>;
};

export type DelegationHavingMinInput = {
  activeAmount?: InputMaybe<HavingBigfloatFilter>;
  upcomingAmount?: InputMaybe<HavingBigfloatFilter>;
};

export type DelegationHavingStddevPopulationInput = {
  activeAmount?: InputMaybe<HavingBigfloatFilter>;
  upcomingAmount?: InputMaybe<HavingBigfloatFilter>;
};

export type DelegationHavingStddevSampleInput = {
  activeAmount?: InputMaybe<HavingBigfloatFilter>;
  upcomingAmount?: InputMaybe<HavingBigfloatFilter>;
};

export type DelegationHavingSumInput = {
  activeAmount?: InputMaybe<HavingBigfloatFilter>;
  upcomingAmount?: InputMaybe<HavingBigfloatFilter>;
};

export type DelegationHavingVariancePopulationInput = {
  activeAmount?: InputMaybe<HavingBigfloatFilter>;
  upcomingAmount?: InputMaybe<HavingBigfloatFilter>;
};

export type DelegationHavingVarianceSampleInput = {
  activeAmount?: InputMaybe<HavingBigfloatFilter>;
  upcomingAmount?: InputMaybe<HavingBigfloatFilter>;
};

export type DelegationMaxAggregateFilter = {
  activeAmount?: InputMaybe<BigFloatFilter>;
  upcomingAmount?: InputMaybe<BigFloatFilter>;
};

export type DelegationMaxAggregates = {
  __typename?: 'DelegationMaxAggregates';
  /** Maximum of activeAmount across the matching connection */
  activeAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of upcomingAmount across the matching connection */
  upcomingAmount?: Maybe<Scalars['BigFloat']['output']>;
};

export type DelegationMinAggregateFilter = {
  activeAmount?: InputMaybe<BigFloatFilter>;
  upcomingAmount?: InputMaybe<BigFloatFilter>;
};

export type DelegationMinAggregates = {
  __typename?: 'DelegationMinAggregates';
  /** Minimum of activeAmount across the matching connection */
  activeAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of upcomingAmount across the matching connection */
  upcomingAmount?: Maybe<Scalars['BigFloat']['output']>;
};

export type DelegationStddevPopulationAggregateFilter = {
  activeAmount?: InputMaybe<BigFloatFilter>;
  upcomingAmount?: InputMaybe<BigFloatFilter>;
};

export type DelegationStddevPopulationAggregates = {
  __typename?: 'DelegationStddevPopulationAggregates';
  /** Population standard deviation of activeAmount across the matching connection */
  activeAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of upcomingAmount across the matching connection */
  upcomingAmount?: Maybe<Scalars['BigFloat']['output']>;
};

export type DelegationStddevSampleAggregateFilter = {
  activeAmount?: InputMaybe<BigFloatFilter>;
  upcomingAmount?: InputMaybe<BigFloatFilter>;
};

export type DelegationStddevSampleAggregates = {
  __typename?: 'DelegationStddevSampleAggregates';
  /** Sample standard deviation of activeAmount across the matching connection */
  activeAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of upcomingAmount across the matching connection */
  upcomingAmount?: Maybe<Scalars['BigFloat']['output']>;
};

export type DelegationSumAggregateFilter = {
  activeAmount?: InputMaybe<BigFloatFilter>;
  upcomingAmount?: InputMaybe<BigFloatFilter>;
};

export type DelegationSumAggregates = {
  __typename?: 'DelegationSumAggregates';
  /** Sum of activeAmount across the matching connection */
  activeAmount: Scalars['BigFloat']['output'];
  /** Sum of upcomingAmount across the matching connection */
  upcomingAmount: Scalars['BigFloat']['output'];
};

export type DelegationVariancePopulationAggregateFilter = {
  activeAmount?: InputMaybe<BigFloatFilter>;
  upcomingAmount?: InputMaybe<BigFloatFilter>;
};

export type DelegationVariancePopulationAggregates = {
  __typename?: 'DelegationVariancePopulationAggregates';
  /** Population variance of activeAmount across the matching connection */
  activeAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of upcomingAmount across the matching connection */
  upcomingAmount?: Maybe<Scalars['BigFloat']['output']>;
};

export type DelegationVarianceSampleAggregateFilter = {
  activeAmount?: InputMaybe<BigFloatFilter>;
  upcomingAmount?: InputMaybe<BigFloatFilter>;
};

export type DelegationVarianceSampleAggregates = {
  __typename?: 'DelegationVarianceSampleAggregates';
  /** Sample variance of activeAmount across the matching connection */
  activeAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of upcomingAmount across the matching connection */
  upcomingAmount?: Maybe<Scalars['BigFloat']['output']>;
};

/** A connection to a list of `Delegation` values. */
export type DelegationsConnection = {
  __typename?: 'DelegationsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<DelegationAggregates>;
  /** A list of edges which contains the `Delegation` and cursor to aid in pagination. */
  edges: Array<DelegationsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<DelegationAggregates>>;
  /** A list of `Delegation` objects. */
  nodes: Array<Delegation>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Delegation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `Delegation` values. */
export type DelegationsConnectionGroupedAggregatesArgs = {
  groupBy: Array<DelegationGroupBy>;
  having?: InputMaybe<DelegationHavingInput>;
};

/** A `Delegation` edge in the connection. */
export type DelegationsEdge = {
  __typename?: 'DelegationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Delegation` at the end of the edge. */
  node: Delegation;
};

/** Methods to use when ordering `Delegation`. */
export type DelegationsOrderBy =
  | 'ACTIVE_AMOUNT_ASC'
  | 'ACTIVE_AMOUNT_DESC'
  | 'DELEGATOR_ID_SS58_ASC'
  | 'DELEGATOR_ID_SS58_DESC'
  | 'NATURAL'
  | 'OPERATOR_ID_SS58_ASC'
  | 'OPERATOR_ID_SS58_DESC'
  | 'UPCOMING_AMOUNT_ASC'
  | 'UPCOMING_AMOUNT_DESC';

export type DepositBalance = {
  __typename?: 'DepositBalance';
  amount: Scalars['BigFloat']['output'];
  asset: ChainflipAsset;
  boostBalance: Scalars['BigFloat']['output'];
  boostBalanceValueUsd: Scalars['BigFloat']['output'];
  chain: ChainflipChain;
  lendingCollateralBalance: Scalars['BigFloat']['output'];
  lendingCollateralBalanceValueUsd: Scalars['BigFloat']['output'];
  lendingSupplyBalance: Scalars['BigFloat']['output'];
  lendingSupplyBalanceValueUsd: Scalars['BigFloat']['output'];
  /** Reads a single `LpAccount` that is related to this `DepositBalance`. */
  lpAccountByLpIdSs58: LpAccount;
  lpIdSs58: Scalars['String']['output'];
  strategyBalance: Scalars['BigFloat']['output'];
  strategyBalanceValueUsd: Scalars['BigFloat']['output'];
  totalBalance: Scalars['BigFloat']['output'];
  totalBalanceValueUsd: Scalars['BigFloat']['output'];
  valueUsd: Scalars['BigFloat']['output'];
};

export type DepositBalanceAggregates = {
  __typename?: 'DepositBalanceAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<DepositBalanceAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<DepositBalanceDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<DepositBalanceMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<DepositBalanceMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<DepositBalanceStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<DepositBalanceStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<DepositBalanceSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<DepositBalanceVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<DepositBalanceVarianceSampleAggregates>;
};

/** A filter to be used against aggregates of `DepositBalance` object types. */
export type DepositBalanceAggregatesFilter = {
  /** Mean average aggregate over matching `DepositBalance` objects. */
  average?: InputMaybe<DepositBalanceAverageAggregateFilter>;
  /** Distinct count aggregate over matching `DepositBalance` objects. */
  distinctCount?: InputMaybe<DepositBalanceDistinctCountAggregateFilter>;
  /** A filter that must pass for the relevant `DepositBalance` object to be included within the aggregate. */
  filter?: InputMaybe<DepositBalanceFilter>;
  /** Maximum aggregate over matching `DepositBalance` objects. */
  max?: InputMaybe<DepositBalanceMaxAggregateFilter>;
  /** Minimum aggregate over matching `DepositBalance` objects. */
  min?: InputMaybe<DepositBalanceMinAggregateFilter>;
  /** Population standard deviation aggregate over matching `DepositBalance` objects. */
  stddevPopulation?: InputMaybe<DepositBalanceStddevPopulationAggregateFilter>;
  /** Sample standard deviation aggregate over matching `DepositBalance` objects. */
  stddevSample?: InputMaybe<DepositBalanceStddevSampleAggregateFilter>;
  /** Sum aggregate over matching `DepositBalance` objects. */
  sum?: InputMaybe<DepositBalanceSumAggregateFilter>;
  /** Population variance aggregate over matching `DepositBalance` objects. */
  variancePopulation?: InputMaybe<DepositBalanceVariancePopulationAggregateFilter>;
  /** Sample variance aggregate over matching `DepositBalance` objects. */
  varianceSample?: InputMaybe<DepositBalanceVarianceSampleAggregateFilter>;
};

export type DepositBalanceAverageAggregateFilter = {
  amount?: InputMaybe<BigFloatFilter>;
  boostBalance?: InputMaybe<BigFloatFilter>;
  boostBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  lendingCollateralBalance?: InputMaybe<BigFloatFilter>;
  lendingCollateralBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  lendingSupplyBalance?: InputMaybe<BigFloatFilter>;
  lendingSupplyBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  strategyBalance?: InputMaybe<BigFloatFilter>;
  strategyBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  totalBalance?: InputMaybe<BigFloatFilter>;
  totalBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  valueUsd?: InputMaybe<BigFloatFilter>;
};

export type DepositBalanceAverageAggregates = {
  __typename?: 'DepositBalanceAverageAggregates';
  /** Mean average of amount across the matching connection */
  amount?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of boostBalance across the matching connection */
  boostBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of boostBalanceValueUsd across the matching connection */
  boostBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of lendingCollateralBalance across the matching connection */
  lendingCollateralBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of lendingCollateralBalanceValueUsd across the matching connection */
  lendingCollateralBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of lendingSupplyBalance across the matching connection */
  lendingSupplyBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of lendingSupplyBalanceValueUsd across the matching connection */
  lendingSupplyBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of strategyBalance across the matching connection */
  strategyBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of strategyBalanceValueUsd across the matching connection */
  strategyBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of totalBalance across the matching connection */
  totalBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of totalBalanceValueUsd across the matching connection */
  totalBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of valueUsd across the matching connection */
  valueUsd?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `DepositBalance` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type DepositBalanceCondition = {
  /** Checks for equality with the object’s `amount` field. */
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `asset` field. */
  asset?: InputMaybe<ChainflipAsset>;
  /** Checks for equality with the object’s `boostBalance` field. */
  boostBalance?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `boostBalanceValueUsd` field. */
  boostBalanceValueUsd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `chain` field. */
  chain?: InputMaybe<ChainflipChain>;
  /** Checks for equality with the object’s `lendingCollateralBalance` field. */
  lendingCollateralBalance?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `lendingCollateralBalanceValueUsd` field. */
  lendingCollateralBalanceValueUsd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `lendingSupplyBalance` field. */
  lendingSupplyBalance?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `lendingSupplyBalanceValueUsd` field. */
  lendingSupplyBalanceValueUsd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `lpIdSs58` field. */
  lpIdSs58?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `strategyBalance` field. */
  strategyBalance?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `strategyBalanceValueUsd` field. */
  strategyBalanceValueUsd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalBalance` field. */
  totalBalance?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalBalanceValueUsd` field. */
  totalBalanceValueUsd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `valueUsd` field. */
  valueUsd?: InputMaybe<Scalars['BigFloat']['input']>;
};

export type DepositBalanceDistinctCountAggregateFilter = {
  amount?: InputMaybe<BigIntFilter>;
  asset?: InputMaybe<BigIntFilter>;
  boostBalance?: InputMaybe<BigIntFilter>;
  boostBalanceValueUsd?: InputMaybe<BigIntFilter>;
  chain?: InputMaybe<BigIntFilter>;
  lendingCollateralBalance?: InputMaybe<BigIntFilter>;
  lendingCollateralBalanceValueUsd?: InputMaybe<BigIntFilter>;
  lendingSupplyBalance?: InputMaybe<BigIntFilter>;
  lendingSupplyBalanceValueUsd?: InputMaybe<BigIntFilter>;
  lpIdSs58?: InputMaybe<BigIntFilter>;
  strategyBalance?: InputMaybe<BigIntFilter>;
  strategyBalanceValueUsd?: InputMaybe<BigIntFilter>;
  totalBalance?: InputMaybe<BigIntFilter>;
  totalBalanceValueUsd?: InputMaybe<BigIntFilter>;
  valueUsd?: InputMaybe<BigIntFilter>;
};

export type DepositBalanceDistinctCountAggregates = {
  __typename?: 'DepositBalanceDistinctCountAggregates';
  /** Distinct count of amount across the matching connection */
  amount?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of asset across the matching connection */
  asset?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of boostBalance across the matching connection */
  boostBalance?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of boostBalanceValueUsd across the matching connection */
  boostBalanceValueUsd?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of chain across the matching connection */
  chain?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of lendingCollateralBalance across the matching connection */
  lendingCollateralBalance?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of lendingCollateralBalanceValueUsd across the matching connection */
  lendingCollateralBalanceValueUsd?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of lendingSupplyBalance across the matching connection */
  lendingSupplyBalance?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of lendingSupplyBalanceValueUsd across the matching connection */
  lendingSupplyBalanceValueUsd?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of lpIdSs58 across the matching connection */
  lpIdSs58?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of strategyBalance across the matching connection */
  strategyBalance?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of strategyBalanceValueUsd across the matching connection */
  strategyBalanceValueUsd?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of totalBalance across the matching connection */
  totalBalance?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of totalBalanceValueUsd across the matching connection */
  totalBalanceValueUsd?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of valueUsd across the matching connection */
  valueUsd?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `DepositBalance` object types. All fields are combined with a logical ‘and.’ */
export type DepositBalanceFilter = {
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DepositBalanceFilter>>;
  /** Filter by the object’s `asset` field. */
  asset?: InputMaybe<ChainflipAssetFilter>;
  /** Filter by the object’s `boostBalance` field. */
  boostBalance?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `boostBalanceValueUsd` field. */
  boostBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `chain` field. */
  chain?: InputMaybe<ChainflipChainFilter>;
  /** Filter by the object’s `lendingCollateralBalance` field. */
  lendingCollateralBalance?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `lendingCollateralBalanceValueUsd` field. */
  lendingCollateralBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `lendingSupplyBalance` field. */
  lendingSupplyBalance?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `lendingSupplyBalanceValueUsd` field. */
  lendingSupplyBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `lpAccountByLpIdSs58` relation. */
  lpAccountByLpIdSs58?: InputMaybe<LpAccountFilter>;
  /** Filter by the object’s `lpIdSs58` field. */
  lpIdSs58?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DepositBalanceFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DepositBalanceFilter>>;
  /** Filter by the object’s `strategyBalance` field. */
  strategyBalance?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `strategyBalanceValueUsd` field. */
  strategyBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalBalance` field. */
  totalBalance?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalBalanceValueUsd` field. */
  totalBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `valueUsd` field. */
  valueUsd?: InputMaybe<BigFloatFilter>;
};

/** Grouping methods for `DepositBalance` for usage during aggregation. */
export type DepositBalanceGroupBy =
  | 'AMOUNT'
  | 'ASSET'
  | 'BOOST_BALANCE'
  | 'BOOST_BALANCE_VALUE_USD'
  | 'CHAIN'
  | 'LENDING_COLLATERAL_BALANCE'
  | 'LENDING_COLLATERAL_BALANCE_VALUE_USD'
  | 'LENDING_SUPPLY_BALANCE'
  | 'LENDING_SUPPLY_BALANCE_VALUE_USD'
  | 'LP_ID_SS58'
  | 'STRATEGY_BALANCE'
  | 'STRATEGY_BALANCE_VALUE_USD'
  | 'TOTAL_BALANCE'
  | 'TOTAL_BALANCE_VALUE_USD'
  | 'VALUE_USD';

export type DepositBalanceHavingAverageInput = {
  amount?: InputMaybe<HavingBigfloatFilter>;
  boostBalance?: InputMaybe<HavingBigfloatFilter>;
  boostBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  lendingCollateralBalance?: InputMaybe<HavingBigfloatFilter>;
  lendingCollateralBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  lendingSupplyBalance?: InputMaybe<HavingBigfloatFilter>;
  lendingSupplyBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  strategyBalance?: InputMaybe<HavingBigfloatFilter>;
  strategyBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  totalBalance?: InputMaybe<HavingBigfloatFilter>;
  totalBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  valueUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type DepositBalanceHavingDistinctCountInput = {
  amount?: InputMaybe<HavingBigfloatFilter>;
  boostBalance?: InputMaybe<HavingBigfloatFilter>;
  boostBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  lendingCollateralBalance?: InputMaybe<HavingBigfloatFilter>;
  lendingCollateralBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  lendingSupplyBalance?: InputMaybe<HavingBigfloatFilter>;
  lendingSupplyBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  strategyBalance?: InputMaybe<HavingBigfloatFilter>;
  strategyBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  totalBalance?: InputMaybe<HavingBigfloatFilter>;
  totalBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  valueUsd?: InputMaybe<HavingBigfloatFilter>;
};

/** Conditions for `DepositBalance` aggregates. */
export type DepositBalanceHavingInput = {
  AND?: InputMaybe<Array<DepositBalanceHavingInput>>;
  OR?: InputMaybe<Array<DepositBalanceHavingInput>>;
  average?: InputMaybe<DepositBalanceHavingAverageInput>;
  distinctCount?: InputMaybe<DepositBalanceHavingDistinctCountInput>;
  max?: InputMaybe<DepositBalanceHavingMaxInput>;
  min?: InputMaybe<DepositBalanceHavingMinInput>;
  stddevPopulation?: InputMaybe<DepositBalanceHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<DepositBalanceHavingStddevSampleInput>;
  sum?: InputMaybe<DepositBalanceHavingSumInput>;
  variancePopulation?: InputMaybe<DepositBalanceHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<DepositBalanceHavingVarianceSampleInput>;
};

export type DepositBalanceHavingMaxInput = {
  amount?: InputMaybe<HavingBigfloatFilter>;
  boostBalance?: InputMaybe<HavingBigfloatFilter>;
  boostBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  lendingCollateralBalance?: InputMaybe<HavingBigfloatFilter>;
  lendingCollateralBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  lendingSupplyBalance?: InputMaybe<HavingBigfloatFilter>;
  lendingSupplyBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  strategyBalance?: InputMaybe<HavingBigfloatFilter>;
  strategyBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  totalBalance?: InputMaybe<HavingBigfloatFilter>;
  totalBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  valueUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type DepositBalanceHavingMinInput = {
  amount?: InputMaybe<HavingBigfloatFilter>;
  boostBalance?: InputMaybe<HavingBigfloatFilter>;
  boostBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  lendingCollateralBalance?: InputMaybe<HavingBigfloatFilter>;
  lendingCollateralBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  lendingSupplyBalance?: InputMaybe<HavingBigfloatFilter>;
  lendingSupplyBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  strategyBalance?: InputMaybe<HavingBigfloatFilter>;
  strategyBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  totalBalance?: InputMaybe<HavingBigfloatFilter>;
  totalBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  valueUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type DepositBalanceHavingStddevPopulationInput = {
  amount?: InputMaybe<HavingBigfloatFilter>;
  boostBalance?: InputMaybe<HavingBigfloatFilter>;
  boostBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  lendingCollateralBalance?: InputMaybe<HavingBigfloatFilter>;
  lendingCollateralBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  lendingSupplyBalance?: InputMaybe<HavingBigfloatFilter>;
  lendingSupplyBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  strategyBalance?: InputMaybe<HavingBigfloatFilter>;
  strategyBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  totalBalance?: InputMaybe<HavingBigfloatFilter>;
  totalBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  valueUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type DepositBalanceHavingStddevSampleInput = {
  amount?: InputMaybe<HavingBigfloatFilter>;
  boostBalance?: InputMaybe<HavingBigfloatFilter>;
  boostBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  lendingCollateralBalance?: InputMaybe<HavingBigfloatFilter>;
  lendingCollateralBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  lendingSupplyBalance?: InputMaybe<HavingBigfloatFilter>;
  lendingSupplyBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  strategyBalance?: InputMaybe<HavingBigfloatFilter>;
  strategyBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  totalBalance?: InputMaybe<HavingBigfloatFilter>;
  totalBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  valueUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type DepositBalanceHavingSumInput = {
  amount?: InputMaybe<HavingBigfloatFilter>;
  boostBalance?: InputMaybe<HavingBigfloatFilter>;
  boostBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  lendingCollateralBalance?: InputMaybe<HavingBigfloatFilter>;
  lendingCollateralBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  lendingSupplyBalance?: InputMaybe<HavingBigfloatFilter>;
  lendingSupplyBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  strategyBalance?: InputMaybe<HavingBigfloatFilter>;
  strategyBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  totalBalance?: InputMaybe<HavingBigfloatFilter>;
  totalBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  valueUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type DepositBalanceHavingVariancePopulationInput = {
  amount?: InputMaybe<HavingBigfloatFilter>;
  boostBalance?: InputMaybe<HavingBigfloatFilter>;
  boostBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  lendingCollateralBalance?: InputMaybe<HavingBigfloatFilter>;
  lendingCollateralBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  lendingSupplyBalance?: InputMaybe<HavingBigfloatFilter>;
  lendingSupplyBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  strategyBalance?: InputMaybe<HavingBigfloatFilter>;
  strategyBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  totalBalance?: InputMaybe<HavingBigfloatFilter>;
  totalBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  valueUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type DepositBalanceHavingVarianceSampleInput = {
  amount?: InputMaybe<HavingBigfloatFilter>;
  boostBalance?: InputMaybe<HavingBigfloatFilter>;
  boostBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  lendingCollateralBalance?: InputMaybe<HavingBigfloatFilter>;
  lendingCollateralBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  lendingSupplyBalance?: InputMaybe<HavingBigfloatFilter>;
  lendingSupplyBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  strategyBalance?: InputMaybe<HavingBigfloatFilter>;
  strategyBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  totalBalance?: InputMaybe<HavingBigfloatFilter>;
  totalBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  valueUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type DepositBalanceMaxAggregateFilter = {
  amount?: InputMaybe<BigFloatFilter>;
  boostBalance?: InputMaybe<BigFloatFilter>;
  boostBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  lendingCollateralBalance?: InputMaybe<BigFloatFilter>;
  lendingCollateralBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  lendingSupplyBalance?: InputMaybe<BigFloatFilter>;
  lendingSupplyBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  strategyBalance?: InputMaybe<BigFloatFilter>;
  strategyBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  totalBalance?: InputMaybe<BigFloatFilter>;
  totalBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  valueUsd?: InputMaybe<BigFloatFilter>;
};

export type DepositBalanceMaxAggregates = {
  __typename?: 'DepositBalanceMaxAggregates';
  /** Maximum of amount across the matching connection */
  amount?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of boostBalance across the matching connection */
  boostBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of boostBalanceValueUsd across the matching connection */
  boostBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of lendingCollateralBalance across the matching connection */
  lendingCollateralBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of lendingCollateralBalanceValueUsd across the matching connection */
  lendingCollateralBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of lendingSupplyBalance across the matching connection */
  lendingSupplyBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of lendingSupplyBalanceValueUsd across the matching connection */
  lendingSupplyBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of strategyBalance across the matching connection */
  strategyBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of strategyBalanceValueUsd across the matching connection */
  strategyBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of totalBalance across the matching connection */
  totalBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of totalBalanceValueUsd across the matching connection */
  totalBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of valueUsd across the matching connection */
  valueUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type DepositBalanceMinAggregateFilter = {
  amount?: InputMaybe<BigFloatFilter>;
  boostBalance?: InputMaybe<BigFloatFilter>;
  boostBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  lendingCollateralBalance?: InputMaybe<BigFloatFilter>;
  lendingCollateralBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  lendingSupplyBalance?: InputMaybe<BigFloatFilter>;
  lendingSupplyBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  strategyBalance?: InputMaybe<BigFloatFilter>;
  strategyBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  totalBalance?: InputMaybe<BigFloatFilter>;
  totalBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  valueUsd?: InputMaybe<BigFloatFilter>;
};

export type DepositBalanceMinAggregates = {
  __typename?: 'DepositBalanceMinAggregates';
  /** Minimum of amount across the matching connection */
  amount?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of boostBalance across the matching connection */
  boostBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of boostBalanceValueUsd across the matching connection */
  boostBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of lendingCollateralBalance across the matching connection */
  lendingCollateralBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of lendingCollateralBalanceValueUsd across the matching connection */
  lendingCollateralBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of lendingSupplyBalance across the matching connection */
  lendingSupplyBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of lendingSupplyBalanceValueUsd across the matching connection */
  lendingSupplyBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of strategyBalance across the matching connection */
  strategyBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of strategyBalanceValueUsd across the matching connection */
  strategyBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of totalBalance across the matching connection */
  totalBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of totalBalanceValueUsd across the matching connection */
  totalBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of valueUsd across the matching connection */
  valueUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type DepositBalanceStddevPopulationAggregateFilter = {
  amount?: InputMaybe<BigFloatFilter>;
  boostBalance?: InputMaybe<BigFloatFilter>;
  boostBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  lendingCollateralBalance?: InputMaybe<BigFloatFilter>;
  lendingCollateralBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  lendingSupplyBalance?: InputMaybe<BigFloatFilter>;
  lendingSupplyBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  strategyBalance?: InputMaybe<BigFloatFilter>;
  strategyBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  totalBalance?: InputMaybe<BigFloatFilter>;
  totalBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  valueUsd?: InputMaybe<BigFloatFilter>;
};

export type DepositBalanceStddevPopulationAggregates = {
  __typename?: 'DepositBalanceStddevPopulationAggregates';
  /** Population standard deviation of amount across the matching connection */
  amount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of boostBalance across the matching connection */
  boostBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of boostBalanceValueUsd across the matching connection */
  boostBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of lendingCollateralBalance across the matching connection */
  lendingCollateralBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of lendingCollateralBalanceValueUsd across the matching connection */
  lendingCollateralBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of lendingSupplyBalance across the matching connection */
  lendingSupplyBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of lendingSupplyBalanceValueUsd across the matching connection */
  lendingSupplyBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of strategyBalance across the matching connection */
  strategyBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of strategyBalanceValueUsd across the matching connection */
  strategyBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of totalBalance across the matching connection */
  totalBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of totalBalanceValueUsd across the matching connection */
  totalBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of valueUsd across the matching connection */
  valueUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type DepositBalanceStddevSampleAggregateFilter = {
  amount?: InputMaybe<BigFloatFilter>;
  boostBalance?: InputMaybe<BigFloatFilter>;
  boostBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  lendingCollateralBalance?: InputMaybe<BigFloatFilter>;
  lendingCollateralBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  lendingSupplyBalance?: InputMaybe<BigFloatFilter>;
  lendingSupplyBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  strategyBalance?: InputMaybe<BigFloatFilter>;
  strategyBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  totalBalance?: InputMaybe<BigFloatFilter>;
  totalBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  valueUsd?: InputMaybe<BigFloatFilter>;
};

export type DepositBalanceStddevSampleAggregates = {
  __typename?: 'DepositBalanceStddevSampleAggregates';
  /** Sample standard deviation of amount across the matching connection */
  amount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of boostBalance across the matching connection */
  boostBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of boostBalanceValueUsd across the matching connection */
  boostBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of lendingCollateralBalance across the matching connection */
  lendingCollateralBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of lendingCollateralBalanceValueUsd across the matching connection */
  lendingCollateralBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of lendingSupplyBalance across the matching connection */
  lendingSupplyBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of lendingSupplyBalanceValueUsd across the matching connection */
  lendingSupplyBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of strategyBalance across the matching connection */
  strategyBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of strategyBalanceValueUsd across the matching connection */
  strategyBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of totalBalance across the matching connection */
  totalBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of totalBalanceValueUsd across the matching connection */
  totalBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of valueUsd across the matching connection */
  valueUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type DepositBalanceSumAggregateFilter = {
  amount?: InputMaybe<BigFloatFilter>;
  boostBalance?: InputMaybe<BigFloatFilter>;
  boostBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  lendingCollateralBalance?: InputMaybe<BigFloatFilter>;
  lendingCollateralBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  lendingSupplyBalance?: InputMaybe<BigFloatFilter>;
  lendingSupplyBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  strategyBalance?: InputMaybe<BigFloatFilter>;
  strategyBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  totalBalance?: InputMaybe<BigFloatFilter>;
  totalBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  valueUsd?: InputMaybe<BigFloatFilter>;
};

export type DepositBalanceSumAggregates = {
  __typename?: 'DepositBalanceSumAggregates';
  /** Sum of amount across the matching connection */
  amount: Scalars['BigFloat']['output'];
  /** Sum of boostBalance across the matching connection */
  boostBalance: Scalars['BigFloat']['output'];
  /** Sum of boostBalanceValueUsd across the matching connection */
  boostBalanceValueUsd: Scalars['BigFloat']['output'];
  /** Sum of lendingCollateralBalance across the matching connection */
  lendingCollateralBalance: Scalars['BigFloat']['output'];
  /** Sum of lendingCollateralBalanceValueUsd across the matching connection */
  lendingCollateralBalanceValueUsd: Scalars['BigFloat']['output'];
  /** Sum of lendingSupplyBalance across the matching connection */
  lendingSupplyBalance: Scalars['BigFloat']['output'];
  /** Sum of lendingSupplyBalanceValueUsd across the matching connection */
  lendingSupplyBalanceValueUsd: Scalars['BigFloat']['output'];
  /** Sum of strategyBalance across the matching connection */
  strategyBalance: Scalars['BigFloat']['output'];
  /** Sum of strategyBalanceValueUsd across the matching connection */
  strategyBalanceValueUsd: Scalars['BigFloat']['output'];
  /** Sum of totalBalance across the matching connection */
  totalBalance: Scalars['BigFloat']['output'];
  /** Sum of totalBalanceValueUsd across the matching connection */
  totalBalanceValueUsd: Scalars['BigFloat']['output'];
  /** Sum of valueUsd across the matching connection */
  valueUsd: Scalars['BigFloat']['output'];
};

export type DepositBalanceVariancePopulationAggregateFilter = {
  amount?: InputMaybe<BigFloatFilter>;
  boostBalance?: InputMaybe<BigFloatFilter>;
  boostBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  lendingCollateralBalance?: InputMaybe<BigFloatFilter>;
  lendingCollateralBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  lendingSupplyBalance?: InputMaybe<BigFloatFilter>;
  lendingSupplyBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  strategyBalance?: InputMaybe<BigFloatFilter>;
  strategyBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  totalBalance?: InputMaybe<BigFloatFilter>;
  totalBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  valueUsd?: InputMaybe<BigFloatFilter>;
};

export type DepositBalanceVariancePopulationAggregates = {
  __typename?: 'DepositBalanceVariancePopulationAggregates';
  /** Population variance of amount across the matching connection */
  amount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of boostBalance across the matching connection */
  boostBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of boostBalanceValueUsd across the matching connection */
  boostBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of lendingCollateralBalance across the matching connection */
  lendingCollateralBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of lendingCollateralBalanceValueUsd across the matching connection */
  lendingCollateralBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of lendingSupplyBalance across the matching connection */
  lendingSupplyBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of lendingSupplyBalanceValueUsd across the matching connection */
  lendingSupplyBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of strategyBalance across the matching connection */
  strategyBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of strategyBalanceValueUsd across the matching connection */
  strategyBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of totalBalance across the matching connection */
  totalBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of totalBalanceValueUsd across the matching connection */
  totalBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of valueUsd across the matching connection */
  valueUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type DepositBalanceVarianceSampleAggregateFilter = {
  amount?: InputMaybe<BigFloatFilter>;
  boostBalance?: InputMaybe<BigFloatFilter>;
  boostBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  lendingCollateralBalance?: InputMaybe<BigFloatFilter>;
  lendingCollateralBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  lendingSupplyBalance?: InputMaybe<BigFloatFilter>;
  lendingSupplyBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  strategyBalance?: InputMaybe<BigFloatFilter>;
  strategyBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  totalBalance?: InputMaybe<BigFloatFilter>;
  totalBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  valueUsd?: InputMaybe<BigFloatFilter>;
};

export type DepositBalanceVarianceSampleAggregates = {
  __typename?: 'DepositBalanceVarianceSampleAggregates';
  /** Sample variance of amount across the matching connection */
  amount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of boostBalance across the matching connection */
  boostBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of boostBalanceValueUsd across the matching connection */
  boostBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of lendingCollateralBalance across the matching connection */
  lendingCollateralBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of lendingCollateralBalanceValueUsd across the matching connection */
  lendingCollateralBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of lendingSupplyBalance across the matching connection */
  lendingSupplyBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of lendingSupplyBalanceValueUsd across the matching connection */
  lendingSupplyBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of strategyBalance across the matching connection */
  strategyBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of strategyBalanceValueUsd across the matching connection */
  strategyBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of totalBalance across the matching connection */
  totalBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of totalBalanceValueUsd across the matching connection */
  totalBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of valueUsd across the matching connection */
  valueUsd?: Maybe<Scalars['BigFloat']['output']>;
};

/** A connection to a list of `DepositBalance` values. */
export type DepositBalancesConnection = {
  __typename?: 'DepositBalancesConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<DepositBalanceAggregates>;
  /** A list of edges which contains the `DepositBalance` and cursor to aid in pagination. */
  edges: Array<DepositBalancesEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<DepositBalanceAggregates>>;
  /** A list of `DepositBalance` objects. */
  nodes: Array<DepositBalance>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DepositBalance` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `DepositBalance` values. */
export type DepositBalancesConnectionGroupedAggregatesArgs = {
  groupBy: Array<DepositBalanceGroupBy>;
  having?: InputMaybe<DepositBalanceHavingInput>;
};

/** A `DepositBalance` edge in the connection. */
export type DepositBalancesEdge = {
  __typename?: 'DepositBalancesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DepositBalance` at the end of the edge. */
  node: DepositBalance;
};

/** Methods to use when ordering `DepositBalance`. */
export type DepositBalancesOrderBy =
  | 'AMOUNT_ASC'
  | 'AMOUNT_DESC'
  | 'ASSET_ASC'
  | 'ASSET_DESC'
  | 'BOOST_BALANCE_ASC'
  | 'BOOST_BALANCE_DESC'
  | 'BOOST_BALANCE_VALUE_USD_ASC'
  | 'BOOST_BALANCE_VALUE_USD_DESC'
  | 'CHAIN_ASC'
  | 'CHAIN_DESC'
  | 'LENDING_COLLATERAL_BALANCE_ASC'
  | 'LENDING_COLLATERAL_BALANCE_DESC'
  | 'LENDING_COLLATERAL_BALANCE_VALUE_USD_ASC'
  | 'LENDING_COLLATERAL_BALANCE_VALUE_USD_DESC'
  | 'LENDING_SUPPLY_BALANCE_ASC'
  | 'LENDING_SUPPLY_BALANCE_DESC'
  | 'LENDING_SUPPLY_BALANCE_VALUE_USD_ASC'
  | 'LENDING_SUPPLY_BALANCE_VALUE_USD_DESC'
  | 'LP_ID_SS58_ASC'
  | 'LP_ID_SS58_DESC'
  | 'NATURAL'
  | 'STRATEGY_BALANCE_ASC'
  | 'STRATEGY_BALANCE_DESC'
  | 'STRATEGY_BALANCE_VALUE_USD_ASC'
  | 'STRATEGY_BALANCE_VALUE_USD_DESC'
  | 'TOTAL_BALANCE_ASC'
  | 'TOTAL_BALANCE_DESC'
  | 'TOTAL_BALANCE_VALUE_USD_ASC'
  | 'TOTAL_BALANCE_VALUE_USD_DESC'
  | 'VALUE_USD_ASC'
  | 'VALUE_USD_DESC';

export type EnvironmentAddress = Node & {
  __typename?: 'EnvironmentAddress';
  id: Scalars['Int']['output'];
  keyManagerAddress: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  redemptionTax: Scalars['BigFloat']['output'];
  runtimeVersion: Scalars['Int']['output'];
  stateChainGatewayAddress: Scalars['String']['output'];
};

export type EnvironmentAddressAggregates = {
  __typename?: 'EnvironmentAddressAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<EnvironmentAddressAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<EnvironmentAddressDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<EnvironmentAddressMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<EnvironmentAddressMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<EnvironmentAddressStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<EnvironmentAddressStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<EnvironmentAddressSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<EnvironmentAddressVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<EnvironmentAddressVarianceSampleAggregates>;
};

export type EnvironmentAddressAverageAggregates = {
  __typename?: 'EnvironmentAddressAverageAggregates';
  /** Mean average of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of redemptionTax across the matching connection */
  redemptionTax?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of runtimeVersion across the matching connection */
  runtimeVersion?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `EnvironmentAddress` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type EnvironmentAddressCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `keyManagerAddress` field. */
  keyManagerAddress?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `redemptionTax` field. */
  redemptionTax?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `runtimeVersion` field. */
  runtimeVersion?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `stateChainGatewayAddress` field. */
  stateChainGatewayAddress?: InputMaybe<Scalars['String']['input']>;
};

export type EnvironmentAddressDistinctCountAggregates = {
  __typename?: 'EnvironmentAddressDistinctCountAggregates';
  /** Distinct count of id across the matching connection */
  id?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of keyManagerAddress across the matching connection */
  keyManagerAddress?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of redemptionTax across the matching connection */
  redemptionTax?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of runtimeVersion across the matching connection */
  runtimeVersion?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of stateChainGatewayAddress across the matching connection */
  stateChainGatewayAddress?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `EnvironmentAddress` object types. All fields are combined with a logical ‘and.’ */
export type EnvironmentAddressFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<EnvironmentAddressFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `keyManagerAddress` field. */
  keyManagerAddress?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<EnvironmentAddressFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<EnvironmentAddressFilter>>;
  /** Filter by the object’s `redemptionTax` field. */
  redemptionTax?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `runtimeVersion` field. */
  runtimeVersion?: InputMaybe<IntFilter>;
  /** Filter by the object’s `stateChainGatewayAddress` field. */
  stateChainGatewayAddress?: InputMaybe<StringFilter>;
};

/** Grouping methods for `EnvironmentAddress` for usage during aggregation. */
export type EnvironmentAddressGroupBy =
  | 'KEY_MANAGER_ADDRESS'
  | 'REDEMPTION_TAX'
  | 'RUNTIME_VERSION'
  | 'STATE_CHAIN_GATEWAY_ADDRESS';

export type EnvironmentAddressHavingAverageInput = {
  id?: InputMaybe<HavingIntFilter>;
  redemptionTax?: InputMaybe<HavingBigfloatFilter>;
  runtimeVersion?: InputMaybe<HavingIntFilter>;
};

export type EnvironmentAddressHavingDistinctCountInput = {
  id?: InputMaybe<HavingIntFilter>;
  redemptionTax?: InputMaybe<HavingBigfloatFilter>;
  runtimeVersion?: InputMaybe<HavingIntFilter>;
};

/** Conditions for `EnvironmentAddress` aggregates. */
export type EnvironmentAddressHavingInput = {
  AND?: InputMaybe<Array<EnvironmentAddressHavingInput>>;
  OR?: InputMaybe<Array<EnvironmentAddressHavingInput>>;
  average?: InputMaybe<EnvironmentAddressHavingAverageInput>;
  distinctCount?: InputMaybe<EnvironmentAddressHavingDistinctCountInput>;
  max?: InputMaybe<EnvironmentAddressHavingMaxInput>;
  min?: InputMaybe<EnvironmentAddressHavingMinInput>;
  stddevPopulation?: InputMaybe<EnvironmentAddressHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<EnvironmentAddressHavingStddevSampleInput>;
  sum?: InputMaybe<EnvironmentAddressHavingSumInput>;
  variancePopulation?: InputMaybe<EnvironmentAddressHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<EnvironmentAddressHavingVarianceSampleInput>;
};

export type EnvironmentAddressHavingMaxInput = {
  id?: InputMaybe<HavingIntFilter>;
  redemptionTax?: InputMaybe<HavingBigfloatFilter>;
  runtimeVersion?: InputMaybe<HavingIntFilter>;
};

export type EnvironmentAddressHavingMinInput = {
  id?: InputMaybe<HavingIntFilter>;
  redemptionTax?: InputMaybe<HavingBigfloatFilter>;
  runtimeVersion?: InputMaybe<HavingIntFilter>;
};

export type EnvironmentAddressHavingStddevPopulationInput = {
  id?: InputMaybe<HavingIntFilter>;
  redemptionTax?: InputMaybe<HavingBigfloatFilter>;
  runtimeVersion?: InputMaybe<HavingIntFilter>;
};

export type EnvironmentAddressHavingStddevSampleInput = {
  id?: InputMaybe<HavingIntFilter>;
  redemptionTax?: InputMaybe<HavingBigfloatFilter>;
  runtimeVersion?: InputMaybe<HavingIntFilter>;
};

export type EnvironmentAddressHavingSumInput = {
  id?: InputMaybe<HavingIntFilter>;
  redemptionTax?: InputMaybe<HavingBigfloatFilter>;
  runtimeVersion?: InputMaybe<HavingIntFilter>;
};

export type EnvironmentAddressHavingVariancePopulationInput = {
  id?: InputMaybe<HavingIntFilter>;
  redemptionTax?: InputMaybe<HavingBigfloatFilter>;
  runtimeVersion?: InputMaybe<HavingIntFilter>;
};

export type EnvironmentAddressHavingVarianceSampleInput = {
  id?: InputMaybe<HavingIntFilter>;
  redemptionTax?: InputMaybe<HavingBigfloatFilter>;
  runtimeVersion?: InputMaybe<HavingIntFilter>;
};

export type EnvironmentAddressMaxAggregates = {
  __typename?: 'EnvironmentAddressMaxAggregates';
  /** Maximum of id across the matching connection */
  id?: Maybe<Scalars['Int']['output']>;
  /** Maximum of redemptionTax across the matching connection */
  redemptionTax?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of runtimeVersion across the matching connection */
  runtimeVersion?: Maybe<Scalars['Int']['output']>;
};

export type EnvironmentAddressMinAggregates = {
  __typename?: 'EnvironmentAddressMinAggregates';
  /** Minimum of id across the matching connection */
  id?: Maybe<Scalars['Int']['output']>;
  /** Minimum of redemptionTax across the matching connection */
  redemptionTax?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of runtimeVersion across the matching connection */
  runtimeVersion?: Maybe<Scalars['Int']['output']>;
};

export type EnvironmentAddressStddevPopulationAggregates = {
  __typename?: 'EnvironmentAddressStddevPopulationAggregates';
  /** Population standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of redemptionTax across the matching connection */
  redemptionTax?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of runtimeVersion across the matching connection */
  runtimeVersion?: Maybe<Scalars['BigFloat']['output']>;
};

export type EnvironmentAddressStddevSampleAggregates = {
  __typename?: 'EnvironmentAddressStddevSampleAggregates';
  /** Sample standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of redemptionTax across the matching connection */
  redemptionTax?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of runtimeVersion across the matching connection */
  runtimeVersion?: Maybe<Scalars['BigFloat']['output']>;
};

export type EnvironmentAddressSumAggregates = {
  __typename?: 'EnvironmentAddressSumAggregates';
  /** Sum of id across the matching connection */
  id: Scalars['BigInt']['output'];
  /** Sum of redemptionTax across the matching connection */
  redemptionTax: Scalars['BigFloat']['output'];
  /** Sum of runtimeVersion across the matching connection */
  runtimeVersion: Scalars['BigInt']['output'];
};

export type EnvironmentAddressVariancePopulationAggregates = {
  __typename?: 'EnvironmentAddressVariancePopulationAggregates';
  /** Population variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of redemptionTax across the matching connection */
  redemptionTax?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of runtimeVersion across the matching connection */
  runtimeVersion?: Maybe<Scalars['BigFloat']['output']>;
};

export type EnvironmentAddressVarianceSampleAggregates = {
  __typename?: 'EnvironmentAddressVarianceSampleAggregates';
  /** Sample variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of redemptionTax across the matching connection */
  redemptionTax?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of runtimeVersion across the matching connection */
  runtimeVersion?: Maybe<Scalars['BigFloat']['output']>;
};

/** A connection to a list of `EnvironmentAddress` values. */
export type EnvironmentAddressesConnection = {
  __typename?: 'EnvironmentAddressesConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<EnvironmentAddressAggregates>;
  /** A list of edges which contains the `EnvironmentAddress` and cursor to aid in pagination. */
  edges: Array<EnvironmentAddressesEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<EnvironmentAddressAggregates>>;
  /** A list of `EnvironmentAddress` objects. */
  nodes: Array<EnvironmentAddress>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `EnvironmentAddress` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `EnvironmentAddress` values. */
export type EnvironmentAddressesConnectionGroupedAggregatesArgs = {
  groupBy: Array<EnvironmentAddressGroupBy>;
  having?: InputMaybe<EnvironmentAddressHavingInput>;
};

/** A `EnvironmentAddress` edge in the connection. */
export type EnvironmentAddressesEdge = {
  __typename?: 'EnvironmentAddressesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `EnvironmentAddress` at the end of the edge. */
  node: EnvironmentAddress;
};

/** Methods to use when ordering `EnvironmentAddress`. */
export type EnvironmentAddressesOrderBy =
  | 'ID_ASC'
  | 'ID_DESC'
  | 'KEY_MANAGER_ADDRESS_ASC'
  | 'KEY_MANAGER_ADDRESS_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'REDEMPTION_TAX_ASC'
  | 'REDEMPTION_TAX_DESC'
  | 'RUNTIME_VERSION_ASC'
  | 'RUNTIME_VERSION_DESC'
  | 'STATE_CHAIN_GATEWAY_ADDRESS_ASC'
  | 'STATE_CHAIN_GATEWAY_ADDRESS_DESC';

export type Event = Node & {
  __typename?: 'Event';
  /** Reads a single `AcalaEvmExecuted` that is related to this `Event`. */
  acalaEvmExecutedByEventId?: Maybe<AcalaEvmExecuted>;
  /** Reads a single `AcalaEvmExecutedFailed` that is related to this `Event`. */
  acalaEvmExecutedFailedByEventId?: Maybe<AcalaEvmExecutedFailed>;
  /** Reads and enables pagination through a set of `AcalaEvmExecutedFailedLog`. */
  acalaEvmExecutedFailedLogsByEventId: AcalaEvmExecutedFailedLogsConnection;
  /**
   * Reads and enables pagination through a set of `AcalaEvmExecutedFailed`.
   * @deprecated Please use acalaEvmExecutedFailedByEventId instead
   */
  acalaEvmExecutedFailedsByEventId: AcalaEvmExecutedFailedsConnection;
  /** Reads and enables pagination through a set of `AcalaEvmExecutedLog`. */
  acalaEvmExecutedLogsByEventId: AcalaEvmExecutedLogsConnection;
  /**
   * Reads and enables pagination through a set of `AcalaEvmExecuted`.
   * @deprecated Please use acalaEvmExecutedByEventId instead
   */
  acalaEvmExecutedsByEventId: AcalaEvmExecutedsConnection;
  args?: Maybe<Scalars['JSON']['output']>;
  /** Reads a single `Block` that is related to this `Event`. */
  blockByBlockId: Block;
  blockId: Scalars['String']['output'];
  /** Reads a single `Call` that is related to this `Event`. */
  callByCallId?: Maybe<Call>;
  callId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `ContractsContractEmitted` that is related to this `Event`. */
  contractsContractEmittedByEventId?: Maybe<ContractsContractEmitted>;
  /**
   * Reads and enables pagination through a set of `ContractsContractEmitted`.
   * @deprecated Please use contractsContractEmittedByEventId instead
   */
  contractsContractEmittedsByEventId: ContractsContractEmittedsConnection;
  /** Reads a single `Extrinsic` that is related to this `Event`. */
  extrinsicByExtrinsicId?: Maybe<Extrinsic>;
  extrinsicId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `FrontierEvmLog` that is related to this `Event`. */
  frontierEvmLogByEventId?: Maybe<FrontierEvmLog>;
  /**
   * Reads and enables pagination through a set of `FrontierEvmLog`.
   * @deprecated Please use frontierEvmLogByEventId instead
   */
  frontierEvmLogsByEventId: FrontierEvmLogsConnection;
  /** Reads a single `GearMessageEnqueued` that is related to this `Event`. */
  gearMessageEnqueuedByEventId?: Maybe<GearMessageEnqueued>;
  /**
   * Reads and enables pagination through a set of `GearMessageEnqueued`.
   * @deprecated Please use gearMessageEnqueuedByEventId instead
   */
  gearMessageEnqueuedsByEventId: GearMessageEnqueuedsConnection;
  /** Reads a single `GearUserMessageSent` that is related to this `Event`. */
  gearUserMessageSentByEventId?: Maybe<GearUserMessageSent>;
  /**
   * Reads and enables pagination through a set of `GearUserMessageSent`.
   * @deprecated Please use gearUserMessageSentByEventId instead
   */
  gearUserMessageSentsByEventId: GearUserMessageSentsConnection;
  id: Scalars['String']['output'];
  indexInBlock: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  phase: Scalars['String']['output'];
  pos: Scalars['Int']['output'];
};


export type EventAcalaEvmExecutedFailedLogsByEventIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AcalaEvmExecutedFailedLogCondition>;
  filter?: InputMaybe<AcalaEvmExecutedFailedLogFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AcalaEvmExecutedFailedLogsOrderBy>>;
};


export type EventAcalaEvmExecutedFailedsByEventIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AcalaEvmExecutedFailedCondition>;
  filter?: InputMaybe<AcalaEvmExecutedFailedFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AcalaEvmExecutedFailedsOrderBy>>;
};


export type EventAcalaEvmExecutedLogsByEventIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AcalaEvmExecutedLogCondition>;
  filter?: InputMaybe<AcalaEvmExecutedLogFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AcalaEvmExecutedLogsOrderBy>>;
};


export type EventAcalaEvmExecutedsByEventIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AcalaEvmExecutedCondition>;
  filter?: InputMaybe<AcalaEvmExecutedFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AcalaEvmExecutedsOrderBy>>;
};


export type EventContractsContractEmittedsByEventIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ContractsContractEmittedCondition>;
  filter?: InputMaybe<ContractsContractEmittedFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ContractsContractEmittedsOrderBy>>;
};


export type EventFrontierEvmLogsByEventIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FrontierEvmLogCondition>;
  filter?: InputMaybe<FrontierEvmLogFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FrontierEvmLogsOrderBy>>;
};


export type EventGearMessageEnqueuedsByEventIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GearMessageEnqueuedCondition>;
  filter?: InputMaybe<GearMessageEnqueuedFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GearMessageEnqueuedsOrderBy>>;
};


export type EventGearUserMessageSentsByEventIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GearUserMessageSentCondition>;
  filter?: InputMaybe<GearUserMessageSentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GearUserMessageSentsOrderBy>>;
};

export type EventAggregates = {
  __typename?: 'EventAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<EventAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<EventDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<EventMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<EventMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<EventStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<EventStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<EventSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<EventVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<EventVarianceSampleAggregates>;
};

export type EventAverageAggregates = {
  __typename?: 'EventAverageAggregates';
  /** Mean average of indexInBlock across the matching connection */
  indexInBlock?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of pos across the matching connection */
  pos?: Maybe<Scalars['BigFloat']['output']>;
};

/** A condition to be used against `Event` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type EventCondition = {
  /** Checks for equality with the object’s `args` field. */
  args?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `blockId` field. */
  blockId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `callId` field. */
  callId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `extrinsicId` field. */
  extrinsicId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `indexInBlock` field. */
  indexInBlock?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `phase` field. */
  phase?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `pos` field. */
  pos?: InputMaybe<Scalars['Int']['input']>;
};

export type EventDistinctCountAggregates = {
  __typename?: 'EventDistinctCountAggregates';
  /** Distinct count of args across the matching connection */
  args?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of blockId across the matching connection */
  blockId?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of callId across the matching connection */
  callId?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of extrinsicId across the matching connection */
  extrinsicId?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of id across the matching connection */
  id?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of indexInBlock across the matching connection */
  indexInBlock?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of name across the matching connection */
  name?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of phase across the matching connection */
  phase?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of pos across the matching connection */
  pos?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `Event` object types. All fields are combined with a logical ‘and.’ */
export type EventFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<EventFilter>>;
  /** Filter by the object’s `args` field. */
  args?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `blockId` field. */
  blockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `callId` field. */
  callId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `extrinsicId` field. */
  extrinsicId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `indexInBlock` field. */
  indexInBlock?: InputMaybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<EventFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<EventFilter>>;
  /** Filter by the object’s `phase` field. */
  phase?: InputMaybe<StringFilter>;
  /** Filter by the object’s `pos` field. */
  pos?: InputMaybe<IntFilter>;
};

/** Grouping methods for `Event` for usage during aggregation. */
export type EventGroupBy =
  | 'ARGS'
  | 'BLOCK_ID'
  | 'CALL_ID'
  | 'EXTRINSIC_ID'
  | 'INDEX_IN_BLOCK'
  | 'NAME'
  | 'PHASE'
  | 'POS';

export type EventHavingAverageInput = {
  indexInBlock?: InputMaybe<HavingIntFilter>;
  pos?: InputMaybe<HavingIntFilter>;
};

export type EventHavingDistinctCountInput = {
  indexInBlock?: InputMaybe<HavingIntFilter>;
  pos?: InputMaybe<HavingIntFilter>;
};

/** Conditions for `Event` aggregates. */
export type EventHavingInput = {
  AND?: InputMaybe<Array<EventHavingInput>>;
  OR?: InputMaybe<Array<EventHavingInput>>;
  average?: InputMaybe<EventHavingAverageInput>;
  distinctCount?: InputMaybe<EventHavingDistinctCountInput>;
  max?: InputMaybe<EventHavingMaxInput>;
  min?: InputMaybe<EventHavingMinInput>;
  stddevPopulation?: InputMaybe<EventHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<EventHavingStddevSampleInput>;
  sum?: InputMaybe<EventHavingSumInput>;
  variancePopulation?: InputMaybe<EventHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<EventHavingVarianceSampleInput>;
};

export type EventHavingMaxInput = {
  indexInBlock?: InputMaybe<HavingIntFilter>;
  pos?: InputMaybe<HavingIntFilter>;
};

export type EventHavingMinInput = {
  indexInBlock?: InputMaybe<HavingIntFilter>;
  pos?: InputMaybe<HavingIntFilter>;
};

export type EventHavingStddevPopulationInput = {
  indexInBlock?: InputMaybe<HavingIntFilter>;
  pos?: InputMaybe<HavingIntFilter>;
};

export type EventHavingStddevSampleInput = {
  indexInBlock?: InputMaybe<HavingIntFilter>;
  pos?: InputMaybe<HavingIntFilter>;
};

export type EventHavingSumInput = {
  indexInBlock?: InputMaybe<HavingIntFilter>;
  pos?: InputMaybe<HavingIntFilter>;
};

export type EventHavingVariancePopulationInput = {
  indexInBlock?: InputMaybe<HavingIntFilter>;
  pos?: InputMaybe<HavingIntFilter>;
};

export type EventHavingVarianceSampleInput = {
  indexInBlock?: InputMaybe<HavingIntFilter>;
  pos?: InputMaybe<HavingIntFilter>;
};

export type EventMaxAggregates = {
  __typename?: 'EventMaxAggregates';
  /** Maximum of indexInBlock across the matching connection */
  indexInBlock?: Maybe<Scalars['Int']['output']>;
  /** Maximum of pos across the matching connection */
  pos?: Maybe<Scalars['Int']['output']>;
};

export type EventMinAggregates = {
  __typename?: 'EventMinAggregates';
  /** Minimum of indexInBlock across the matching connection */
  indexInBlock?: Maybe<Scalars['Int']['output']>;
  /** Minimum of pos across the matching connection */
  pos?: Maybe<Scalars['Int']['output']>;
};

export type EventStddevPopulationAggregates = {
  __typename?: 'EventStddevPopulationAggregates';
  /** Population standard deviation of indexInBlock across the matching connection */
  indexInBlock?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of pos across the matching connection */
  pos?: Maybe<Scalars['BigFloat']['output']>;
};

export type EventStddevSampleAggregates = {
  __typename?: 'EventStddevSampleAggregates';
  /** Sample standard deviation of indexInBlock across the matching connection */
  indexInBlock?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of pos across the matching connection */
  pos?: Maybe<Scalars['BigFloat']['output']>;
};

export type EventSumAggregates = {
  __typename?: 'EventSumAggregates';
  /** Sum of indexInBlock across the matching connection */
  indexInBlock: Scalars['BigInt']['output'];
  /** Sum of pos across the matching connection */
  pos: Scalars['BigInt']['output'];
};

export type EventVariancePopulationAggregates = {
  __typename?: 'EventVariancePopulationAggregates';
  /** Population variance of indexInBlock across the matching connection */
  indexInBlock?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of pos across the matching connection */
  pos?: Maybe<Scalars['BigFloat']['output']>;
};

export type EventVarianceSampleAggregates = {
  __typename?: 'EventVarianceSampleAggregates';
  /** Sample variance of indexInBlock across the matching connection */
  indexInBlock?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of pos across the matching connection */
  pos?: Maybe<Scalars['BigFloat']['output']>;
};

/** A connection to a list of `Event` values. */
export type EventsConnection = {
  __typename?: 'EventsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<EventAggregates>;
  /** A list of edges which contains the `Event` and cursor to aid in pagination. */
  edges: Array<EventsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<EventAggregates>>;
  /** A list of `Event` objects. */
  nodes: Array<Event>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Event` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `Event` values. */
export type EventsConnectionGroupedAggregatesArgs = {
  groupBy: Array<EventGroupBy>;
  having?: InputMaybe<EventHavingInput>;
};

/** A `Event` edge in the connection. */
export type EventsEdge = {
  __typename?: 'EventsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Event` at the end of the edge. */
  node: Event;
};

/** Methods to use when ordering `Event`. */
export type EventsOrderBy =
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_AVERAGE_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_AVERAGE_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_AVERAGE_EVENT_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_AVERAGE_EVENT_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_AVERAGE_EVENT_ID_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_AVERAGE_EVENT_ID_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_AVERAGE_ID_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_AVERAGE_ID_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_AVERAGE_TOPIC0_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_AVERAGE_TOPIC0_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_AVERAGE_TOPIC1_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_AVERAGE_TOPIC1_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_AVERAGE_TOPIC2_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_AVERAGE_TOPIC2_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_AVERAGE_TOPIC3_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_AVERAGE_TOPIC3_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_COUNT_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_COUNT_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_DISTINCT_COUNT_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_DISTINCT_COUNT_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_DISTINCT_COUNT_EVENT_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_DISTINCT_COUNT_EVENT_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_DISTINCT_COUNT_EVENT_ID_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_DISTINCT_COUNT_EVENT_ID_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_DISTINCT_COUNT_ID_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_DISTINCT_COUNT_ID_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_DISTINCT_COUNT_TOPIC0_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_DISTINCT_COUNT_TOPIC0_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_DISTINCT_COUNT_TOPIC1_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_DISTINCT_COUNT_TOPIC1_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_DISTINCT_COUNT_TOPIC2_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_DISTINCT_COUNT_TOPIC2_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_DISTINCT_COUNT_TOPIC3_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_DISTINCT_COUNT_TOPIC3_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_MAX_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_MAX_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_MAX_EVENT_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_MAX_EVENT_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_MAX_EVENT_ID_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_MAX_EVENT_ID_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_MAX_ID_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_MAX_ID_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_MAX_TOPIC0_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_MAX_TOPIC0_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_MAX_TOPIC1_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_MAX_TOPIC1_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_MAX_TOPIC2_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_MAX_TOPIC2_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_MAX_TOPIC3_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_MAX_TOPIC3_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_MIN_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_MIN_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_MIN_EVENT_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_MIN_EVENT_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_MIN_EVENT_ID_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_MIN_EVENT_ID_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_MIN_ID_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_MIN_ID_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_MIN_TOPIC0_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_MIN_TOPIC0_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_MIN_TOPIC1_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_MIN_TOPIC1_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_MIN_TOPIC2_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_MIN_TOPIC2_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_MIN_TOPIC3_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_MIN_TOPIC3_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_STDDEV_POPULATION_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_STDDEV_POPULATION_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_STDDEV_POPULATION_EVENT_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_STDDEV_POPULATION_EVENT_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_STDDEV_POPULATION_EVENT_ID_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_STDDEV_POPULATION_EVENT_ID_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_STDDEV_POPULATION_ID_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_STDDEV_POPULATION_ID_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_STDDEV_POPULATION_TOPIC0_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_STDDEV_POPULATION_TOPIC0_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_STDDEV_POPULATION_TOPIC1_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_STDDEV_POPULATION_TOPIC1_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_STDDEV_POPULATION_TOPIC2_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_STDDEV_POPULATION_TOPIC2_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_STDDEV_POPULATION_TOPIC3_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_STDDEV_POPULATION_TOPIC3_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_STDDEV_SAMPLE_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_STDDEV_SAMPLE_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_STDDEV_SAMPLE_EVENT_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_STDDEV_SAMPLE_EVENT_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_STDDEV_SAMPLE_EVENT_ID_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_STDDEV_SAMPLE_EVENT_ID_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_STDDEV_SAMPLE_ID_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_STDDEV_SAMPLE_ID_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_STDDEV_SAMPLE_TOPIC0_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_STDDEV_SAMPLE_TOPIC0_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_STDDEV_SAMPLE_TOPIC1_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_STDDEV_SAMPLE_TOPIC1_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_STDDEV_SAMPLE_TOPIC2_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_STDDEV_SAMPLE_TOPIC2_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_STDDEV_SAMPLE_TOPIC3_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_STDDEV_SAMPLE_TOPIC3_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_SUM_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_SUM_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_SUM_EVENT_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_SUM_EVENT_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_SUM_EVENT_ID_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_SUM_EVENT_ID_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_SUM_ID_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_SUM_ID_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_SUM_TOPIC0_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_SUM_TOPIC0_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_SUM_TOPIC1_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_SUM_TOPIC1_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_SUM_TOPIC2_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_SUM_TOPIC2_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_SUM_TOPIC3_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_SUM_TOPIC3_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_VARIANCE_POPULATION_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_VARIANCE_POPULATION_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_VARIANCE_POPULATION_EVENT_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_VARIANCE_POPULATION_EVENT_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_VARIANCE_POPULATION_EVENT_ID_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_VARIANCE_POPULATION_EVENT_ID_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_VARIANCE_POPULATION_ID_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_VARIANCE_POPULATION_ID_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_VARIANCE_POPULATION_TOPIC0_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_VARIANCE_POPULATION_TOPIC0_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_VARIANCE_POPULATION_TOPIC1_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_VARIANCE_POPULATION_TOPIC1_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_VARIANCE_POPULATION_TOPIC2_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_VARIANCE_POPULATION_TOPIC2_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_VARIANCE_POPULATION_TOPIC3_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_VARIANCE_POPULATION_TOPIC3_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_VARIANCE_SAMPLE_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_VARIANCE_SAMPLE_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_VARIANCE_SAMPLE_EVENT_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_VARIANCE_SAMPLE_EVENT_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_VARIANCE_SAMPLE_EVENT_ID_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_VARIANCE_SAMPLE_EVENT_ID_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_VARIANCE_SAMPLE_ID_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_VARIANCE_SAMPLE_ID_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_VARIANCE_SAMPLE_TOPIC0_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_VARIANCE_SAMPLE_TOPIC0_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_VARIANCE_SAMPLE_TOPIC1_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_VARIANCE_SAMPLE_TOPIC1_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_VARIANCE_SAMPLE_TOPIC2_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_VARIANCE_SAMPLE_TOPIC2_DESC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_VARIANCE_SAMPLE_TOPIC3_ASC'
  | 'ACALA_EVM_EXECUTED_FAILED_LOGS_BY_EVENT_ID_VARIANCE_SAMPLE_TOPIC3_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_AVERAGE_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_AVERAGE_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_AVERAGE_EVENT_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_AVERAGE_EVENT_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_AVERAGE_EVENT_ID_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_AVERAGE_EVENT_ID_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_AVERAGE_ID_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_AVERAGE_ID_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_AVERAGE_TOPIC0_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_AVERAGE_TOPIC0_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_AVERAGE_TOPIC1_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_AVERAGE_TOPIC1_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_AVERAGE_TOPIC2_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_AVERAGE_TOPIC2_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_AVERAGE_TOPIC3_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_AVERAGE_TOPIC3_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_COUNT_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_COUNT_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_DISTINCT_COUNT_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_DISTINCT_COUNT_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_DISTINCT_COUNT_EVENT_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_DISTINCT_COUNT_EVENT_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_DISTINCT_COUNT_EVENT_ID_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_DISTINCT_COUNT_EVENT_ID_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_DISTINCT_COUNT_ID_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_DISTINCT_COUNT_ID_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_DISTINCT_COUNT_TOPIC0_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_DISTINCT_COUNT_TOPIC0_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_DISTINCT_COUNT_TOPIC1_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_DISTINCT_COUNT_TOPIC1_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_DISTINCT_COUNT_TOPIC2_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_DISTINCT_COUNT_TOPIC2_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_DISTINCT_COUNT_TOPIC3_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_DISTINCT_COUNT_TOPIC3_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_MAX_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_MAX_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_MAX_EVENT_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_MAX_EVENT_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_MAX_EVENT_ID_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_MAX_EVENT_ID_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_MAX_ID_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_MAX_ID_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_MAX_TOPIC0_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_MAX_TOPIC0_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_MAX_TOPIC1_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_MAX_TOPIC1_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_MAX_TOPIC2_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_MAX_TOPIC2_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_MAX_TOPIC3_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_MAX_TOPIC3_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_MIN_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_MIN_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_MIN_EVENT_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_MIN_EVENT_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_MIN_EVENT_ID_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_MIN_EVENT_ID_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_MIN_ID_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_MIN_ID_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_MIN_TOPIC0_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_MIN_TOPIC0_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_MIN_TOPIC1_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_MIN_TOPIC1_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_MIN_TOPIC2_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_MIN_TOPIC2_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_MIN_TOPIC3_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_MIN_TOPIC3_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_STDDEV_POPULATION_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_STDDEV_POPULATION_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_STDDEV_POPULATION_EVENT_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_STDDEV_POPULATION_EVENT_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_STDDEV_POPULATION_EVENT_ID_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_STDDEV_POPULATION_EVENT_ID_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_STDDEV_POPULATION_ID_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_STDDEV_POPULATION_ID_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_STDDEV_POPULATION_TOPIC0_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_STDDEV_POPULATION_TOPIC0_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_STDDEV_POPULATION_TOPIC1_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_STDDEV_POPULATION_TOPIC1_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_STDDEV_POPULATION_TOPIC2_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_STDDEV_POPULATION_TOPIC2_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_STDDEV_POPULATION_TOPIC3_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_STDDEV_POPULATION_TOPIC3_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_STDDEV_SAMPLE_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_STDDEV_SAMPLE_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_STDDEV_SAMPLE_EVENT_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_STDDEV_SAMPLE_EVENT_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_STDDEV_SAMPLE_EVENT_ID_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_STDDEV_SAMPLE_EVENT_ID_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_STDDEV_SAMPLE_ID_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_STDDEV_SAMPLE_ID_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_STDDEV_SAMPLE_TOPIC0_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_STDDEV_SAMPLE_TOPIC0_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_STDDEV_SAMPLE_TOPIC1_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_STDDEV_SAMPLE_TOPIC1_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_STDDEV_SAMPLE_TOPIC2_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_STDDEV_SAMPLE_TOPIC2_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_STDDEV_SAMPLE_TOPIC3_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_STDDEV_SAMPLE_TOPIC3_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_SUM_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_SUM_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_SUM_EVENT_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_SUM_EVENT_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_SUM_EVENT_ID_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_SUM_EVENT_ID_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_SUM_ID_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_SUM_ID_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_SUM_TOPIC0_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_SUM_TOPIC0_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_SUM_TOPIC1_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_SUM_TOPIC1_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_SUM_TOPIC2_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_SUM_TOPIC2_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_SUM_TOPIC3_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_SUM_TOPIC3_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_VARIANCE_POPULATION_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_VARIANCE_POPULATION_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_VARIANCE_POPULATION_EVENT_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_VARIANCE_POPULATION_EVENT_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_VARIANCE_POPULATION_EVENT_ID_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_VARIANCE_POPULATION_EVENT_ID_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_VARIANCE_POPULATION_ID_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_VARIANCE_POPULATION_ID_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_VARIANCE_POPULATION_TOPIC0_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_VARIANCE_POPULATION_TOPIC0_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_VARIANCE_POPULATION_TOPIC1_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_VARIANCE_POPULATION_TOPIC1_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_VARIANCE_POPULATION_TOPIC2_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_VARIANCE_POPULATION_TOPIC2_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_VARIANCE_POPULATION_TOPIC3_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_VARIANCE_POPULATION_TOPIC3_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_VARIANCE_SAMPLE_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_VARIANCE_SAMPLE_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_VARIANCE_SAMPLE_EVENT_CONTRACT_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_VARIANCE_SAMPLE_EVENT_CONTRACT_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_VARIANCE_SAMPLE_EVENT_ID_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_VARIANCE_SAMPLE_EVENT_ID_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_VARIANCE_SAMPLE_ID_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_VARIANCE_SAMPLE_ID_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_VARIANCE_SAMPLE_TOPIC0_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_VARIANCE_SAMPLE_TOPIC0_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_VARIANCE_SAMPLE_TOPIC1_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_VARIANCE_SAMPLE_TOPIC1_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_VARIANCE_SAMPLE_TOPIC2_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_VARIANCE_SAMPLE_TOPIC2_DESC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_VARIANCE_SAMPLE_TOPIC3_ASC'
  | 'ACALA_EVM_EXECUTED_LOGS_BY_EVENT_ID_VARIANCE_SAMPLE_TOPIC3_DESC'
  | 'ARGS_ASC'
  | 'ARGS_DESC'
  | 'BLOCK_ID_ASC'
  | 'BLOCK_ID_DESC'
  | 'CALL_ID_ASC'
  | 'CALL_ID_DESC'
  | 'EXTRINSIC_ID_ASC'
  | 'EXTRINSIC_ID_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'INDEX_IN_BLOCK_ASC'
  | 'INDEX_IN_BLOCK_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'NATURAL'
  | 'PHASE_ASC'
  | 'PHASE_DESC'
  | 'POS_ASC'
  | 'POS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

export type Extrinsic = Node & {
  __typename?: 'Extrinsic';
  /** Reads a single `Block` that is related to this `Extrinsic`. */
  blockByBlockId: Block;
  blockId: Scalars['String']['output'];
  callId: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `Call`. */
  callsByExtrinsicId: CallsConnection;
  error?: Maybe<Scalars['JSON']['output']>;
  /** Reads and enables pagination through a set of `Event`. */
  eventsByExtrinsicId: EventsConnection;
  fee?: Maybe<Scalars['BigFloat']['output']>;
  hash: Scalars['String']['output'];
  id: Scalars['String']['output'];
  indexInBlock: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  pos: Scalars['Int']['output'];
  signature?: Maybe<Scalars['JSON']['output']>;
  success: Scalars['Boolean']['output'];
  tip?: Maybe<Scalars['BigFloat']['output']>;
  version: Scalars['Int']['output'];
};


export type ExtrinsicCallsByExtrinsicIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CallCondition>;
  filter?: InputMaybe<CallFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CallsOrderBy>>;
};


export type ExtrinsicEventsByExtrinsicIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventCondition>;
  filter?: InputMaybe<EventFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};

export type ExtrinsicAggregates = {
  __typename?: 'ExtrinsicAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<ExtrinsicAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<ExtrinsicDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<ExtrinsicMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<ExtrinsicMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<ExtrinsicStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<ExtrinsicStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<ExtrinsicSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<ExtrinsicVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<ExtrinsicVarianceSampleAggregates>;
};

export type ExtrinsicAverageAggregates = {
  __typename?: 'ExtrinsicAverageAggregates';
  /** Mean average of fee across the matching connection */
  fee?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of indexInBlock across the matching connection */
  indexInBlock?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of pos across the matching connection */
  pos?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of tip across the matching connection */
  tip?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of version across the matching connection */
  version?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `Extrinsic` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ExtrinsicCondition = {
  /** Checks for equality with the object’s `blockId` field. */
  blockId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `callId` field. */
  callId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `error` field. */
  error?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `fee` field. */
  fee?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `hash` field. */
  hash?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `indexInBlock` field. */
  indexInBlock?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `pos` field. */
  pos?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `signature` field. */
  signature?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `success` field. */
  success?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `tip` field. */
  tip?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `version` field. */
  version?: InputMaybe<Scalars['Int']['input']>;
};

export type ExtrinsicDistinctCountAggregates = {
  __typename?: 'ExtrinsicDistinctCountAggregates';
  /** Distinct count of blockId across the matching connection */
  blockId?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of callId across the matching connection */
  callId?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of error across the matching connection */
  error?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of fee across the matching connection */
  fee?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of hash across the matching connection */
  hash?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of id across the matching connection */
  id?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of indexInBlock across the matching connection */
  indexInBlock?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of pos across the matching connection */
  pos?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of signature across the matching connection */
  signature?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of success across the matching connection */
  success?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of tip across the matching connection */
  tip?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of version across the matching connection */
  version?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `Extrinsic` object types. All fields are combined with a logical ‘and.’ */
export type ExtrinsicFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ExtrinsicFilter>>;
  /** Filter by the object’s `blockId` field. */
  blockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `callId` field. */
  callId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `error` field. */
  error?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `fee` field. */
  fee?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `hash` field. */
  hash?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `indexInBlock` field. */
  indexInBlock?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ExtrinsicFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ExtrinsicFilter>>;
  /** Filter by the object’s `pos` field. */
  pos?: InputMaybe<IntFilter>;
  /** Filter by the object’s `signature` field. */
  signature?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `success` field. */
  success?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `tip` field. */
  tip?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `version` field. */
  version?: InputMaybe<IntFilter>;
};

/** Grouping methods for `Extrinsic` for usage during aggregation. */
export type ExtrinsicGroupBy =
  | 'BLOCK_ID'
  | 'CALL_ID'
  | 'ERROR'
  | 'FEE'
  | 'HASH'
  | 'INDEX_IN_BLOCK'
  | 'POS'
  | 'SIGNATURE'
  | 'SUCCESS'
  | 'TIP'
  | 'VERSION';

export type ExtrinsicHavingAverageInput = {
  fee?: InputMaybe<HavingBigfloatFilter>;
  indexInBlock?: InputMaybe<HavingIntFilter>;
  pos?: InputMaybe<HavingIntFilter>;
  tip?: InputMaybe<HavingBigfloatFilter>;
  version?: InputMaybe<HavingIntFilter>;
};

export type ExtrinsicHavingDistinctCountInput = {
  fee?: InputMaybe<HavingBigfloatFilter>;
  indexInBlock?: InputMaybe<HavingIntFilter>;
  pos?: InputMaybe<HavingIntFilter>;
  tip?: InputMaybe<HavingBigfloatFilter>;
  version?: InputMaybe<HavingIntFilter>;
};

/** Conditions for `Extrinsic` aggregates. */
export type ExtrinsicHavingInput = {
  AND?: InputMaybe<Array<ExtrinsicHavingInput>>;
  OR?: InputMaybe<Array<ExtrinsicHavingInput>>;
  average?: InputMaybe<ExtrinsicHavingAverageInput>;
  distinctCount?: InputMaybe<ExtrinsicHavingDistinctCountInput>;
  max?: InputMaybe<ExtrinsicHavingMaxInput>;
  min?: InputMaybe<ExtrinsicHavingMinInput>;
  stddevPopulation?: InputMaybe<ExtrinsicHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<ExtrinsicHavingStddevSampleInput>;
  sum?: InputMaybe<ExtrinsicHavingSumInput>;
  variancePopulation?: InputMaybe<ExtrinsicHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<ExtrinsicHavingVarianceSampleInput>;
};

export type ExtrinsicHavingMaxInput = {
  fee?: InputMaybe<HavingBigfloatFilter>;
  indexInBlock?: InputMaybe<HavingIntFilter>;
  pos?: InputMaybe<HavingIntFilter>;
  tip?: InputMaybe<HavingBigfloatFilter>;
  version?: InputMaybe<HavingIntFilter>;
};

export type ExtrinsicHavingMinInput = {
  fee?: InputMaybe<HavingBigfloatFilter>;
  indexInBlock?: InputMaybe<HavingIntFilter>;
  pos?: InputMaybe<HavingIntFilter>;
  tip?: InputMaybe<HavingBigfloatFilter>;
  version?: InputMaybe<HavingIntFilter>;
};

export type ExtrinsicHavingStddevPopulationInput = {
  fee?: InputMaybe<HavingBigfloatFilter>;
  indexInBlock?: InputMaybe<HavingIntFilter>;
  pos?: InputMaybe<HavingIntFilter>;
  tip?: InputMaybe<HavingBigfloatFilter>;
  version?: InputMaybe<HavingIntFilter>;
};

export type ExtrinsicHavingStddevSampleInput = {
  fee?: InputMaybe<HavingBigfloatFilter>;
  indexInBlock?: InputMaybe<HavingIntFilter>;
  pos?: InputMaybe<HavingIntFilter>;
  tip?: InputMaybe<HavingBigfloatFilter>;
  version?: InputMaybe<HavingIntFilter>;
};

export type ExtrinsicHavingSumInput = {
  fee?: InputMaybe<HavingBigfloatFilter>;
  indexInBlock?: InputMaybe<HavingIntFilter>;
  pos?: InputMaybe<HavingIntFilter>;
  tip?: InputMaybe<HavingBigfloatFilter>;
  version?: InputMaybe<HavingIntFilter>;
};

export type ExtrinsicHavingVariancePopulationInput = {
  fee?: InputMaybe<HavingBigfloatFilter>;
  indexInBlock?: InputMaybe<HavingIntFilter>;
  pos?: InputMaybe<HavingIntFilter>;
  tip?: InputMaybe<HavingBigfloatFilter>;
  version?: InputMaybe<HavingIntFilter>;
};

export type ExtrinsicHavingVarianceSampleInput = {
  fee?: InputMaybe<HavingBigfloatFilter>;
  indexInBlock?: InputMaybe<HavingIntFilter>;
  pos?: InputMaybe<HavingIntFilter>;
  tip?: InputMaybe<HavingBigfloatFilter>;
  version?: InputMaybe<HavingIntFilter>;
};

export type ExtrinsicMaxAggregates = {
  __typename?: 'ExtrinsicMaxAggregates';
  /** Maximum of fee across the matching connection */
  fee?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of indexInBlock across the matching connection */
  indexInBlock?: Maybe<Scalars['Int']['output']>;
  /** Maximum of pos across the matching connection */
  pos?: Maybe<Scalars['Int']['output']>;
  /** Maximum of tip across the matching connection */
  tip?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of version across the matching connection */
  version?: Maybe<Scalars['Int']['output']>;
};

export type ExtrinsicMinAggregates = {
  __typename?: 'ExtrinsicMinAggregates';
  /** Minimum of fee across the matching connection */
  fee?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of indexInBlock across the matching connection */
  indexInBlock?: Maybe<Scalars['Int']['output']>;
  /** Minimum of pos across the matching connection */
  pos?: Maybe<Scalars['Int']['output']>;
  /** Minimum of tip across the matching connection */
  tip?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of version across the matching connection */
  version?: Maybe<Scalars['Int']['output']>;
};

export type ExtrinsicStddevPopulationAggregates = {
  __typename?: 'ExtrinsicStddevPopulationAggregates';
  /** Population standard deviation of fee across the matching connection */
  fee?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of indexInBlock across the matching connection */
  indexInBlock?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of pos across the matching connection */
  pos?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of tip across the matching connection */
  tip?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of version across the matching connection */
  version?: Maybe<Scalars['BigFloat']['output']>;
};

export type ExtrinsicStddevSampleAggregates = {
  __typename?: 'ExtrinsicStddevSampleAggregates';
  /** Sample standard deviation of fee across the matching connection */
  fee?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of indexInBlock across the matching connection */
  indexInBlock?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of pos across the matching connection */
  pos?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of tip across the matching connection */
  tip?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of version across the matching connection */
  version?: Maybe<Scalars['BigFloat']['output']>;
};

export type ExtrinsicSumAggregates = {
  __typename?: 'ExtrinsicSumAggregates';
  /** Sum of fee across the matching connection */
  fee: Scalars['BigFloat']['output'];
  /** Sum of indexInBlock across the matching connection */
  indexInBlock: Scalars['BigInt']['output'];
  /** Sum of pos across the matching connection */
  pos: Scalars['BigInt']['output'];
  /** Sum of tip across the matching connection */
  tip: Scalars['BigFloat']['output'];
  /** Sum of version across the matching connection */
  version: Scalars['BigInt']['output'];
};

export type ExtrinsicVariancePopulationAggregates = {
  __typename?: 'ExtrinsicVariancePopulationAggregates';
  /** Population variance of fee across the matching connection */
  fee?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of indexInBlock across the matching connection */
  indexInBlock?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of pos across the matching connection */
  pos?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of tip across the matching connection */
  tip?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of version across the matching connection */
  version?: Maybe<Scalars['BigFloat']['output']>;
};

export type ExtrinsicVarianceSampleAggregates = {
  __typename?: 'ExtrinsicVarianceSampleAggregates';
  /** Sample variance of fee across the matching connection */
  fee?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of indexInBlock across the matching connection */
  indexInBlock?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of pos across the matching connection */
  pos?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of tip across the matching connection */
  tip?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of version across the matching connection */
  version?: Maybe<Scalars['BigFloat']['output']>;
};

/** A connection to a list of `Extrinsic` values. */
export type ExtrinsicsConnection = {
  __typename?: 'ExtrinsicsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<ExtrinsicAggregates>;
  /** A list of edges which contains the `Extrinsic` and cursor to aid in pagination. */
  edges: Array<ExtrinsicsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<ExtrinsicAggregates>>;
  /** A list of `Extrinsic` objects. */
  nodes: Array<Extrinsic>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Extrinsic` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `Extrinsic` values. */
export type ExtrinsicsConnectionGroupedAggregatesArgs = {
  groupBy: Array<ExtrinsicGroupBy>;
  having?: InputMaybe<ExtrinsicHavingInput>;
};

/** A `Extrinsic` edge in the connection. */
export type ExtrinsicsEdge = {
  __typename?: 'ExtrinsicsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Extrinsic` at the end of the edge. */
  node: Extrinsic;
};

/** Methods to use when ordering `Extrinsic`. */
export type ExtrinsicsOrderBy =
  | 'BLOCK_ID_ASC'
  | 'BLOCK_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_AVERAGE_ARGS_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_AVERAGE_ARGS_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_AVERAGE_BLOCK_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_AVERAGE_BLOCK_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_AVERAGE_ERROR_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_AVERAGE_ERROR_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_AVERAGE_EXTRINSIC_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_AVERAGE_EXTRINSIC_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_AVERAGE_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_AVERAGE_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_AVERAGE_NAME_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_AVERAGE_NAME_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_AVERAGE_ORIGIN_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_AVERAGE_ORIGIN_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_AVERAGE_PARENT_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_AVERAGE_PARENT_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_AVERAGE_POS_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_AVERAGE_POS_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_AVERAGE_SUCCESS_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_AVERAGE_SUCCESS_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_COUNT_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_COUNT_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_DISTINCT_COUNT_ARGS_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_DISTINCT_COUNT_ARGS_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_DISTINCT_COUNT_BLOCK_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_DISTINCT_COUNT_BLOCK_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_DISTINCT_COUNT_ERROR_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_DISTINCT_COUNT_ERROR_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_DISTINCT_COUNT_EXTRINSIC_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_DISTINCT_COUNT_EXTRINSIC_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_DISTINCT_COUNT_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_DISTINCT_COUNT_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_DISTINCT_COUNT_NAME_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_DISTINCT_COUNT_NAME_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_DISTINCT_COUNT_ORIGIN_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_DISTINCT_COUNT_ORIGIN_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_DISTINCT_COUNT_PARENT_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_DISTINCT_COUNT_PARENT_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_DISTINCT_COUNT_POS_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_DISTINCT_COUNT_POS_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_DISTINCT_COUNT_SUCCESS_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_DISTINCT_COUNT_SUCCESS_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_MAX_ARGS_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_MAX_ARGS_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_MAX_BLOCK_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_MAX_BLOCK_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_MAX_ERROR_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_MAX_ERROR_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_MAX_EXTRINSIC_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_MAX_EXTRINSIC_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_MAX_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_MAX_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_MAX_NAME_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_MAX_NAME_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_MAX_ORIGIN_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_MAX_ORIGIN_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_MAX_PARENT_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_MAX_PARENT_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_MAX_POS_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_MAX_POS_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_MAX_SUCCESS_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_MAX_SUCCESS_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_MIN_ARGS_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_MIN_ARGS_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_MIN_BLOCK_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_MIN_BLOCK_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_MIN_ERROR_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_MIN_ERROR_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_MIN_EXTRINSIC_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_MIN_EXTRINSIC_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_MIN_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_MIN_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_MIN_NAME_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_MIN_NAME_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_MIN_ORIGIN_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_MIN_ORIGIN_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_MIN_PARENT_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_MIN_PARENT_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_MIN_POS_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_MIN_POS_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_MIN_SUCCESS_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_MIN_SUCCESS_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_POPULATION_ARGS_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_POPULATION_ARGS_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_POPULATION_BLOCK_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_POPULATION_BLOCK_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_POPULATION_ERROR_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_POPULATION_ERROR_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_POPULATION_EXTRINSIC_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_POPULATION_EXTRINSIC_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_POPULATION_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_POPULATION_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_POPULATION_NAME_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_POPULATION_NAME_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_POPULATION_ORIGIN_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_POPULATION_ORIGIN_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_POPULATION_PARENT_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_POPULATION_PARENT_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_POPULATION_POS_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_POPULATION_POS_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_POPULATION_SUCCESS_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_POPULATION_SUCCESS_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_ARGS_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_ARGS_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_BLOCK_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_BLOCK_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_ERROR_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_ERROR_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_EXTRINSIC_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_EXTRINSIC_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_NAME_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_NAME_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_ORIGIN_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_ORIGIN_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_PARENT_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_PARENT_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_POS_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_POS_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_SUCCESS_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_SUCCESS_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_SUM_ARGS_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_SUM_ARGS_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_SUM_BLOCK_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_SUM_BLOCK_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_SUM_ERROR_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_SUM_ERROR_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_SUM_EXTRINSIC_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_SUM_EXTRINSIC_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_SUM_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_SUM_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_SUM_NAME_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_SUM_NAME_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_SUM_ORIGIN_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_SUM_ORIGIN_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_SUM_PARENT_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_SUM_PARENT_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_SUM_POS_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_SUM_POS_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_SUM_SUCCESS_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_SUM_SUCCESS_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_ARGS_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_ARGS_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_BLOCK_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_BLOCK_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_ERROR_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_ERROR_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_EXTRINSIC_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_EXTRINSIC_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_NAME_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_NAME_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_ORIGIN_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_ORIGIN_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_PARENT_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_PARENT_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_POS_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_POS_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_SUCCESS_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_SUCCESS_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_ARGS_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_ARGS_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_BLOCK_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_BLOCK_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_ERROR_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_ERROR_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_EXTRINSIC_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_EXTRINSIC_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_NAME_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_NAME_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_ORIGIN_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_ORIGIN_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_PARENT_ID_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_PARENT_ID_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_POS_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_POS_DESC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_SUCCESS_ASC'
  | 'CALLS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_SUCCESS_DESC'
  | 'CALL_ID_ASC'
  | 'CALL_ID_DESC'
  | 'ERROR_ASC'
  | 'ERROR_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_AVERAGE_ARGS_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_AVERAGE_ARGS_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_AVERAGE_BLOCK_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_AVERAGE_BLOCK_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_AVERAGE_CALL_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_AVERAGE_CALL_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_AVERAGE_EXTRINSIC_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_AVERAGE_EXTRINSIC_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_AVERAGE_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_AVERAGE_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_AVERAGE_INDEX_IN_BLOCK_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_AVERAGE_INDEX_IN_BLOCK_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_AVERAGE_NAME_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_AVERAGE_NAME_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_AVERAGE_PHASE_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_AVERAGE_PHASE_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_AVERAGE_POS_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_AVERAGE_POS_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_COUNT_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_COUNT_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_DISTINCT_COUNT_ARGS_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_DISTINCT_COUNT_ARGS_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_DISTINCT_COUNT_BLOCK_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_DISTINCT_COUNT_BLOCK_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_DISTINCT_COUNT_CALL_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_DISTINCT_COUNT_CALL_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_DISTINCT_COUNT_EXTRINSIC_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_DISTINCT_COUNT_EXTRINSIC_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_DISTINCT_COUNT_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_DISTINCT_COUNT_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_DISTINCT_COUNT_INDEX_IN_BLOCK_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_DISTINCT_COUNT_INDEX_IN_BLOCK_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_DISTINCT_COUNT_NAME_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_DISTINCT_COUNT_NAME_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_DISTINCT_COUNT_PHASE_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_DISTINCT_COUNT_PHASE_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_DISTINCT_COUNT_POS_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_DISTINCT_COUNT_POS_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_MAX_ARGS_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_MAX_ARGS_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_MAX_BLOCK_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_MAX_BLOCK_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_MAX_CALL_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_MAX_CALL_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_MAX_EXTRINSIC_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_MAX_EXTRINSIC_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_MAX_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_MAX_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_MAX_INDEX_IN_BLOCK_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_MAX_INDEX_IN_BLOCK_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_MAX_NAME_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_MAX_NAME_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_MAX_PHASE_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_MAX_PHASE_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_MAX_POS_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_MAX_POS_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_MIN_ARGS_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_MIN_ARGS_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_MIN_BLOCK_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_MIN_BLOCK_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_MIN_CALL_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_MIN_CALL_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_MIN_EXTRINSIC_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_MIN_EXTRINSIC_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_MIN_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_MIN_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_MIN_INDEX_IN_BLOCK_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_MIN_INDEX_IN_BLOCK_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_MIN_NAME_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_MIN_NAME_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_MIN_PHASE_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_MIN_PHASE_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_MIN_POS_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_MIN_POS_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_POPULATION_ARGS_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_POPULATION_ARGS_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_POPULATION_BLOCK_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_POPULATION_BLOCK_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_POPULATION_CALL_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_POPULATION_CALL_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_POPULATION_EXTRINSIC_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_POPULATION_EXTRINSIC_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_POPULATION_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_POPULATION_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_POPULATION_INDEX_IN_BLOCK_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_POPULATION_INDEX_IN_BLOCK_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_POPULATION_NAME_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_POPULATION_NAME_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_POPULATION_PHASE_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_POPULATION_PHASE_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_POPULATION_POS_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_POPULATION_POS_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_ARGS_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_ARGS_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_BLOCK_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_BLOCK_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_CALL_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_CALL_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_EXTRINSIC_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_EXTRINSIC_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_INDEX_IN_BLOCK_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_INDEX_IN_BLOCK_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_NAME_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_NAME_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_PHASE_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_PHASE_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_POS_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_STDDEV_SAMPLE_POS_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_SUM_ARGS_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_SUM_ARGS_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_SUM_BLOCK_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_SUM_BLOCK_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_SUM_CALL_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_SUM_CALL_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_SUM_EXTRINSIC_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_SUM_EXTRINSIC_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_SUM_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_SUM_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_SUM_INDEX_IN_BLOCK_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_SUM_INDEX_IN_BLOCK_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_SUM_NAME_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_SUM_NAME_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_SUM_PHASE_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_SUM_PHASE_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_SUM_POS_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_SUM_POS_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_ARGS_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_ARGS_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_BLOCK_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_BLOCK_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_CALL_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_CALL_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_EXTRINSIC_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_EXTRINSIC_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_INDEX_IN_BLOCK_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_INDEX_IN_BLOCK_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_NAME_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_NAME_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_PHASE_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_PHASE_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_POS_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_POPULATION_POS_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_ARGS_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_ARGS_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_BLOCK_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_BLOCK_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_CALL_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_CALL_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_EXTRINSIC_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_EXTRINSIC_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_ID_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_ID_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_INDEX_IN_BLOCK_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_INDEX_IN_BLOCK_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_NAME_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_NAME_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_PHASE_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_PHASE_DESC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_POS_ASC'
  | 'EVENTS_BY_EXTRINSIC_ID_VARIANCE_SAMPLE_POS_DESC'
  | 'FEE_ASC'
  | 'FEE_DESC'
  | 'HASH_ASC'
  | 'HASH_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'INDEX_IN_BLOCK_ASC'
  | 'INDEX_IN_BLOCK_DESC'
  | 'NATURAL'
  | 'POS_ASC'
  | 'POS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SIGNATURE_ASC'
  | 'SIGNATURE_DESC'
  | 'SUCCESS_ASC'
  | 'SUCCESS_DESC'
  | 'TIP_ASC'
  | 'TIP_DESC'
  | 'VERSION_ASC'
  | 'VERSION_DESC';

/** A connection to a list of `FlipSupply` values. */
export type FlipSuppliesConnection = {
  __typename?: 'FlipSuppliesConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<FlipSupplyAggregates>;
  /** A list of edges which contains the `FlipSupply` and cursor to aid in pagination. */
  edges: Array<FlipSuppliesEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<FlipSupplyAggregates>>;
  /** A list of `FlipSupply` objects. */
  nodes: Array<FlipSupply>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FlipSupply` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `FlipSupply` values. */
export type FlipSuppliesConnectionGroupedAggregatesArgs = {
  groupBy: Array<FlipSupplyGroupBy>;
  having?: InputMaybe<FlipSupplyHavingInput>;
};

/** A `FlipSupply` edge in the connection. */
export type FlipSuppliesEdge = {
  __typename?: 'FlipSuppliesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FlipSupply` at the end of the edge. */
  node: FlipSupply;
};

/** Methods to use when ordering `FlipSupply`. */
export type FlipSuppliesOrderBy =
  | 'ANNUAL_SYSTEM_COMPOUNDED_REWARDS_ASC'
  | 'ANNUAL_SYSTEM_COMPOUNDED_REWARDS_DESC'
  | 'AUTHORITY_EMISSION_PER_BLOCK_ASC'
  | 'AUTHORITY_EMISSION_PER_BLOCK_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'OFFCHAIN_FUNDS_ASC'
  | 'OFFCHAIN_FUNDS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'START_BLOCK_HEIGHT_ASC'
  | 'START_BLOCK_HEIGHT_DESC'
  | 'START_BLOCK_TIMESTAMP_ASC'
  | 'START_BLOCK_TIMESTAMP_DESC'
  | 'TOTAL_ANNUAL_EMISSION_ASC'
  | 'TOTAL_ANNUAL_EMISSION_DESC'
  | 'TOTAL_ISSUANCE_ASC'
  | 'TOTAL_ISSUANCE_DESC';

export type FlipSupply = Node & {
  __typename?: 'FlipSupply';
  annualSystemCompoundedRewards: Scalars['String']['output'];
  authorityEmissionPerBlock: Scalars['BigFloat']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  offchainFunds: Scalars['String']['output'];
  startBlockHeight: Scalars['Int']['output'];
  startBlockTimestamp: Scalars['BigInt']['output'];
  totalAnnualEmission: Scalars['BigFloat']['output'];
  totalIssuance: Scalars['String']['output'];
};

export type FlipSupplyAggregates = {
  __typename?: 'FlipSupplyAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<FlipSupplyAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<FlipSupplyDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<FlipSupplyMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<FlipSupplyMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<FlipSupplyStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<FlipSupplyStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<FlipSupplySumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<FlipSupplyVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<FlipSupplyVarianceSampleAggregates>;
};

export type FlipSupplyAverageAggregates = {
  __typename?: 'FlipSupplyAverageAggregates';
  /** Mean average of authorityEmissionPerBlock across the matching connection */
  authorityEmissionPerBlock?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of startBlockHeight across the matching connection */
  startBlockHeight?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of startBlockTimestamp across the matching connection */
  startBlockTimestamp?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of totalAnnualEmission across the matching connection */
  totalAnnualEmission?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `FlipSupply` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type FlipSupplyCondition = {
  /** Checks for equality with the object’s `annualSystemCompoundedRewards` field. */
  annualSystemCompoundedRewards?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `authorityEmissionPerBlock` field. */
  authorityEmissionPerBlock?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `offchainFunds` field. */
  offchainFunds?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `startBlockHeight` field. */
  startBlockHeight?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `startBlockTimestamp` field. */
  startBlockTimestamp?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `totalAnnualEmission` field. */
  totalAnnualEmission?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalIssuance` field. */
  totalIssuance?: InputMaybe<Scalars['String']['input']>;
};

export type FlipSupplyDistinctCountAggregates = {
  __typename?: 'FlipSupplyDistinctCountAggregates';
  /** Distinct count of annualSystemCompoundedRewards across the matching connection */
  annualSystemCompoundedRewards?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of authorityEmissionPerBlock across the matching connection */
  authorityEmissionPerBlock?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of id across the matching connection */
  id?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of offchainFunds across the matching connection */
  offchainFunds?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of startBlockHeight across the matching connection */
  startBlockHeight?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of startBlockTimestamp across the matching connection */
  startBlockTimestamp?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of totalAnnualEmission across the matching connection */
  totalAnnualEmission?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of totalIssuance across the matching connection */
  totalIssuance?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `FlipSupply` object types. All fields are combined with a logical ‘and.’ */
export type FlipSupplyFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FlipSupplyFilter>>;
  /** Filter by the object’s `annualSystemCompoundedRewards` field. */
  annualSystemCompoundedRewards?: InputMaybe<StringFilter>;
  /** Filter by the object’s `authorityEmissionPerBlock` field. */
  authorityEmissionPerBlock?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FlipSupplyFilter>;
  /** Filter by the object’s `offchainFunds` field. */
  offchainFunds?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FlipSupplyFilter>>;
  /** Filter by the object’s `startBlockHeight` field. */
  startBlockHeight?: InputMaybe<IntFilter>;
  /** Filter by the object’s `startBlockTimestamp` field. */
  startBlockTimestamp?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `totalAnnualEmission` field. */
  totalAnnualEmission?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalIssuance` field. */
  totalIssuance?: InputMaybe<StringFilter>;
};

/** Grouping methods for `FlipSupply` for usage during aggregation. */
export type FlipSupplyGroupBy =
  | 'ANNUAL_SYSTEM_COMPOUNDED_REWARDS'
  | 'AUTHORITY_EMISSION_PER_BLOCK'
  | 'OFFCHAIN_FUNDS'
  | 'START_BLOCK_HEIGHT'
  | 'START_BLOCK_TIMESTAMP'
  | 'TOTAL_ANNUAL_EMISSION'
  | 'TOTAL_ISSUANCE';

export type FlipSupplyHavingAverageInput = {
  authorityEmissionPerBlock?: InputMaybe<HavingBigfloatFilter>;
  id?: InputMaybe<HavingIntFilter>;
  startBlockHeight?: InputMaybe<HavingIntFilter>;
  startBlockTimestamp?: InputMaybe<HavingBigintFilter>;
  totalAnnualEmission?: InputMaybe<HavingBigfloatFilter>;
};

export type FlipSupplyHavingDistinctCountInput = {
  authorityEmissionPerBlock?: InputMaybe<HavingBigfloatFilter>;
  id?: InputMaybe<HavingIntFilter>;
  startBlockHeight?: InputMaybe<HavingIntFilter>;
  startBlockTimestamp?: InputMaybe<HavingBigintFilter>;
  totalAnnualEmission?: InputMaybe<HavingBigfloatFilter>;
};

/** Conditions for `FlipSupply` aggregates. */
export type FlipSupplyHavingInput = {
  AND?: InputMaybe<Array<FlipSupplyHavingInput>>;
  OR?: InputMaybe<Array<FlipSupplyHavingInput>>;
  average?: InputMaybe<FlipSupplyHavingAverageInput>;
  distinctCount?: InputMaybe<FlipSupplyHavingDistinctCountInput>;
  max?: InputMaybe<FlipSupplyHavingMaxInput>;
  min?: InputMaybe<FlipSupplyHavingMinInput>;
  stddevPopulation?: InputMaybe<FlipSupplyHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<FlipSupplyHavingStddevSampleInput>;
  sum?: InputMaybe<FlipSupplyHavingSumInput>;
  variancePopulation?: InputMaybe<FlipSupplyHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<FlipSupplyHavingVarianceSampleInput>;
};

export type FlipSupplyHavingMaxInput = {
  authorityEmissionPerBlock?: InputMaybe<HavingBigfloatFilter>;
  id?: InputMaybe<HavingIntFilter>;
  startBlockHeight?: InputMaybe<HavingIntFilter>;
  startBlockTimestamp?: InputMaybe<HavingBigintFilter>;
  totalAnnualEmission?: InputMaybe<HavingBigfloatFilter>;
};

export type FlipSupplyHavingMinInput = {
  authorityEmissionPerBlock?: InputMaybe<HavingBigfloatFilter>;
  id?: InputMaybe<HavingIntFilter>;
  startBlockHeight?: InputMaybe<HavingIntFilter>;
  startBlockTimestamp?: InputMaybe<HavingBigintFilter>;
  totalAnnualEmission?: InputMaybe<HavingBigfloatFilter>;
};

export type FlipSupplyHavingStddevPopulationInput = {
  authorityEmissionPerBlock?: InputMaybe<HavingBigfloatFilter>;
  id?: InputMaybe<HavingIntFilter>;
  startBlockHeight?: InputMaybe<HavingIntFilter>;
  startBlockTimestamp?: InputMaybe<HavingBigintFilter>;
  totalAnnualEmission?: InputMaybe<HavingBigfloatFilter>;
};

export type FlipSupplyHavingStddevSampleInput = {
  authorityEmissionPerBlock?: InputMaybe<HavingBigfloatFilter>;
  id?: InputMaybe<HavingIntFilter>;
  startBlockHeight?: InputMaybe<HavingIntFilter>;
  startBlockTimestamp?: InputMaybe<HavingBigintFilter>;
  totalAnnualEmission?: InputMaybe<HavingBigfloatFilter>;
};

export type FlipSupplyHavingSumInput = {
  authorityEmissionPerBlock?: InputMaybe<HavingBigfloatFilter>;
  id?: InputMaybe<HavingIntFilter>;
  startBlockHeight?: InputMaybe<HavingIntFilter>;
  startBlockTimestamp?: InputMaybe<HavingBigintFilter>;
  totalAnnualEmission?: InputMaybe<HavingBigfloatFilter>;
};

export type FlipSupplyHavingVariancePopulationInput = {
  authorityEmissionPerBlock?: InputMaybe<HavingBigfloatFilter>;
  id?: InputMaybe<HavingIntFilter>;
  startBlockHeight?: InputMaybe<HavingIntFilter>;
  startBlockTimestamp?: InputMaybe<HavingBigintFilter>;
  totalAnnualEmission?: InputMaybe<HavingBigfloatFilter>;
};

export type FlipSupplyHavingVarianceSampleInput = {
  authorityEmissionPerBlock?: InputMaybe<HavingBigfloatFilter>;
  id?: InputMaybe<HavingIntFilter>;
  startBlockHeight?: InputMaybe<HavingIntFilter>;
  startBlockTimestamp?: InputMaybe<HavingBigintFilter>;
  totalAnnualEmission?: InputMaybe<HavingBigfloatFilter>;
};

export type FlipSupplyMaxAggregates = {
  __typename?: 'FlipSupplyMaxAggregates';
  /** Maximum of authorityEmissionPerBlock across the matching connection */
  authorityEmissionPerBlock?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of id across the matching connection */
  id?: Maybe<Scalars['Int']['output']>;
  /** Maximum of startBlockHeight across the matching connection */
  startBlockHeight?: Maybe<Scalars['Int']['output']>;
  /** Maximum of startBlockTimestamp across the matching connection */
  startBlockTimestamp?: Maybe<Scalars['BigInt']['output']>;
  /** Maximum of totalAnnualEmission across the matching connection */
  totalAnnualEmission?: Maybe<Scalars['BigFloat']['output']>;
};

export type FlipSupplyMinAggregates = {
  __typename?: 'FlipSupplyMinAggregates';
  /** Minimum of authorityEmissionPerBlock across the matching connection */
  authorityEmissionPerBlock?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of id across the matching connection */
  id?: Maybe<Scalars['Int']['output']>;
  /** Minimum of startBlockHeight across the matching connection */
  startBlockHeight?: Maybe<Scalars['Int']['output']>;
  /** Minimum of startBlockTimestamp across the matching connection */
  startBlockTimestamp?: Maybe<Scalars['BigInt']['output']>;
  /** Minimum of totalAnnualEmission across the matching connection */
  totalAnnualEmission?: Maybe<Scalars['BigFloat']['output']>;
};

export type FlipSupplyStddevPopulationAggregates = {
  __typename?: 'FlipSupplyStddevPopulationAggregates';
  /** Population standard deviation of authorityEmissionPerBlock across the matching connection */
  authorityEmissionPerBlock?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of startBlockHeight across the matching connection */
  startBlockHeight?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of startBlockTimestamp across the matching connection */
  startBlockTimestamp?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of totalAnnualEmission across the matching connection */
  totalAnnualEmission?: Maybe<Scalars['BigFloat']['output']>;
};

export type FlipSupplyStddevSampleAggregates = {
  __typename?: 'FlipSupplyStddevSampleAggregates';
  /** Sample standard deviation of authorityEmissionPerBlock across the matching connection */
  authorityEmissionPerBlock?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of startBlockHeight across the matching connection */
  startBlockHeight?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of startBlockTimestamp across the matching connection */
  startBlockTimestamp?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of totalAnnualEmission across the matching connection */
  totalAnnualEmission?: Maybe<Scalars['BigFloat']['output']>;
};

export type FlipSupplySumAggregates = {
  __typename?: 'FlipSupplySumAggregates';
  /** Sum of authorityEmissionPerBlock across the matching connection */
  authorityEmissionPerBlock: Scalars['BigFloat']['output'];
  /** Sum of id across the matching connection */
  id: Scalars['BigInt']['output'];
  /** Sum of startBlockHeight across the matching connection */
  startBlockHeight: Scalars['BigInt']['output'];
  /** Sum of startBlockTimestamp across the matching connection */
  startBlockTimestamp: Scalars['BigFloat']['output'];
  /** Sum of totalAnnualEmission across the matching connection */
  totalAnnualEmission: Scalars['BigFloat']['output'];
};

export type FlipSupplyVariancePopulationAggregates = {
  __typename?: 'FlipSupplyVariancePopulationAggregates';
  /** Population variance of authorityEmissionPerBlock across the matching connection */
  authorityEmissionPerBlock?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of startBlockHeight across the matching connection */
  startBlockHeight?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of startBlockTimestamp across the matching connection */
  startBlockTimestamp?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of totalAnnualEmission across the matching connection */
  totalAnnualEmission?: Maybe<Scalars['BigFloat']['output']>;
};

export type FlipSupplyVarianceSampleAggregates = {
  __typename?: 'FlipSupplyVarianceSampleAggregates';
  /** Sample variance of authorityEmissionPerBlock across the matching connection */
  authorityEmissionPerBlock?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of startBlockHeight across the matching connection */
  startBlockHeight?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of startBlockTimestamp across the matching connection */
  startBlockTimestamp?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of totalAnnualEmission across the matching connection */
  totalAnnualEmission?: Maybe<Scalars['BigFloat']['output']>;
};

/** A filter to be used against Float fields. All fields are combined with a logical ‘and.’ */
export type FloatFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Float']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Float']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Float']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Float']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Float']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Float']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Float']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Float']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Float']['input']>>;
};

export type FrontierEthereumTransaction = Node & {
  __typename?: 'FrontierEthereumTransaction';
  /** Reads a single `Call` that is related to this `FrontierEthereumTransaction`. */
  callByCallId: Call;
  callId: Scalars['String']['output'];
  contract: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  sighash?: Maybe<Scalars['String']['output']>;
};

export type FrontierEthereumTransactionAggregates = {
  __typename?: 'FrontierEthereumTransactionAggregates';
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<FrontierEthereumTransactionDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/**
 * A condition to be used against `FrontierEthereumTransaction` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type FrontierEthereumTransactionCondition = {
  /** Checks for equality with the object’s `callId` field. */
  callId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `contract` field. */
  contract?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sighash` field. */
  sighash?: InputMaybe<Scalars['String']['input']>;
};

export type FrontierEthereumTransactionDistinctCountAggregates = {
  __typename?: 'FrontierEthereumTransactionDistinctCountAggregates';
  /** Distinct count of callId across the matching connection */
  callId?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of contract across the matching connection */
  contract?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of sighash across the matching connection */
  sighash?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `FrontierEthereumTransaction` object types. All fields are combined with a logical ‘and.’ */
export type FrontierEthereumTransactionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FrontierEthereumTransactionFilter>>;
  /** Filter by the object’s `callId` field. */
  callId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `contract` field. */
  contract?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FrontierEthereumTransactionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FrontierEthereumTransactionFilter>>;
  /** Filter by the object’s `sighash` field. */
  sighash?: InputMaybe<StringFilter>;
};

/** Grouping methods for `FrontierEthereumTransaction` for usage during aggregation. */
export type FrontierEthereumTransactionGroupBy =
  | 'CONTRACT'
  | 'SIGHASH';

/** Conditions for `FrontierEthereumTransaction` aggregates. */
export type FrontierEthereumTransactionHavingInput = {
  AND?: InputMaybe<Array<FrontierEthereumTransactionHavingInput>>;
  OR?: InputMaybe<Array<FrontierEthereumTransactionHavingInput>>;
};

/** A connection to a list of `FrontierEthereumTransaction` values. */
export type FrontierEthereumTransactionsConnection = {
  __typename?: 'FrontierEthereumTransactionsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<FrontierEthereumTransactionAggregates>;
  /** A list of edges which contains the `FrontierEthereumTransaction` and cursor to aid in pagination. */
  edges: Array<FrontierEthereumTransactionsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<FrontierEthereumTransactionAggregates>>;
  /** A list of `FrontierEthereumTransaction` objects. */
  nodes: Array<FrontierEthereumTransaction>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FrontierEthereumTransaction` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `FrontierEthereumTransaction` values. */
export type FrontierEthereumTransactionsConnectionGroupedAggregatesArgs = {
  groupBy: Array<FrontierEthereumTransactionGroupBy>;
  having?: InputMaybe<FrontierEthereumTransactionHavingInput>;
};

/** A `FrontierEthereumTransaction` edge in the connection. */
export type FrontierEthereumTransactionsEdge = {
  __typename?: 'FrontierEthereumTransactionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FrontierEthereumTransaction` at the end of the edge. */
  node: FrontierEthereumTransaction;
};

/** Methods to use when ordering `FrontierEthereumTransaction`. */
export type FrontierEthereumTransactionsOrderBy =
  | 'CALL_ID_ASC'
  | 'CALL_ID_DESC'
  | 'CONTRACT_ASC'
  | 'CONTRACT_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SIGHASH_ASC'
  | 'SIGHASH_DESC';

export type FrontierEvmLog = Node & {
  __typename?: 'FrontierEvmLog';
  contract: Scalars['String']['output'];
  /** Reads a single `Event` that is related to this `FrontierEvmLog`. */
  eventByEventId: Event;
  eventId: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  topic0?: Maybe<Scalars['String']['output']>;
  topic1?: Maybe<Scalars['String']['output']>;
  topic2?: Maybe<Scalars['String']['output']>;
  topic3?: Maybe<Scalars['String']['output']>;
};

export type FrontierEvmLogAggregates = {
  __typename?: 'FrontierEvmLogAggregates';
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<FrontierEvmLogDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/**
 * A condition to be used against `FrontierEvmLog` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type FrontierEvmLogCondition = {
  /** Checks for equality with the object’s `contract` field. */
  contract?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `eventId` field. */
  eventId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `topic0` field. */
  topic0?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `topic1` field. */
  topic1?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `topic2` field. */
  topic2?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `topic3` field. */
  topic3?: InputMaybe<Scalars['String']['input']>;
};

export type FrontierEvmLogDistinctCountAggregates = {
  __typename?: 'FrontierEvmLogDistinctCountAggregates';
  /** Distinct count of contract across the matching connection */
  contract?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of eventId across the matching connection */
  eventId?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of topic0 across the matching connection */
  topic0?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of topic1 across the matching connection */
  topic1?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of topic2 across the matching connection */
  topic2?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of topic3 across the matching connection */
  topic3?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `FrontierEvmLog` object types. All fields are combined with a logical ‘and.’ */
export type FrontierEvmLogFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FrontierEvmLogFilter>>;
  /** Filter by the object’s `contract` field. */
  contract?: InputMaybe<StringFilter>;
  /** Filter by the object’s `eventId` field. */
  eventId?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FrontierEvmLogFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FrontierEvmLogFilter>>;
  /** Filter by the object’s `topic0` field. */
  topic0?: InputMaybe<StringFilter>;
  /** Filter by the object’s `topic1` field. */
  topic1?: InputMaybe<StringFilter>;
  /** Filter by the object’s `topic2` field. */
  topic2?: InputMaybe<StringFilter>;
  /** Filter by the object’s `topic3` field. */
  topic3?: InputMaybe<StringFilter>;
};

/** Grouping methods for `FrontierEvmLog` for usage during aggregation. */
export type FrontierEvmLogGroupBy =
  | 'CONTRACT'
  | 'TOPIC0'
  | 'TOPIC1'
  | 'TOPIC2'
  | 'TOPIC3';

/** Conditions for `FrontierEvmLog` aggregates. */
export type FrontierEvmLogHavingInput = {
  AND?: InputMaybe<Array<FrontierEvmLogHavingInput>>;
  OR?: InputMaybe<Array<FrontierEvmLogHavingInput>>;
};

/** A connection to a list of `FrontierEvmLog` values. */
export type FrontierEvmLogsConnection = {
  __typename?: 'FrontierEvmLogsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<FrontierEvmLogAggregates>;
  /** A list of edges which contains the `FrontierEvmLog` and cursor to aid in pagination. */
  edges: Array<FrontierEvmLogsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<FrontierEvmLogAggregates>>;
  /** A list of `FrontierEvmLog` objects. */
  nodes: Array<FrontierEvmLog>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `FrontierEvmLog` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `FrontierEvmLog` values. */
export type FrontierEvmLogsConnectionGroupedAggregatesArgs = {
  groupBy: Array<FrontierEvmLogGroupBy>;
  having?: InputMaybe<FrontierEvmLogHavingInput>;
};

/** A `FrontierEvmLog` edge in the connection. */
export type FrontierEvmLogsEdge = {
  __typename?: 'FrontierEvmLogsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `FrontierEvmLog` at the end of the edge. */
  node: FrontierEvmLog;
};

/** Methods to use when ordering `FrontierEvmLog`. */
export type FrontierEvmLogsOrderBy =
  | 'CONTRACT_ASC'
  | 'CONTRACT_DESC'
  | 'EVENT_ID_ASC'
  | 'EVENT_ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TOPIC0_ASC'
  | 'TOPIC0_DESC'
  | 'TOPIC1_ASC'
  | 'TOPIC1_DESC'
  | 'TOPIC2_ASC'
  | 'TOPIC2_DESC'
  | 'TOPIC3_ASC'
  | 'TOPIC3_DESC';

export type GearMessageEnqueued = Node & {
  __typename?: 'GearMessageEnqueued';
  /** Reads a single `Event` that is related to this `GearMessageEnqueued`. */
  eventByEventId: Event;
  eventId: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  program: Scalars['String']['output'];
};

export type GearMessageEnqueuedAggregates = {
  __typename?: 'GearMessageEnqueuedAggregates';
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<GearMessageEnqueuedDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/**
 * A condition to be used against `GearMessageEnqueued` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type GearMessageEnqueuedCondition = {
  /** Checks for equality with the object’s `eventId` field. */
  eventId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `program` field. */
  program?: InputMaybe<Scalars['String']['input']>;
};

export type GearMessageEnqueuedDistinctCountAggregates = {
  __typename?: 'GearMessageEnqueuedDistinctCountAggregates';
  /** Distinct count of eventId across the matching connection */
  eventId?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of program across the matching connection */
  program?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `GearMessageEnqueued` object types. All fields are combined with a logical ‘and.’ */
export type GearMessageEnqueuedFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<GearMessageEnqueuedFilter>>;
  /** Filter by the object’s `eventId` field. */
  eventId?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<GearMessageEnqueuedFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<GearMessageEnqueuedFilter>>;
  /** Filter by the object’s `program` field. */
  program?: InputMaybe<StringFilter>;
};

/** Grouping methods for `GearMessageEnqueued` for usage during aggregation. */
export type GearMessageEnqueuedGroupBy =
  | 'PROGRAM';

/** Conditions for `GearMessageEnqueued` aggregates. */
export type GearMessageEnqueuedHavingInput = {
  AND?: InputMaybe<Array<GearMessageEnqueuedHavingInput>>;
  OR?: InputMaybe<Array<GearMessageEnqueuedHavingInput>>;
};

/** A connection to a list of `GearMessageEnqueued` values. */
export type GearMessageEnqueuedsConnection = {
  __typename?: 'GearMessageEnqueuedsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<GearMessageEnqueuedAggregates>;
  /** A list of edges which contains the `GearMessageEnqueued` and cursor to aid in pagination. */
  edges: Array<GearMessageEnqueuedsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<GearMessageEnqueuedAggregates>>;
  /** A list of `GearMessageEnqueued` objects. */
  nodes: Array<GearMessageEnqueued>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `GearMessageEnqueued` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `GearMessageEnqueued` values. */
export type GearMessageEnqueuedsConnectionGroupedAggregatesArgs = {
  groupBy: Array<GearMessageEnqueuedGroupBy>;
  having?: InputMaybe<GearMessageEnqueuedHavingInput>;
};

/** A `GearMessageEnqueued` edge in the connection. */
export type GearMessageEnqueuedsEdge = {
  __typename?: 'GearMessageEnqueuedsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `GearMessageEnqueued` at the end of the edge. */
  node: GearMessageEnqueued;
};

/** Methods to use when ordering `GearMessageEnqueued`. */
export type GearMessageEnqueuedsOrderBy =
  | 'EVENT_ID_ASC'
  | 'EVENT_ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'PROGRAM_ASC'
  | 'PROGRAM_DESC';

export type GearUserMessageSent = Node & {
  __typename?: 'GearUserMessageSent';
  /** Reads a single `Event` that is related to this `GearUserMessageSent`. */
  eventByEventId: Event;
  eventId: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  program: Scalars['String']['output'];
};

export type GearUserMessageSentAggregates = {
  __typename?: 'GearUserMessageSentAggregates';
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<GearUserMessageSentDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/**
 * A condition to be used against `GearUserMessageSent` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type GearUserMessageSentCondition = {
  /** Checks for equality with the object’s `eventId` field. */
  eventId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `program` field. */
  program?: InputMaybe<Scalars['String']['input']>;
};

export type GearUserMessageSentDistinctCountAggregates = {
  __typename?: 'GearUserMessageSentDistinctCountAggregates';
  /** Distinct count of eventId across the matching connection */
  eventId?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of program across the matching connection */
  program?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `GearUserMessageSent` object types. All fields are combined with a logical ‘and.’ */
export type GearUserMessageSentFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<GearUserMessageSentFilter>>;
  /** Filter by the object’s `eventId` field. */
  eventId?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<GearUserMessageSentFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<GearUserMessageSentFilter>>;
  /** Filter by the object’s `program` field. */
  program?: InputMaybe<StringFilter>;
};

/** Grouping methods for `GearUserMessageSent` for usage during aggregation. */
export type GearUserMessageSentGroupBy =
  | 'PROGRAM';

/** Conditions for `GearUserMessageSent` aggregates. */
export type GearUserMessageSentHavingInput = {
  AND?: InputMaybe<Array<GearUserMessageSentHavingInput>>;
  OR?: InputMaybe<Array<GearUserMessageSentHavingInput>>;
};

/** A connection to a list of `GearUserMessageSent` values. */
export type GearUserMessageSentsConnection = {
  __typename?: 'GearUserMessageSentsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<GearUserMessageSentAggregates>;
  /** A list of edges which contains the `GearUserMessageSent` and cursor to aid in pagination. */
  edges: Array<GearUserMessageSentsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<GearUserMessageSentAggregates>>;
  /** A list of `GearUserMessageSent` objects. */
  nodes: Array<GearUserMessageSent>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `GearUserMessageSent` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `GearUserMessageSent` values. */
export type GearUserMessageSentsConnectionGroupedAggregatesArgs = {
  groupBy: Array<GearUserMessageSentGroupBy>;
  having?: InputMaybe<GearUserMessageSentHavingInput>;
};

/** A `GearUserMessageSent` edge in the connection. */
export type GearUserMessageSentsEdge = {
  __typename?: 'GearUserMessageSentsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `GearUserMessageSent` at the end of the edge. */
  node: GearUserMessageSent;
};

/** Methods to use when ordering `GearUserMessageSent`. */
export type GearUserMessageSentsOrderBy =
  | 'EVENT_ID_ASC'
  | 'EVENT_ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'PROGRAM_ASC'
  | 'PROGRAM_DESC';

export type HavingBigfloatFilter = {
  equalTo?: InputMaybe<Scalars['BigFloat']['input']>;
  greaterThan?: InputMaybe<Scalars['BigFloat']['input']>;
  greaterThanOrEqualTo?: InputMaybe<Scalars['BigFloat']['input']>;
  lessThan?: InputMaybe<Scalars['BigFloat']['input']>;
  lessThanOrEqualTo?: InputMaybe<Scalars['BigFloat']['input']>;
  notEqualTo?: InputMaybe<Scalars['BigFloat']['input']>;
};

export type HavingBigintFilter = {
  equalTo?: InputMaybe<Scalars['BigInt']['input']>;
  greaterThan?: InputMaybe<Scalars['BigInt']['input']>;
  greaterThanOrEqualTo?: InputMaybe<Scalars['BigInt']['input']>;
  lessThan?: InputMaybe<Scalars['BigInt']['input']>;
  lessThanOrEqualTo?: InputMaybe<Scalars['BigInt']['input']>;
  notEqualTo?: InputMaybe<Scalars['BigInt']['input']>;
};

export type HavingDatetimeFilter = {
  equalTo?: InputMaybe<Scalars['Datetime']['input']>;
  greaterThan?: InputMaybe<Scalars['Datetime']['input']>;
  greaterThanOrEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  lessThan?: InputMaybe<Scalars['Datetime']['input']>;
  lessThanOrEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  notEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
};

export type HavingFloatFilter = {
  equalTo?: InputMaybe<Scalars['Float']['input']>;
  greaterThan?: InputMaybe<Scalars['Float']['input']>;
  greaterThanOrEqualTo?: InputMaybe<Scalars['Float']['input']>;
  lessThan?: InputMaybe<Scalars['Float']['input']>;
  lessThanOrEqualTo?: InputMaybe<Scalars['Float']['input']>;
  notEqualTo?: InputMaybe<Scalars['Float']['input']>;
};

export type HavingIntFilter = {
  equalTo?: InputMaybe<Scalars['Int']['input']>;
  greaterThan?: InputMaybe<Scalars['Int']['input']>;
  greaterThanOrEqualTo?: InputMaybe<Scalars['Int']['input']>;
  lessThan?: InputMaybe<Scalars['Int']['input']>;
  lessThanOrEqualTo?: InputMaybe<Scalars['Int']['input']>;
  notEqualTo?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against Int fields. All fields are combined with a logical ‘and.’ */
export type IntFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Int']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Int']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Int']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Int']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Int']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** A filter to be used against JSON fields. All fields are combined with a logical ‘and.’ */
export type JsonFilter = {
  /** Contained by the specified JSON. */
  containedBy?: InputMaybe<Scalars['JSON']['input']>;
  /** Contains the specified JSON. */
  contains?: InputMaybe<Scalars['JSON']['input']>;
  /** Contains all of the specified keys. */
  containsAllKeys?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Contains any of the specified keys. */
  containsAnyKeys?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Contains the specified key. */
  containsKey?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['JSON']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['JSON']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['JSON']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['JSON']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['JSON']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['JSON']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['JSON']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['JSON']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['JSON']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['JSON']['input']>>;
};

export type LendingGlobalConfig = Node & {
  __typename?: 'LendingGlobalConfig';
  hardLiquidationLtvAbortAtBps: Scalars['Int']['output'];
  hardLiquidationLtvThresholdBps: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  interestFeeNetworkShareBps: Scalars['Int']['output'];
  liquidationFeeNetworkShareBps: Scalars['Int']['output'];
  lowLtvPenaltyFeeNetworkShareBps: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  originationFeeNetworkShareBps: Scalars['Int']['output'];
  softLiquidationLtvAbortAtBps: Scalars['Int']['output'];
  softLiquidationLtvThresholdBps: Scalars['Int']['output'];
  targetLtvThresholdBps: Scalars['Int']['output'];
  topupLtvThresholdBps: Scalars['Int']['output'];
};

export type LendingGlobalConfigAggregates = {
  __typename?: 'LendingGlobalConfigAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<LendingGlobalConfigAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<LendingGlobalConfigDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<LendingGlobalConfigMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<LendingGlobalConfigMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<LendingGlobalConfigStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<LendingGlobalConfigStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<LendingGlobalConfigSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<LendingGlobalConfigVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<LendingGlobalConfigVarianceSampleAggregates>;
};

export type LendingGlobalConfigAverageAggregates = {
  __typename?: 'LendingGlobalConfigAverageAggregates';
  /** Mean average of hardLiquidationLtvAbortAtBps across the matching connection */
  hardLiquidationLtvAbortAtBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of hardLiquidationLtvThresholdBps across the matching connection */
  hardLiquidationLtvThresholdBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of interestFeeNetworkShareBps across the matching connection */
  interestFeeNetworkShareBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of liquidationFeeNetworkShareBps across the matching connection */
  liquidationFeeNetworkShareBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of lowLtvPenaltyFeeNetworkShareBps across the matching connection */
  lowLtvPenaltyFeeNetworkShareBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of originationFeeNetworkShareBps across the matching connection */
  originationFeeNetworkShareBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of softLiquidationLtvAbortAtBps across the matching connection */
  softLiquidationLtvAbortAtBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of softLiquidationLtvThresholdBps across the matching connection */
  softLiquidationLtvThresholdBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of targetLtvThresholdBps across the matching connection */
  targetLtvThresholdBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of topupLtvThresholdBps across the matching connection */
  topupLtvThresholdBps?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `LendingGlobalConfig` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type LendingGlobalConfigCondition = {
  /** Checks for equality with the object’s `hardLiquidationLtvAbortAtBps` field. */
  hardLiquidationLtvAbortAtBps?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `hardLiquidationLtvThresholdBps` field. */
  hardLiquidationLtvThresholdBps?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `interestFeeNetworkShareBps` field. */
  interestFeeNetworkShareBps?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `liquidationFeeNetworkShareBps` field. */
  liquidationFeeNetworkShareBps?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `lowLtvPenaltyFeeNetworkShareBps` field. */
  lowLtvPenaltyFeeNetworkShareBps?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `originationFeeNetworkShareBps` field. */
  originationFeeNetworkShareBps?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `softLiquidationLtvAbortAtBps` field. */
  softLiquidationLtvAbortAtBps?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `softLiquidationLtvThresholdBps` field. */
  softLiquidationLtvThresholdBps?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `targetLtvThresholdBps` field. */
  targetLtvThresholdBps?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `topupLtvThresholdBps` field. */
  topupLtvThresholdBps?: InputMaybe<Scalars['Int']['input']>;
};

export type LendingGlobalConfigDistinctCountAggregates = {
  __typename?: 'LendingGlobalConfigDistinctCountAggregates';
  /** Distinct count of hardLiquidationLtvAbortAtBps across the matching connection */
  hardLiquidationLtvAbortAtBps?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of hardLiquidationLtvThresholdBps across the matching connection */
  hardLiquidationLtvThresholdBps?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of id across the matching connection */
  id?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of interestFeeNetworkShareBps across the matching connection */
  interestFeeNetworkShareBps?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of liquidationFeeNetworkShareBps across the matching connection */
  liquidationFeeNetworkShareBps?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of lowLtvPenaltyFeeNetworkShareBps across the matching connection */
  lowLtvPenaltyFeeNetworkShareBps?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of originationFeeNetworkShareBps across the matching connection */
  originationFeeNetworkShareBps?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of softLiquidationLtvAbortAtBps across the matching connection */
  softLiquidationLtvAbortAtBps?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of softLiquidationLtvThresholdBps across the matching connection */
  softLiquidationLtvThresholdBps?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of targetLtvThresholdBps across the matching connection */
  targetLtvThresholdBps?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of topupLtvThresholdBps across the matching connection */
  topupLtvThresholdBps?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `LendingGlobalConfig` object types. All fields are combined with a logical ‘and.’ */
export type LendingGlobalConfigFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<LendingGlobalConfigFilter>>;
  /** Filter by the object’s `hardLiquidationLtvAbortAtBps` field. */
  hardLiquidationLtvAbortAtBps?: InputMaybe<IntFilter>;
  /** Filter by the object’s `hardLiquidationLtvThresholdBps` field. */
  hardLiquidationLtvThresholdBps?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `interestFeeNetworkShareBps` field. */
  interestFeeNetworkShareBps?: InputMaybe<IntFilter>;
  /** Filter by the object’s `liquidationFeeNetworkShareBps` field. */
  liquidationFeeNetworkShareBps?: InputMaybe<IntFilter>;
  /** Filter by the object’s `lowLtvPenaltyFeeNetworkShareBps` field. */
  lowLtvPenaltyFeeNetworkShareBps?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<LendingGlobalConfigFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<LendingGlobalConfigFilter>>;
  /** Filter by the object’s `originationFeeNetworkShareBps` field. */
  originationFeeNetworkShareBps?: InputMaybe<IntFilter>;
  /** Filter by the object’s `softLiquidationLtvAbortAtBps` field. */
  softLiquidationLtvAbortAtBps?: InputMaybe<IntFilter>;
  /** Filter by the object’s `softLiquidationLtvThresholdBps` field. */
  softLiquidationLtvThresholdBps?: InputMaybe<IntFilter>;
  /** Filter by the object’s `targetLtvThresholdBps` field. */
  targetLtvThresholdBps?: InputMaybe<IntFilter>;
  /** Filter by the object’s `topupLtvThresholdBps` field. */
  topupLtvThresholdBps?: InputMaybe<IntFilter>;
};

/** Grouping methods for `LendingGlobalConfig` for usage during aggregation. */
export type LendingGlobalConfigGroupBy =
  | 'HARD_LIQUIDATION_LTV_ABORT_AT_BPS'
  | 'HARD_LIQUIDATION_LTV_THRESHOLD_BPS'
  | 'INTEREST_FEE_NETWORK_SHARE_BPS'
  | 'LIQUIDATION_FEE_NETWORK_SHARE_BPS'
  | 'LOW_LTV_PENALTY_FEE_NETWORK_SHARE_BPS'
  | 'ORIGINATION_FEE_NETWORK_SHARE_BPS'
  | 'SOFT_LIQUIDATION_LTV_ABORT_AT_BPS'
  | 'SOFT_LIQUIDATION_LTV_THRESHOLD_BPS'
  | 'TARGET_LTV_THRESHOLD_BPS'
  | 'TOPUP_LTV_THRESHOLD_BPS';

export type LendingGlobalConfigHavingAverageInput = {
  hardLiquidationLtvAbortAtBps?: InputMaybe<HavingIntFilter>;
  hardLiquidationLtvThresholdBps?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingIntFilter>;
  interestFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  liquidationFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  lowLtvPenaltyFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  originationFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  softLiquidationLtvAbortAtBps?: InputMaybe<HavingIntFilter>;
  softLiquidationLtvThresholdBps?: InputMaybe<HavingIntFilter>;
  targetLtvThresholdBps?: InputMaybe<HavingIntFilter>;
  topupLtvThresholdBps?: InputMaybe<HavingIntFilter>;
};

export type LendingGlobalConfigHavingDistinctCountInput = {
  hardLiquidationLtvAbortAtBps?: InputMaybe<HavingIntFilter>;
  hardLiquidationLtvThresholdBps?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingIntFilter>;
  interestFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  liquidationFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  lowLtvPenaltyFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  originationFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  softLiquidationLtvAbortAtBps?: InputMaybe<HavingIntFilter>;
  softLiquidationLtvThresholdBps?: InputMaybe<HavingIntFilter>;
  targetLtvThresholdBps?: InputMaybe<HavingIntFilter>;
  topupLtvThresholdBps?: InputMaybe<HavingIntFilter>;
};

/** Conditions for `LendingGlobalConfig` aggregates. */
export type LendingGlobalConfigHavingInput = {
  AND?: InputMaybe<Array<LendingGlobalConfigHavingInput>>;
  OR?: InputMaybe<Array<LendingGlobalConfigHavingInput>>;
  average?: InputMaybe<LendingGlobalConfigHavingAverageInput>;
  distinctCount?: InputMaybe<LendingGlobalConfigHavingDistinctCountInput>;
  max?: InputMaybe<LendingGlobalConfigHavingMaxInput>;
  min?: InputMaybe<LendingGlobalConfigHavingMinInput>;
  stddevPopulation?: InputMaybe<LendingGlobalConfigHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<LendingGlobalConfigHavingStddevSampleInput>;
  sum?: InputMaybe<LendingGlobalConfigHavingSumInput>;
  variancePopulation?: InputMaybe<LendingGlobalConfigHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<LendingGlobalConfigHavingVarianceSampleInput>;
};

export type LendingGlobalConfigHavingMaxInput = {
  hardLiquidationLtvAbortAtBps?: InputMaybe<HavingIntFilter>;
  hardLiquidationLtvThresholdBps?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingIntFilter>;
  interestFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  liquidationFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  lowLtvPenaltyFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  originationFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  softLiquidationLtvAbortAtBps?: InputMaybe<HavingIntFilter>;
  softLiquidationLtvThresholdBps?: InputMaybe<HavingIntFilter>;
  targetLtvThresholdBps?: InputMaybe<HavingIntFilter>;
  topupLtvThresholdBps?: InputMaybe<HavingIntFilter>;
};

export type LendingGlobalConfigHavingMinInput = {
  hardLiquidationLtvAbortAtBps?: InputMaybe<HavingIntFilter>;
  hardLiquidationLtvThresholdBps?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingIntFilter>;
  interestFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  liquidationFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  lowLtvPenaltyFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  originationFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  softLiquidationLtvAbortAtBps?: InputMaybe<HavingIntFilter>;
  softLiquidationLtvThresholdBps?: InputMaybe<HavingIntFilter>;
  targetLtvThresholdBps?: InputMaybe<HavingIntFilter>;
  topupLtvThresholdBps?: InputMaybe<HavingIntFilter>;
};

export type LendingGlobalConfigHavingStddevPopulationInput = {
  hardLiquidationLtvAbortAtBps?: InputMaybe<HavingIntFilter>;
  hardLiquidationLtvThresholdBps?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingIntFilter>;
  interestFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  liquidationFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  lowLtvPenaltyFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  originationFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  softLiquidationLtvAbortAtBps?: InputMaybe<HavingIntFilter>;
  softLiquidationLtvThresholdBps?: InputMaybe<HavingIntFilter>;
  targetLtvThresholdBps?: InputMaybe<HavingIntFilter>;
  topupLtvThresholdBps?: InputMaybe<HavingIntFilter>;
};

export type LendingGlobalConfigHavingStddevSampleInput = {
  hardLiquidationLtvAbortAtBps?: InputMaybe<HavingIntFilter>;
  hardLiquidationLtvThresholdBps?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingIntFilter>;
  interestFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  liquidationFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  lowLtvPenaltyFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  originationFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  softLiquidationLtvAbortAtBps?: InputMaybe<HavingIntFilter>;
  softLiquidationLtvThresholdBps?: InputMaybe<HavingIntFilter>;
  targetLtvThresholdBps?: InputMaybe<HavingIntFilter>;
  topupLtvThresholdBps?: InputMaybe<HavingIntFilter>;
};

export type LendingGlobalConfigHavingSumInput = {
  hardLiquidationLtvAbortAtBps?: InputMaybe<HavingIntFilter>;
  hardLiquidationLtvThresholdBps?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingIntFilter>;
  interestFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  liquidationFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  lowLtvPenaltyFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  originationFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  softLiquidationLtvAbortAtBps?: InputMaybe<HavingIntFilter>;
  softLiquidationLtvThresholdBps?: InputMaybe<HavingIntFilter>;
  targetLtvThresholdBps?: InputMaybe<HavingIntFilter>;
  topupLtvThresholdBps?: InputMaybe<HavingIntFilter>;
};

export type LendingGlobalConfigHavingVariancePopulationInput = {
  hardLiquidationLtvAbortAtBps?: InputMaybe<HavingIntFilter>;
  hardLiquidationLtvThresholdBps?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingIntFilter>;
  interestFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  liquidationFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  lowLtvPenaltyFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  originationFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  softLiquidationLtvAbortAtBps?: InputMaybe<HavingIntFilter>;
  softLiquidationLtvThresholdBps?: InputMaybe<HavingIntFilter>;
  targetLtvThresholdBps?: InputMaybe<HavingIntFilter>;
  topupLtvThresholdBps?: InputMaybe<HavingIntFilter>;
};

export type LendingGlobalConfigHavingVarianceSampleInput = {
  hardLiquidationLtvAbortAtBps?: InputMaybe<HavingIntFilter>;
  hardLiquidationLtvThresholdBps?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingIntFilter>;
  interestFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  liquidationFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  lowLtvPenaltyFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  originationFeeNetworkShareBps?: InputMaybe<HavingIntFilter>;
  softLiquidationLtvAbortAtBps?: InputMaybe<HavingIntFilter>;
  softLiquidationLtvThresholdBps?: InputMaybe<HavingIntFilter>;
  targetLtvThresholdBps?: InputMaybe<HavingIntFilter>;
  topupLtvThresholdBps?: InputMaybe<HavingIntFilter>;
};

export type LendingGlobalConfigMaxAggregates = {
  __typename?: 'LendingGlobalConfigMaxAggregates';
  /** Maximum of hardLiquidationLtvAbortAtBps across the matching connection */
  hardLiquidationLtvAbortAtBps?: Maybe<Scalars['Int']['output']>;
  /** Maximum of hardLiquidationLtvThresholdBps across the matching connection */
  hardLiquidationLtvThresholdBps?: Maybe<Scalars['Int']['output']>;
  /** Maximum of id across the matching connection */
  id?: Maybe<Scalars['Int']['output']>;
  /** Maximum of interestFeeNetworkShareBps across the matching connection */
  interestFeeNetworkShareBps?: Maybe<Scalars['Int']['output']>;
  /** Maximum of liquidationFeeNetworkShareBps across the matching connection */
  liquidationFeeNetworkShareBps?: Maybe<Scalars['Int']['output']>;
  /** Maximum of lowLtvPenaltyFeeNetworkShareBps across the matching connection */
  lowLtvPenaltyFeeNetworkShareBps?: Maybe<Scalars['Int']['output']>;
  /** Maximum of originationFeeNetworkShareBps across the matching connection */
  originationFeeNetworkShareBps?: Maybe<Scalars['Int']['output']>;
  /** Maximum of softLiquidationLtvAbortAtBps across the matching connection */
  softLiquidationLtvAbortAtBps?: Maybe<Scalars['Int']['output']>;
  /** Maximum of softLiquidationLtvThresholdBps across the matching connection */
  softLiquidationLtvThresholdBps?: Maybe<Scalars['Int']['output']>;
  /** Maximum of targetLtvThresholdBps across the matching connection */
  targetLtvThresholdBps?: Maybe<Scalars['Int']['output']>;
  /** Maximum of topupLtvThresholdBps across the matching connection */
  topupLtvThresholdBps?: Maybe<Scalars['Int']['output']>;
};

export type LendingGlobalConfigMinAggregates = {
  __typename?: 'LendingGlobalConfigMinAggregates';
  /** Minimum of hardLiquidationLtvAbortAtBps across the matching connection */
  hardLiquidationLtvAbortAtBps?: Maybe<Scalars['Int']['output']>;
  /** Minimum of hardLiquidationLtvThresholdBps across the matching connection */
  hardLiquidationLtvThresholdBps?: Maybe<Scalars['Int']['output']>;
  /** Minimum of id across the matching connection */
  id?: Maybe<Scalars['Int']['output']>;
  /** Minimum of interestFeeNetworkShareBps across the matching connection */
  interestFeeNetworkShareBps?: Maybe<Scalars['Int']['output']>;
  /** Minimum of liquidationFeeNetworkShareBps across the matching connection */
  liquidationFeeNetworkShareBps?: Maybe<Scalars['Int']['output']>;
  /** Minimum of lowLtvPenaltyFeeNetworkShareBps across the matching connection */
  lowLtvPenaltyFeeNetworkShareBps?: Maybe<Scalars['Int']['output']>;
  /** Minimum of originationFeeNetworkShareBps across the matching connection */
  originationFeeNetworkShareBps?: Maybe<Scalars['Int']['output']>;
  /** Minimum of softLiquidationLtvAbortAtBps across the matching connection */
  softLiquidationLtvAbortAtBps?: Maybe<Scalars['Int']['output']>;
  /** Minimum of softLiquidationLtvThresholdBps across the matching connection */
  softLiquidationLtvThresholdBps?: Maybe<Scalars['Int']['output']>;
  /** Minimum of targetLtvThresholdBps across the matching connection */
  targetLtvThresholdBps?: Maybe<Scalars['Int']['output']>;
  /** Minimum of topupLtvThresholdBps across the matching connection */
  topupLtvThresholdBps?: Maybe<Scalars['Int']['output']>;
};

export type LendingGlobalConfigStddevPopulationAggregates = {
  __typename?: 'LendingGlobalConfigStddevPopulationAggregates';
  /** Population standard deviation of hardLiquidationLtvAbortAtBps across the matching connection */
  hardLiquidationLtvAbortAtBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of hardLiquidationLtvThresholdBps across the matching connection */
  hardLiquidationLtvThresholdBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of interestFeeNetworkShareBps across the matching connection */
  interestFeeNetworkShareBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of liquidationFeeNetworkShareBps across the matching connection */
  liquidationFeeNetworkShareBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of lowLtvPenaltyFeeNetworkShareBps across the matching connection */
  lowLtvPenaltyFeeNetworkShareBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of originationFeeNetworkShareBps across the matching connection */
  originationFeeNetworkShareBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of softLiquidationLtvAbortAtBps across the matching connection */
  softLiquidationLtvAbortAtBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of softLiquidationLtvThresholdBps across the matching connection */
  softLiquidationLtvThresholdBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of targetLtvThresholdBps across the matching connection */
  targetLtvThresholdBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of topupLtvThresholdBps across the matching connection */
  topupLtvThresholdBps?: Maybe<Scalars['BigFloat']['output']>;
};

export type LendingGlobalConfigStddevSampleAggregates = {
  __typename?: 'LendingGlobalConfigStddevSampleAggregates';
  /** Sample standard deviation of hardLiquidationLtvAbortAtBps across the matching connection */
  hardLiquidationLtvAbortAtBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of hardLiquidationLtvThresholdBps across the matching connection */
  hardLiquidationLtvThresholdBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of interestFeeNetworkShareBps across the matching connection */
  interestFeeNetworkShareBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of liquidationFeeNetworkShareBps across the matching connection */
  liquidationFeeNetworkShareBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of lowLtvPenaltyFeeNetworkShareBps across the matching connection */
  lowLtvPenaltyFeeNetworkShareBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of originationFeeNetworkShareBps across the matching connection */
  originationFeeNetworkShareBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of softLiquidationLtvAbortAtBps across the matching connection */
  softLiquidationLtvAbortAtBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of softLiquidationLtvThresholdBps across the matching connection */
  softLiquidationLtvThresholdBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of targetLtvThresholdBps across the matching connection */
  targetLtvThresholdBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of topupLtvThresholdBps across the matching connection */
  topupLtvThresholdBps?: Maybe<Scalars['BigFloat']['output']>;
};

export type LendingGlobalConfigSumAggregates = {
  __typename?: 'LendingGlobalConfigSumAggregates';
  /** Sum of hardLiquidationLtvAbortAtBps across the matching connection */
  hardLiquidationLtvAbortAtBps: Scalars['BigInt']['output'];
  /** Sum of hardLiquidationLtvThresholdBps across the matching connection */
  hardLiquidationLtvThresholdBps: Scalars['BigInt']['output'];
  /** Sum of id across the matching connection */
  id: Scalars['BigInt']['output'];
  /** Sum of interestFeeNetworkShareBps across the matching connection */
  interestFeeNetworkShareBps: Scalars['BigInt']['output'];
  /** Sum of liquidationFeeNetworkShareBps across the matching connection */
  liquidationFeeNetworkShareBps: Scalars['BigInt']['output'];
  /** Sum of lowLtvPenaltyFeeNetworkShareBps across the matching connection */
  lowLtvPenaltyFeeNetworkShareBps: Scalars['BigInt']['output'];
  /** Sum of originationFeeNetworkShareBps across the matching connection */
  originationFeeNetworkShareBps: Scalars['BigInt']['output'];
  /** Sum of softLiquidationLtvAbortAtBps across the matching connection */
  softLiquidationLtvAbortAtBps: Scalars['BigInt']['output'];
  /** Sum of softLiquidationLtvThresholdBps across the matching connection */
  softLiquidationLtvThresholdBps: Scalars['BigInt']['output'];
  /** Sum of targetLtvThresholdBps across the matching connection */
  targetLtvThresholdBps: Scalars['BigInt']['output'];
  /** Sum of topupLtvThresholdBps across the matching connection */
  topupLtvThresholdBps: Scalars['BigInt']['output'];
};

export type LendingGlobalConfigVariancePopulationAggregates = {
  __typename?: 'LendingGlobalConfigVariancePopulationAggregates';
  /** Population variance of hardLiquidationLtvAbortAtBps across the matching connection */
  hardLiquidationLtvAbortAtBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of hardLiquidationLtvThresholdBps across the matching connection */
  hardLiquidationLtvThresholdBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of interestFeeNetworkShareBps across the matching connection */
  interestFeeNetworkShareBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of liquidationFeeNetworkShareBps across the matching connection */
  liquidationFeeNetworkShareBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of lowLtvPenaltyFeeNetworkShareBps across the matching connection */
  lowLtvPenaltyFeeNetworkShareBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of originationFeeNetworkShareBps across the matching connection */
  originationFeeNetworkShareBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of softLiquidationLtvAbortAtBps across the matching connection */
  softLiquidationLtvAbortAtBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of softLiquidationLtvThresholdBps across the matching connection */
  softLiquidationLtvThresholdBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of targetLtvThresholdBps across the matching connection */
  targetLtvThresholdBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of topupLtvThresholdBps across the matching connection */
  topupLtvThresholdBps?: Maybe<Scalars['BigFloat']['output']>;
};

export type LendingGlobalConfigVarianceSampleAggregates = {
  __typename?: 'LendingGlobalConfigVarianceSampleAggregates';
  /** Sample variance of hardLiquidationLtvAbortAtBps across the matching connection */
  hardLiquidationLtvAbortAtBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of hardLiquidationLtvThresholdBps across the matching connection */
  hardLiquidationLtvThresholdBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of interestFeeNetworkShareBps across the matching connection */
  interestFeeNetworkShareBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of liquidationFeeNetworkShareBps across the matching connection */
  liquidationFeeNetworkShareBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of lowLtvPenaltyFeeNetworkShareBps across the matching connection */
  lowLtvPenaltyFeeNetworkShareBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of originationFeeNetworkShareBps across the matching connection */
  originationFeeNetworkShareBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of softLiquidationLtvAbortAtBps across the matching connection */
  softLiquidationLtvAbortAtBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of softLiquidationLtvThresholdBps across the matching connection */
  softLiquidationLtvThresholdBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of targetLtvThresholdBps across the matching connection */
  targetLtvThresholdBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of topupLtvThresholdBps across the matching connection */
  topupLtvThresholdBps?: Maybe<Scalars['BigFloat']['output']>;
};

/** A connection to a list of `LendingGlobalConfig` values. */
export type LendingGlobalConfigsConnection = {
  __typename?: 'LendingGlobalConfigsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<LendingGlobalConfigAggregates>;
  /** A list of edges which contains the `LendingGlobalConfig` and cursor to aid in pagination. */
  edges: Array<LendingGlobalConfigsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<LendingGlobalConfigAggregates>>;
  /** A list of `LendingGlobalConfig` objects. */
  nodes: Array<LendingGlobalConfig>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `LendingGlobalConfig` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `LendingGlobalConfig` values. */
export type LendingGlobalConfigsConnectionGroupedAggregatesArgs = {
  groupBy: Array<LendingGlobalConfigGroupBy>;
  having?: InputMaybe<LendingGlobalConfigHavingInput>;
};

/** A `LendingGlobalConfig` edge in the connection. */
export type LendingGlobalConfigsEdge = {
  __typename?: 'LendingGlobalConfigsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `LendingGlobalConfig` at the end of the edge. */
  node: LendingGlobalConfig;
};

/** Methods to use when ordering `LendingGlobalConfig`. */
export type LendingGlobalConfigsOrderBy =
  | 'HARD_LIQUIDATION_LTV_ABORT_AT_BPS_ASC'
  | 'HARD_LIQUIDATION_LTV_ABORT_AT_BPS_DESC'
  | 'HARD_LIQUIDATION_LTV_THRESHOLD_BPS_ASC'
  | 'HARD_LIQUIDATION_LTV_THRESHOLD_BPS_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'INTEREST_FEE_NETWORK_SHARE_BPS_ASC'
  | 'INTEREST_FEE_NETWORK_SHARE_BPS_DESC'
  | 'LIQUIDATION_FEE_NETWORK_SHARE_BPS_ASC'
  | 'LIQUIDATION_FEE_NETWORK_SHARE_BPS_DESC'
  | 'LOW_LTV_PENALTY_FEE_NETWORK_SHARE_BPS_ASC'
  | 'LOW_LTV_PENALTY_FEE_NETWORK_SHARE_BPS_DESC'
  | 'NATURAL'
  | 'ORIGINATION_FEE_NETWORK_SHARE_BPS_ASC'
  | 'ORIGINATION_FEE_NETWORK_SHARE_BPS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SOFT_LIQUIDATION_LTV_ABORT_AT_BPS_ASC'
  | 'SOFT_LIQUIDATION_LTV_ABORT_AT_BPS_DESC'
  | 'SOFT_LIQUIDATION_LTV_THRESHOLD_BPS_ASC'
  | 'SOFT_LIQUIDATION_LTV_THRESHOLD_BPS_DESC'
  | 'TARGET_LTV_THRESHOLD_BPS_ASC'
  | 'TARGET_LTV_THRESHOLD_BPS_DESC'
  | 'TOPUP_LTV_THRESHOLD_BPS_ASC'
  | 'TOPUP_LTV_THRESHOLD_BPS_DESC';

export type LendingPool = {
  __typename?: 'LendingPool';
  addingLenderFundsEnabled: Scalars['Boolean']['output'];
  asset: ChainflipAsset;
  borrowingEnabled: Scalars['Boolean']['output'];
  interestAtJunctionBps: Scalars['Int']['output'];
  interestAtMaxUtilisationBps: Scalars['Int']['output'];
  interestAtZeroUtilisationBps: Scalars['Int']['output'];
  interestRateBps: Scalars['Int']['output'];
  junctionUtilisationBps: Scalars['Int']['output'];
  liquidationFeeBps: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `Loan`. */
  loansByAsset: LoansConnection;
  /** Reads and enables pagination through a set of `LpLendingBalance`. */
  lpLendingBalancesByAsset: LpLendingBalancesConnection;
  /** Reads a single `OraclePrice` that is related to this `LendingPool`. */
  oraclePriceByOraclePriceId: OraclePrice;
  oraclePriceId: Scalars['Int']['output'];
  originationFeeBps: Scalars['Int']['output'];
  totalAmount: Scalars['BigFloat']['output'];
  totalAmountUsd: Scalars['BigFloat']['output'];
  totalAvailableAmount: Scalars['BigFloat']['output'];
  totalAvailableAmountUsd: Scalars['BigFloat']['output'];
  totalBorrowedAmount: Scalars['BigFloat']['output'];
  totalBorrowedAmountUsd: Scalars['BigFloat']['output'];
  utilisationRateBps: Scalars['Int']['output'];
  withdrawingLenderFundsEnabled: Scalars['Boolean']['output'];
};


export type LendingPoolLoansByAssetArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LoanCondition>;
  filter?: InputMaybe<LoanFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LoansOrderBy>>;
};


export type LendingPoolLpLendingBalancesByAssetArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LpLendingBalanceCondition>;
  filter?: InputMaybe<LpLendingBalanceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LpLendingBalancesOrderBy>>;
};

export type LendingPoolAggregates = {
  __typename?: 'LendingPoolAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<LendingPoolAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<LendingPoolDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<LendingPoolMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<LendingPoolMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<LendingPoolStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<LendingPoolStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<LendingPoolSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<LendingPoolVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<LendingPoolVarianceSampleAggregates>;
};

/** A filter to be used against aggregates of `LendingPool` object types. */
export type LendingPoolAggregatesFilter = {
  /** Mean average aggregate over matching `LendingPool` objects. */
  average?: InputMaybe<LendingPoolAverageAggregateFilter>;
  /** Distinct count aggregate over matching `LendingPool` objects. */
  distinctCount?: InputMaybe<LendingPoolDistinctCountAggregateFilter>;
  /** A filter that must pass for the relevant `LendingPool` object to be included within the aggregate. */
  filter?: InputMaybe<LendingPoolFilter>;
  /** Maximum aggregate over matching `LendingPool` objects. */
  max?: InputMaybe<LendingPoolMaxAggregateFilter>;
  /** Minimum aggregate over matching `LendingPool` objects. */
  min?: InputMaybe<LendingPoolMinAggregateFilter>;
  /** Population standard deviation aggregate over matching `LendingPool` objects. */
  stddevPopulation?: InputMaybe<LendingPoolStddevPopulationAggregateFilter>;
  /** Sample standard deviation aggregate over matching `LendingPool` objects. */
  stddevSample?: InputMaybe<LendingPoolStddevSampleAggregateFilter>;
  /** Sum aggregate over matching `LendingPool` objects. */
  sum?: InputMaybe<LendingPoolSumAggregateFilter>;
  /** Population variance aggregate over matching `LendingPool` objects. */
  variancePopulation?: InputMaybe<LendingPoolVariancePopulationAggregateFilter>;
  /** Sample variance aggregate over matching `LendingPool` objects. */
  varianceSample?: InputMaybe<LendingPoolVarianceSampleAggregateFilter>;
};

export type LendingPoolAverageAggregateFilter = {
  interestAtJunctionBps?: InputMaybe<BigFloatFilter>;
  interestAtMaxUtilisationBps?: InputMaybe<BigFloatFilter>;
  interestAtZeroUtilisationBps?: InputMaybe<BigFloatFilter>;
  interestRateBps?: InputMaybe<BigFloatFilter>;
  junctionUtilisationBps?: InputMaybe<BigFloatFilter>;
  liquidationFeeBps?: InputMaybe<BigFloatFilter>;
  oraclePriceId?: InputMaybe<BigFloatFilter>;
  originationFeeBps?: InputMaybe<BigFloatFilter>;
  totalAmount?: InputMaybe<BigFloatFilter>;
  totalAmountUsd?: InputMaybe<BigFloatFilter>;
  totalAvailableAmount?: InputMaybe<BigFloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<BigFloatFilter>;
  totalBorrowedAmount?: InputMaybe<BigFloatFilter>;
  totalBorrowedAmountUsd?: InputMaybe<BigFloatFilter>;
  utilisationRateBps?: InputMaybe<BigFloatFilter>;
};

export type LendingPoolAverageAggregates = {
  __typename?: 'LendingPoolAverageAggregates';
  /** Mean average of interestAtJunctionBps across the matching connection */
  interestAtJunctionBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of interestAtMaxUtilisationBps across the matching connection */
  interestAtMaxUtilisationBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of interestAtZeroUtilisationBps across the matching connection */
  interestAtZeroUtilisationBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of interestRateBps across the matching connection */
  interestRateBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of junctionUtilisationBps across the matching connection */
  junctionUtilisationBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of liquidationFeeBps across the matching connection */
  liquidationFeeBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of oraclePriceId across the matching connection */
  oraclePriceId?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of originationFeeBps across the matching connection */
  originationFeeBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of totalAmount across the matching connection */
  totalAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of totalAmountUsd across the matching connection */
  totalAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of totalAvailableAmount across the matching connection */
  totalAvailableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of totalAvailableAmountUsd across the matching connection */
  totalAvailableAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of totalBorrowedAmount across the matching connection */
  totalBorrowedAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of totalBorrowedAmountUsd across the matching connection */
  totalBorrowedAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of utilisationRateBps across the matching connection */
  utilisationRateBps?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `LendingPool` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type LendingPoolCondition = {
  /** Checks for equality with the object’s `addingLenderFundsEnabled` field. */
  addingLenderFundsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `asset` field. */
  asset?: InputMaybe<ChainflipAsset>;
  /** Checks for equality with the object’s `borrowingEnabled` field. */
  borrowingEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `interestAtJunctionBps` field. */
  interestAtJunctionBps?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `interestAtMaxUtilisationBps` field. */
  interestAtMaxUtilisationBps?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `interestAtZeroUtilisationBps` field. */
  interestAtZeroUtilisationBps?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `interestRateBps` field. */
  interestRateBps?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `junctionUtilisationBps` field. */
  junctionUtilisationBps?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `liquidationFeeBps` field. */
  liquidationFeeBps?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `oraclePriceId` field. */
  oraclePriceId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `originationFeeBps` field. */
  originationFeeBps?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `totalAmount` field. */
  totalAmount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalAmountUsd` field. */
  totalAmountUsd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalAvailableAmount` field. */
  totalAvailableAmount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalAvailableAmountUsd` field. */
  totalAvailableAmountUsd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalBorrowedAmount` field. */
  totalBorrowedAmount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalBorrowedAmountUsd` field. */
  totalBorrowedAmountUsd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `utilisationRateBps` field. */
  utilisationRateBps?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `withdrawingLenderFundsEnabled` field. */
  withdrawingLenderFundsEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

export type LendingPoolDistinctCountAggregateFilter = {
  addingLenderFundsEnabled?: InputMaybe<BigIntFilter>;
  asset?: InputMaybe<BigIntFilter>;
  borrowingEnabled?: InputMaybe<BigIntFilter>;
  interestAtJunctionBps?: InputMaybe<BigIntFilter>;
  interestAtMaxUtilisationBps?: InputMaybe<BigIntFilter>;
  interestAtZeroUtilisationBps?: InputMaybe<BigIntFilter>;
  interestRateBps?: InputMaybe<BigIntFilter>;
  junctionUtilisationBps?: InputMaybe<BigIntFilter>;
  liquidationFeeBps?: InputMaybe<BigIntFilter>;
  oraclePriceId?: InputMaybe<BigIntFilter>;
  originationFeeBps?: InputMaybe<BigIntFilter>;
  totalAmount?: InputMaybe<BigIntFilter>;
  totalAmountUsd?: InputMaybe<BigIntFilter>;
  totalAvailableAmount?: InputMaybe<BigIntFilter>;
  totalAvailableAmountUsd?: InputMaybe<BigIntFilter>;
  totalBorrowedAmount?: InputMaybe<BigIntFilter>;
  totalBorrowedAmountUsd?: InputMaybe<BigIntFilter>;
  utilisationRateBps?: InputMaybe<BigIntFilter>;
  withdrawingLenderFundsEnabled?: InputMaybe<BigIntFilter>;
};

export type LendingPoolDistinctCountAggregates = {
  __typename?: 'LendingPoolDistinctCountAggregates';
  /** Distinct count of addingLenderFundsEnabled across the matching connection */
  addingLenderFundsEnabled?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of asset across the matching connection */
  asset?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of borrowingEnabled across the matching connection */
  borrowingEnabled?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of interestAtJunctionBps across the matching connection */
  interestAtJunctionBps?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of interestAtMaxUtilisationBps across the matching connection */
  interestAtMaxUtilisationBps?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of interestAtZeroUtilisationBps across the matching connection */
  interestAtZeroUtilisationBps?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of interestRateBps across the matching connection */
  interestRateBps?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of junctionUtilisationBps across the matching connection */
  junctionUtilisationBps?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of liquidationFeeBps across the matching connection */
  liquidationFeeBps?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of oraclePriceId across the matching connection */
  oraclePriceId?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of originationFeeBps across the matching connection */
  originationFeeBps?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of totalAmount across the matching connection */
  totalAmount?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of totalAmountUsd across the matching connection */
  totalAmountUsd?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of totalAvailableAmount across the matching connection */
  totalAvailableAmount?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of totalAvailableAmountUsd across the matching connection */
  totalAvailableAmountUsd?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of totalBorrowedAmount across the matching connection */
  totalBorrowedAmount?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of totalBorrowedAmountUsd across the matching connection */
  totalBorrowedAmountUsd?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of utilisationRateBps across the matching connection */
  utilisationRateBps?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of withdrawingLenderFundsEnabled across the matching connection */
  withdrawingLenderFundsEnabled?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `LendingPool` object types. All fields are combined with a logical ‘and.’ */
export type LendingPoolFilter = {
  /** Filter by the object’s `addingLenderFundsEnabled` field. */
  addingLenderFundsEnabled?: InputMaybe<BooleanFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<LendingPoolFilter>>;
  /** Filter by the object’s `asset` field. */
  asset?: InputMaybe<ChainflipAssetFilter>;
  /** Filter by the object’s `borrowingEnabled` field. */
  borrowingEnabled?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `interestAtJunctionBps` field. */
  interestAtJunctionBps?: InputMaybe<IntFilter>;
  /** Filter by the object’s `interestAtMaxUtilisationBps` field. */
  interestAtMaxUtilisationBps?: InputMaybe<IntFilter>;
  /** Filter by the object’s `interestAtZeroUtilisationBps` field. */
  interestAtZeroUtilisationBps?: InputMaybe<IntFilter>;
  /** Filter by the object’s `interestRateBps` field. */
  interestRateBps?: InputMaybe<IntFilter>;
  /** Filter by the object’s `junctionUtilisationBps` field. */
  junctionUtilisationBps?: InputMaybe<IntFilter>;
  /** Filter by the object’s `liquidationFeeBps` field. */
  liquidationFeeBps?: InputMaybe<IntFilter>;
  /** Filter by the object’s `loansByAsset` relation. */
  loansByAsset?: InputMaybe<LendingPoolToManyLoanFilter>;
  /** Some related `loansByAsset` exist. */
  loansByAssetExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `lpLendingBalancesByAsset` relation. */
  lpLendingBalancesByAsset?: InputMaybe<LendingPoolToManyLpLendingBalanceFilter>;
  /** Some related `lpLendingBalancesByAsset` exist. */
  lpLendingBalancesByAssetExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Negates the expression. */
  not?: InputMaybe<LendingPoolFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<LendingPoolFilter>>;
  /** Filter by the object’s `oraclePriceByOraclePriceId` relation. */
  oraclePriceByOraclePriceId?: InputMaybe<OraclePriceFilter>;
  /** Filter by the object’s `oraclePriceId` field. */
  oraclePriceId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `originationFeeBps` field. */
  originationFeeBps?: InputMaybe<IntFilter>;
  /** Filter by the object’s `totalAmount` field. */
  totalAmount?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalAmountUsd` field. */
  totalAmountUsd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalAvailableAmount` field. */
  totalAvailableAmount?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalAvailableAmountUsd` field. */
  totalAvailableAmountUsd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalBorrowedAmount` field. */
  totalBorrowedAmount?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalBorrowedAmountUsd` field. */
  totalBorrowedAmountUsd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `utilisationRateBps` field. */
  utilisationRateBps?: InputMaybe<IntFilter>;
  /** Filter by the object’s `withdrawingLenderFundsEnabled` field. */
  withdrawingLenderFundsEnabled?: InputMaybe<BooleanFilter>;
};

/** Grouping methods for `LendingPool` for usage during aggregation. */
export type LendingPoolGroupBy =
  | 'ADDING_LENDER_FUNDS_ENABLED'
  | 'BORROWING_ENABLED'
  | 'INTEREST_AT_JUNCTION_BPS'
  | 'INTEREST_AT_MAX_UTILISATION_BPS'
  | 'INTEREST_AT_ZERO_UTILISATION_BPS'
  | 'INTEREST_RATE_BPS'
  | 'JUNCTION_UTILISATION_BPS'
  | 'LIQUIDATION_FEE_BPS'
  | 'ORACLE_PRICE_ID'
  | 'ORIGINATION_FEE_BPS'
  | 'TOTAL_AMOUNT'
  | 'TOTAL_AMOUNT_USD'
  | 'TOTAL_AVAILABLE_AMOUNT'
  | 'TOTAL_AVAILABLE_AMOUNT_USD'
  | 'TOTAL_BORROWED_AMOUNT'
  | 'TOTAL_BORROWED_AMOUNT_USD'
  | 'UTILISATION_RATE_BPS'
  | 'WITHDRAWING_LENDER_FUNDS_ENABLED';

export type LendingPoolHavingAverageInput = {
  interestAtJunctionBps?: InputMaybe<HavingIntFilter>;
  interestAtMaxUtilisationBps?: InputMaybe<HavingIntFilter>;
  interestAtZeroUtilisationBps?: InputMaybe<HavingIntFilter>;
  interestRateBps?: InputMaybe<HavingIntFilter>;
  junctionUtilisationBps?: InputMaybe<HavingIntFilter>;
  liquidationFeeBps?: InputMaybe<HavingIntFilter>;
  oraclePriceId?: InputMaybe<HavingIntFilter>;
  originationFeeBps?: InputMaybe<HavingIntFilter>;
  totalAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalBorrowedAmount?: InputMaybe<HavingBigfloatFilter>;
  totalBorrowedAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  utilisationRateBps?: InputMaybe<HavingIntFilter>;
};

export type LendingPoolHavingDistinctCountInput = {
  interestAtJunctionBps?: InputMaybe<HavingIntFilter>;
  interestAtMaxUtilisationBps?: InputMaybe<HavingIntFilter>;
  interestAtZeroUtilisationBps?: InputMaybe<HavingIntFilter>;
  interestRateBps?: InputMaybe<HavingIntFilter>;
  junctionUtilisationBps?: InputMaybe<HavingIntFilter>;
  liquidationFeeBps?: InputMaybe<HavingIntFilter>;
  oraclePriceId?: InputMaybe<HavingIntFilter>;
  originationFeeBps?: InputMaybe<HavingIntFilter>;
  totalAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalBorrowedAmount?: InputMaybe<HavingBigfloatFilter>;
  totalBorrowedAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  utilisationRateBps?: InputMaybe<HavingIntFilter>;
};

/** Conditions for `LendingPool` aggregates. */
export type LendingPoolHavingInput = {
  AND?: InputMaybe<Array<LendingPoolHavingInput>>;
  OR?: InputMaybe<Array<LendingPoolHavingInput>>;
  average?: InputMaybe<LendingPoolHavingAverageInput>;
  distinctCount?: InputMaybe<LendingPoolHavingDistinctCountInput>;
  max?: InputMaybe<LendingPoolHavingMaxInput>;
  min?: InputMaybe<LendingPoolHavingMinInput>;
  stddevPopulation?: InputMaybe<LendingPoolHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<LendingPoolHavingStddevSampleInput>;
  sum?: InputMaybe<LendingPoolHavingSumInput>;
  variancePopulation?: InputMaybe<LendingPoolHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<LendingPoolHavingVarianceSampleInput>;
};

export type LendingPoolHavingMaxInput = {
  interestAtJunctionBps?: InputMaybe<HavingIntFilter>;
  interestAtMaxUtilisationBps?: InputMaybe<HavingIntFilter>;
  interestAtZeroUtilisationBps?: InputMaybe<HavingIntFilter>;
  interestRateBps?: InputMaybe<HavingIntFilter>;
  junctionUtilisationBps?: InputMaybe<HavingIntFilter>;
  liquidationFeeBps?: InputMaybe<HavingIntFilter>;
  oraclePriceId?: InputMaybe<HavingIntFilter>;
  originationFeeBps?: InputMaybe<HavingIntFilter>;
  totalAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalBorrowedAmount?: InputMaybe<HavingBigfloatFilter>;
  totalBorrowedAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  utilisationRateBps?: InputMaybe<HavingIntFilter>;
};

export type LendingPoolHavingMinInput = {
  interestAtJunctionBps?: InputMaybe<HavingIntFilter>;
  interestAtMaxUtilisationBps?: InputMaybe<HavingIntFilter>;
  interestAtZeroUtilisationBps?: InputMaybe<HavingIntFilter>;
  interestRateBps?: InputMaybe<HavingIntFilter>;
  junctionUtilisationBps?: InputMaybe<HavingIntFilter>;
  liquidationFeeBps?: InputMaybe<HavingIntFilter>;
  oraclePriceId?: InputMaybe<HavingIntFilter>;
  originationFeeBps?: InputMaybe<HavingIntFilter>;
  totalAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalBorrowedAmount?: InputMaybe<HavingBigfloatFilter>;
  totalBorrowedAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  utilisationRateBps?: InputMaybe<HavingIntFilter>;
};

export type LendingPoolHavingStddevPopulationInput = {
  interestAtJunctionBps?: InputMaybe<HavingIntFilter>;
  interestAtMaxUtilisationBps?: InputMaybe<HavingIntFilter>;
  interestAtZeroUtilisationBps?: InputMaybe<HavingIntFilter>;
  interestRateBps?: InputMaybe<HavingIntFilter>;
  junctionUtilisationBps?: InputMaybe<HavingIntFilter>;
  liquidationFeeBps?: InputMaybe<HavingIntFilter>;
  oraclePriceId?: InputMaybe<HavingIntFilter>;
  originationFeeBps?: InputMaybe<HavingIntFilter>;
  totalAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalBorrowedAmount?: InputMaybe<HavingBigfloatFilter>;
  totalBorrowedAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  utilisationRateBps?: InputMaybe<HavingIntFilter>;
};

export type LendingPoolHavingStddevSampleInput = {
  interestAtJunctionBps?: InputMaybe<HavingIntFilter>;
  interestAtMaxUtilisationBps?: InputMaybe<HavingIntFilter>;
  interestAtZeroUtilisationBps?: InputMaybe<HavingIntFilter>;
  interestRateBps?: InputMaybe<HavingIntFilter>;
  junctionUtilisationBps?: InputMaybe<HavingIntFilter>;
  liquidationFeeBps?: InputMaybe<HavingIntFilter>;
  oraclePriceId?: InputMaybe<HavingIntFilter>;
  originationFeeBps?: InputMaybe<HavingIntFilter>;
  totalAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalBorrowedAmount?: InputMaybe<HavingBigfloatFilter>;
  totalBorrowedAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  utilisationRateBps?: InputMaybe<HavingIntFilter>;
};

export type LendingPoolHavingSumInput = {
  interestAtJunctionBps?: InputMaybe<HavingIntFilter>;
  interestAtMaxUtilisationBps?: InputMaybe<HavingIntFilter>;
  interestAtZeroUtilisationBps?: InputMaybe<HavingIntFilter>;
  interestRateBps?: InputMaybe<HavingIntFilter>;
  junctionUtilisationBps?: InputMaybe<HavingIntFilter>;
  liquidationFeeBps?: InputMaybe<HavingIntFilter>;
  oraclePriceId?: InputMaybe<HavingIntFilter>;
  originationFeeBps?: InputMaybe<HavingIntFilter>;
  totalAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalBorrowedAmount?: InputMaybe<HavingBigfloatFilter>;
  totalBorrowedAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  utilisationRateBps?: InputMaybe<HavingIntFilter>;
};

export type LendingPoolHavingVariancePopulationInput = {
  interestAtJunctionBps?: InputMaybe<HavingIntFilter>;
  interestAtMaxUtilisationBps?: InputMaybe<HavingIntFilter>;
  interestAtZeroUtilisationBps?: InputMaybe<HavingIntFilter>;
  interestRateBps?: InputMaybe<HavingIntFilter>;
  junctionUtilisationBps?: InputMaybe<HavingIntFilter>;
  liquidationFeeBps?: InputMaybe<HavingIntFilter>;
  oraclePriceId?: InputMaybe<HavingIntFilter>;
  originationFeeBps?: InputMaybe<HavingIntFilter>;
  totalAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalBorrowedAmount?: InputMaybe<HavingBigfloatFilter>;
  totalBorrowedAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  utilisationRateBps?: InputMaybe<HavingIntFilter>;
};

export type LendingPoolHavingVarianceSampleInput = {
  interestAtJunctionBps?: InputMaybe<HavingIntFilter>;
  interestAtMaxUtilisationBps?: InputMaybe<HavingIntFilter>;
  interestAtZeroUtilisationBps?: InputMaybe<HavingIntFilter>;
  interestRateBps?: InputMaybe<HavingIntFilter>;
  junctionUtilisationBps?: InputMaybe<HavingIntFilter>;
  liquidationFeeBps?: InputMaybe<HavingIntFilter>;
  oraclePriceId?: InputMaybe<HavingIntFilter>;
  originationFeeBps?: InputMaybe<HavingIntFilter>;
  totalAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalBorrowedAmount?: InputMaybe<HavingBigfloatFilter>;
  totalBorrowedAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  utilisationRateBps?: InputMaybe<HavingIntFilter>;
};

export type LendingPoolMaxAggregateFilter = {
  interestAtJunctionBps?: InputMaybe<IntFilter>;
  interestAtMaxUtilisationBps?: InputMaybe<IntFilter>;
  interestAtZeroUtilisationBps?: InputMaybe<IntFilter>;
  interestRateBps?: InputMaybe<IntFilter>;
  junctionUtilisationBps?: InputMaybe<IntFilter>;
  liquidationFeeBps?: InputMaybe<IntFilter>;
  oraclePriceId?: InputMaybe<IntFilter>;
  originationFeeBps?: InputMaybe<IntFilter>;
  totalAmount?: InputMaybe<BigFloatFilter>;
  totalAmountUsd?: InputMaybe<BigFloatFilter>;
  totalAvailableAmount?: InputMaybe<BigFloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<BigFloatFilter>;
  totalBorrowedAmount?: InputMaybe<BigFloatFilter>;
  totalBorrowedAmountUsd?: InputMaybe<BigFloatFilter>;
  utilisationRateBps?: InputMaybe<IntFilter>;
};

export type LendingPoolMaxAggregates = {
  __typename?: 'LendingPoolMaxAggregates';
  /** Maximum of interestAtJunctionBps across the matching connection */
  interestAtJunctionBps?: Maybe<Scalars['Int']['output']>;
  /** Maximum of interestAtMaxUtilisationBps across the matching connection */
  interestAtMaxUtilisationBps?: Maybe<Scalars['Int']['output']>;
  /** Maximum of interestAtZeroUtilisationBps across the matching connection */
  interestAtZeroUtilisationBps?: Maybe<Scalars['Int']['output']>;
  /** Maximum of interestRateBps across the matching connection */
  interestRateBps?: Maybe<Scalars['Int']['output']>;
  /** Maximum of junctionUtilisationBps across the matching connection */
  junctionUtilisationBps?: Maybe<Scalars['Int']['output']>;
  /** Maximum of liquidationFeeBps across the matching connection */
  liquidationFeeBps?: Maybe<Scalars['Int']['output']>;
  /** Maximum of oraclePriceId across the matching connection */
  oraclePriceId?: Maybe<Scalars['Int']['output']>;
  /** Maximum of originationFeeBps across the matching connection */
  originationFeeBps?: Maybe<Scalars['Int']['output']>;
  /** Maximum of totalAmount across the matching connection */
  totalAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of totalAmountUsd across the matching connection */
  totalAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of totalAvailableAmount across the matching connection */
  totalAvailableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of totalAvailableAmountUsd across the matching connection */
  totalAvailableAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of totalBorrowedAmount across the matching connection */
  totalBorrowedAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of totalBorrowedAmountUsd across the matching connection */
  totalBorrowedAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of utilisationRateBps across the matching connection */
  utilisationRateBps?: Maybe<Scalars['Int']['output']>;
};

export type LendingPoolMinAggregateFilter = {
  interestAtJunctionBps?: InputMaybe<IntFilter>;
  interestAtMaxUtilisationBps?: InputMaybe<IntFilter>;
  interestAtZeroUtilisationBps?: InputMaybe<IntFilter>;
  interestRateBps?: InputMaybe<IntFilter>;
  junctionUtilisationBps?: InputMaybe<IntFilter>;
  liquidationFeeBps?: InputMaybe<IntFilter>;
  oraclePriceId?: InputMaybe<IntFilter>;
  originationFeeBps?: InputMaybe<IntFilter>;
  totalAmount?: InputMaybe<BigFloatFilter>;
  totalAmountUsd?: InputMaybe<BigFloatFilter>;
  totalAvailableAmount?: InputMaybe<BigFloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<BigFloatFilter>;
  totalBorrowedAmount?: InputMaybe<BigFloatFilter>;
  totalBorrowedAmountUsd?: InputMaybe<BigFloatFilter>;
  utilisationRateBps?: InputMaybe<IntFilter>;
};

export type LendingPoolMinAggregates = {
  __typename?: 'LendingPoolMinAggregates';
  /** Minimum of interestAtJunctionBps across the matching connection */
  interestAtJunctionBps?: Maybe<Scalars['Int']['output']>;
  /** Minimum of interestAtMaxUtilisationBps across the matching connection */
  interestAtMaxUtilisationBps?: Maybe<Scalars['Int']['output']>;
  /** Minimum of interestAtZeroUtilisationBps across the matching connection */
  interestAtZeroUtilisationBps?: Maybe<Scalars['Int']['output']>;
  /** Minimum of interestRateBps across the matching connection */
  interestRateBps?: Maybe<Scalars['Int']['output']>;
  /** Minimum of junctionUtilisationBps across the matching connection */
  junctionUtilisationBps?: Maybe<Scalars['Int']['output']>;
  /** Minimum of liquidationFeeBps across the matching connection */
  liquidationFeeBps?: Maybe<Scalars['Int']['output']>;
  /** Minimum of oraclePriceId across the matching connection */
  oraclePriceId?: Maybe<Scalars['Int']['output']>;
  /** Minimum of originationFeeBps across the matching connection */
  originationFeeBps?: Maybe<Scalars['Int']['output']>;
  /** Minimum of totalAmount across the matching connection */
  totalAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of totalAmountUsd across the matching connection */
  totalAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of totalAvailableAmount across the matching connection */
  totalAvailableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of totalAvailableAmountUsd across the matching connection */
  totalAvailableAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of totalBorrowedAmount across the matching connection */
  totalBorrowedAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of totalBorrowedAmountUsd across the matching connection */
  totalBorrowedAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of utilisationRateBps across the matching connection */
  utilisationRateBps?: Maybe<Scalars['Int']['output']>;
};

export type LendingPoolStddevPopulationAggregateFilter = {
  interestAtJunctionBps?: InputMaybe<BigFloatFilter>;
  interestAtMaxUtilisationBps?: InputMaybe<BigFloatFilter>;
  interestAtZeroUtilisationBps?: InputMaybe<BigFloatFilter>;
  interestRateBps?: InputMaybe<BigFloatFilter>;
  junctionUtilisationBps?: InputMaybe<BigFloatFilter>;
  liquidationFeeBps?: InputMaybe<BigFloatFilter>;
  oraclePriceId?: InputMaybe<BigFloatFilter>;
  originationFeeBps?: InputMaybe<BigFloatFilter>;
  totalAmount?: InputMaybe<BigFloatFilter>;
  totalAmountUsd?: InputMaybe<BigFloatFilter>;
  totalAvailableAmount?: InputMaybe<BigFloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<BigFloatFilter>;
  totalBorrowedAmount?: InputMaybe<BigFloatFilter>;
  totalBorrowedAmountUsd?: InputMaybe<BigFloatFilter>;
  utilisationRateBps?: InputMaybe<BigFloatFilter>;
};

export type LendingPoolStddevPopulationAggregates = {
  __typename?: 'LendingPoolStddevPopulationAggregates';
  /** Population standard deviation of interestAtJunctionBps across the matching connection */
  interestAtJunctionBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of interestAtMaxUtilisationBps across the matching connection */
  interestAtMaxUtilisationBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of interestAtZeroUtilisationBps across the matching connection */
  interestAtZeroUtilisationBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of interestRateBps across the matching connection */
  interestRateBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of junctionUtilisationBps across the matching connection */
  junctionUtilisationBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of liquidationFeeBps across the matching connection */
  liquidationFeeBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of oraclePriceId across the matching connection */
  oraclePriceId?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of originationFeeBps across the matching connection */
  originationFeeBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of totalAmount across the matching connection */
  totalAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of totalAmountUsd across the matching connection */
  totalAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of totalAvailableAmount across the matching connection */
  totalAvailableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of totalAvailableAmountUsd across the matching connection */
  totalAvailableAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of totalBorrowedAmount across the matching connection */
  totalBorrowedAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of totalBorrowedAmountUsd across the matching connection */
  totalBorrowedAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of utilisationRateBps across the matching connection */
  utilisationRateBps?: Maybe<Scalars['BigFloat']['output']>;
};

export type LendingPoolStddevSampleAggregateFilter = {
  interestAtJunctionBps?: InputMaybe<BigFloatFilter>;
  interestAtMaxUtilisationBps?: InputMaybe<BigFloatFilter>;
  interestAtZeroUtilisationBps?: InputMaybe<BigFloatFilter>;
  interestRateBps?: InputMaybe<BigFloatFilter>;
  junctionUtilisationBps?: InputMaybe<BigFloatFilter>;
  liquidationFeeBps?: InputMaybe<BigFloatFilter>;
  oraclePriceId?: InputMaybe<BigFloatFilter>;
  originationFeeBps?: InputMaybe<BigFloatFilter>;
  totalAmount?: InputMaybe<BigFloatFilter>;
  totalAmountUsd?: InputMaybe<BigFloatFilter>;
  totalAvailableAmount?: InputMaybe<BigFloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<BigFloatFilter>;
  totalBorrowedAmount?: InputMaybe<BigFloatFilter>;
  totalBorrowedAmountUsd?: InputMaybe<BigFloatFilter>;
  utilisationRateBps?: InputMaybe<BigFloatFilter>;
};

export type LendingPoolStddevSampleAggregates = {
  __typename?: 'LendingPoolStddevSampleAggregates';
  /** Sample standard deviation of interestAtJunctionBps across the matching connection */
  interestAtJunctionBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of interestAtMaxUtilisationBps across the matching connection */
  interestAtMaxUtilisationBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of interestAtZeroUtilisationBps across the matching connection */
  interestAtZeroUtilisationBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of interestRateBps across the matching connection */
  interestRateBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of junctionUtilisationBps across the matching connection */
  junctionUtilisationBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of liquidationFeeBps across the matching connection */
  liquidationFeeBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of oraclePriceId across the matching connection */
  oraclePriceId?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of originationFeeBps across the matching connection */
  originationFeeBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of totalAmount across the matching connection */
  totalAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of totalAmountUsd across the matching connection */
  totalAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of totalAvailableAmount across the matching connection */
  totalAvailableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of totalAvailableAmountUsd across the matching connection */
  totalAvailableAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of totalBorrowedAmount across the matching connection */
  totalBorrowedAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of totalBorrowedAmountUsd across the matching connection */
  totalBorrowedAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of utilisationRateBps across the matching connection */
  utilisationRateBps?: Maybe<Scalars['BigFloat']['output']>;
};

export type LendingPoolSumAggregateFilter = {
  interestAtJunctionBps?: InputMaybe<BigIntFilter>;
  interestAtMaxUtilisationBps?: InputMaybe<BigIntFilter>;
  interestAtZeroUtilisationBps?: InputMaybe<BigIntFilter>;
  interestRateBps?: InputMaybe<BigIntFilter>;
  junctionUtilisationBps?: InputMaybe<BigIntFilter>;
  liquidationFeeBps?: InputMaybe<BigIntFilter>;
  oraclePriceId?: InputMaybe<BigIntFilter>;
  originationFeeBps?: InputMaybe<BigIntFilter>;
  totalAmount?: InputMaybe<BigFloatFilter>;
  totalAmountUsd?: InputMaybe<BigFloatFilter>;
  totalAvailableAmount?: InputMaybe<BigFloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<BigFloatFilter>;
  totalBorrowedAmount?: InputMaybe<BigFloatFilter>;
  totalBorrowedAmountUsd?: InputMaybe<BigFloatFilter>;
  utilisationRateBps?: InputMaybe<BigIntFilter>;
};

export type LendingPoolSumAggregates = {
  __typename?: 'LendingPoolSumAggregates';
  /** Sum of interestAtJunctionBps across the matching connection */
  interestAtJunctionBps: Scalars['BigInt']['output'];
  /** Sum of interestAtMaxUtilisationBps across the matching connection */
  interestAtMaxUtilisationBps: Scalars['BigInt']['output'];
  /** Sum of interestAtZeroUtilisationBps across the matching connection */
  interestAtZeroUtilisationBps: Scalars['BigInt']['output'];
  /** Sum of interestRateBps across the matching connection */
  interestRateBps: Scalars['BigInt']['output'];
  /** Sum of junctionUtilisationBps across the matching connection */
  junctionUtilisationBps: Scalars['BigInt']['output'];
  /** Sum of liquidationFeeBps across the matching connection */
  liquidationFeeBps: Scalars['BigInt']['output'];
  /** Sum of oraclePriceId across the matching connection */
  oraclePriceId: Scalars['BigInt']['output'];
  /** Sum of originationFeeBps across the matching connection */
  originationFeeBps: Scalars['BigInt']['output'];
  /** Sum of totalAmount across the matching connection */
  totalAmount: Scalars['BigFloat']['output'];
  /** Sum of totalAmountUsd across the matching connection */
  totalAmountUsd: Scalars['BigFloat']['output'];
  /** Sum of totalAvailableAmount across the matching connection */
  totalAvailableAmount: Scalars['BigFloat']['output'];
  /** Sum of totalAvailableAmountUsd across the matching connection */
  totalAvailableAmountUsd: Scalars['BigFloat']['output'];
  /** Sum of totalBorrowedAmount across the matching connection */
  totalBorrowedAmount: Scalars['BigFloat']['output'];
  /** Sum of totalBorrowedAmountUsd across the matching connection */
  totalBorrowedAmountUsd: Scalars['BigFloat']['output'];
  /** Sum of utilisationRateBps across the matching connection */
  utilisationRateBps: Scalars['BigInt']['output'];
};

/** A filter to be used against many `Loan` object types. All fields are combined with a logical ‘and.’ */
export type LendingPoolToManyLoanFilter = {
  /** Aggregates across related `Loan` match the filter criteria. */
  aggregates?: InputMaybe<LoanAggregatesFilter>;
  /** Every related `Loan` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<LoanFilter>;
  /** No related `Loan` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<LoanFilter>;
  /** Some related `Loan` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<LoanFilter>;
};

/** A filter to be used against many `LpLendingBalance` object types. All fields are combined with a logical ‘and.’ */
export type LendingPoolToManyLpLendingBalanceFilter = {
  /** Aggregates across related `LpLendingBalance` match the filter criteria. */
  aggregates?: InputMaybe<LpLendingBalanceAggregatesFilter>;
  /** Every related `LpLendingBalance` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<LpLendingBalanceFilter>;
  /** No related `LpLendingBalance` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<LpLendingBalanceFilter>;
  /** Some related `LpLendingBalance` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<LpLendingBalanceFilter>;
};

export type LendingPoolVariancePopulationAggregateFilter = {
  interestAtJunctionBps?: InputMaybe<BigFloatFilter>;
  interestAtMaxUtilisationBps?: InputMaybe<BigFloatFilter>;
  interestAtZeroUtilisationBps?: InputMaybe<BigFloatFilter>;
  interestRateBps?: InputMaybe<BigFloatFilter>;
  junctionUtilisationBps?: InputMaybe<BigFloatFilter>;
  liquidationFeeBps?: InputMaybe<BigFloatFilter>;
  oraclePriceId?: InputMaybe<BigFloatFilter>;
  originationFeeBps?: InputMaybe<BigFloatFilter>;
  totalAmount?: InputMaybe<BigFloatFilter>;
  totalAmountUsd?: InputMaybe<BigFloatFilter>;
  totalAvailableAmount?: InputMaybe<BigFloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<BigFloatFilter>;
  totalBorrowedAmount?: InputMaybe<BigFloatFilter>;
  totalBorrowedAmountUsd?: InputMaybe<BigFloatFilter>;
  utilisationRateBps?: InputMaybe<BigFloatFilter>;
};

export type LendingPoolVariancePopulationAggregates = {
  __typename?: 'LendingPoolVariancePopulationAggregates';
  /** Population variance of interestAtJunctionBps across the matching connection */
  interestAtJunctionBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of interestAtMaxUtilisationBps across the matching connection */
  interestAtMaxUtilisationBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of interestAtZeroUtilisationBps across the matching connection */
  interestAtZeroUtilisationBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of interestRateBps across the matching connection */
  interestRateBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of junctionUtilisationBps across the matching connection */
  junctionUtilisationBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of liquidationFeeBps across the matching connection */
  liquidationFeeBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of oraclePriceId across the matching connection */
  oraclePriceId?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of originationFeeBps across the matching connection */
  originationFeeBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of totalAmount across the matching connection */
  totalAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of totalAmountUsd across the matching connection */
  totalAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of totalAvailableAmount across the matching connection */
  totalAvailableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of totalAvailableAmountUsd across the matching connection */
  totalAvailableAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of totalBorrowedAmount across the matching connection */
  totalBorrowedAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of totalBorrowedAmountUsd across the matching connection */
  totalBorrowedAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of utilisationRateBps across the matching connection */
  utilisationRateBps?: Maybe<Scalars['BigFloat']['output']>;
};

export type LendingPoolVarianceSampleAggregateFilter = {
  interestAtJunctionBps?: InputMaybe<BigFloatFilter>;
  interestAtMaxUtilisationBps?: InputMaybe<BigFloatFilter>;
  interestAtZeroUtilisationBps?: InputMaybe<BigFloatFilter>;
  interestRateBps?: InputMaybe<BigFloatFilter>;
  junctionUtilisationBps?: InputMaybe<BigFloatFilter>;
  liquidationFeeBps?: InputMaybe<BigFloatFilter>;
  oraclePriceId?: InputMaybe<BigFloatFilter>;
  originationFeeBps?: InputMaybe<BigFloatFilter>;
  totalAmount?: InputMaybe<BigFloatFilter>;
  totalAmountUsd?: InputMaybe<BigFloatFilter>;
  totalAvailableAmount?: InputMaybe<BigFloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<BigFloatFilter>;
  totalBorrowedAmount?: InputMaybe<BigFloatFilter>;
  totalBorrowedAmountUsd?: InputMaybe<BigFloatFilter>;
  utilisationRateBps?: InputMaybe<BigFloatFilter>;
};

export type LendingPoolVarianceSampleAggregates = {
  __typename?: 'LendingPoolVarianceSampleAggregates';
  /** Sample variance of interestAtJunctionBps across the matching connection */
  interestAtJunctionBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of interestAtMaxUtilisationBps across the matching connection */
  interestAtMaxUtilisationBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of interestAtZeroUtilisationBps across the matching connection */
  interestAtZeroUtilisationBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of interestRateBps across the matching connection */
  interestRateBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of junctionUtilisationBps across the matching connection */
  junctionUtilisationBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of liquidationFeeBps across the matching connection */
  liquidationFeeBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of oraclePriceId across the matching connection */
  oraclePriceId?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of originationFeeBps across the matching connection */
  originationFeeBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of totalAmount across the matching connection */
  totalAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of totalAmountUsd across the matching connection */
  totalAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of totalAvailableAmount across the matching connection */
  totalAvailableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of totalAvailableAmountUsd across the matching connection */
  totalAvailableAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of totalBorrowedAmount across the matching connection */
  totalBorrowedAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of totalBorrowedAmountUsd across the matching connection */
  totalBorrowedAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of utilisationRateBps across the matching connection */
  utilisationRateBps?: Maybe<Scalars['BigFloat']['output']>;
};

/** A connection to a list of `LendingPool` values. */
export type LendingPoolsConnection = {
  __typename?: 'LendingPoolsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<LendingPoolAggregates>;
  /** A list of edges which contains the `LendingPool` and cursor to aid in pagination. */
  edges: Array<LendingPoolsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<LendingPoolAggregates>>;
  /** A list of `LendingPool` objects. */
  nodes: Array<LendingPool>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `LendingPool` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `LendingPool` values. */
export type LendingPoolsConnectionGroupedAggregatesArgs = {
  groupBy: Array<LendingPoolGroupBy>;
  having?: InputMaybe<LendingPoolHavingInput>;
};

/** A `LendingPool` edge in the connection. */
export type LendingPoolsEdge = {
  __typename?: 'LendingPoolsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `LendingPool` at the end of the edge. */
  node: LendingPool;
};

/** Methods to use when ordering `LendingPool`. */
export type LendingPoolsOrderBy =
  | 'ADDING_LENDER_FUNDS_ENABLED_ASC'
  | 'ADDING_LENDER_FUNDS_ENABLED_DESC'
  | 'ASSET_ASC'
  | 'ASSET_DESC'
  | 'BORROWING_ENABLED_ASC'
  | 'BORROWING_ENABLED_DESC'
  | 'INTEREST_AT_JUNCTION_BPS_ASC'
  | 'INTEREST_AT_JUNCTION_BPS_DESC'
  | 'INTEREST_AT_MAX_UTILISATION_BPS_ASC'
  | 'INTEREST_AT_MAX_UTILISATION_BPS_DESC'
  | 'INTEREST_AT_ZERO_UTILISATION_BPS_ASC'
  | 'INTEREST_AT_ZERO_UTILISATION_BPS_DESC'
  | 'INTEREST_RATE_BPS_ASC'
  | 'INTEREST_RATE_BPS_DESC'
  | 'JUNCTION_UTILISATION_BPS_ASC'
  | 'JUNCTION_UTILISATION_BPS_DESC'
  | 'LIQUIDATION_FEE_BPS_ASC'
  | 'LIQUIDATION_FEE_BPS_DESC'
  | 'LOANS_BY_ASSET_AVERAGE_ASSET_ASC'
  | 'LOANS_BY_ASSET_AVERAGE_ASSET_DESC'
  | 'LOANS_BY_ASSET_AVERAGE_CREATED_AT_BLOCK_INDEX_ASC'
  | 'LOANS_BY_ASSET_AVERAGE_CREATED_AT_BLOCK_INDEX_DESC'
  | 'LOANS_BY_ASSET_AVERAGE_ID_ASC'
  | 'LOANS_BY_ASSET_AVERAGE_ID_DESC'
  | 'LOANS_BY_ASSET_AVERAGE_LOAN_ACCOUNT_LP_ID_SS58_ASC'
  | 'LOANS_BY_ASSET_AVERAGE_LOAN_ACCOUNT_LP_ID_SS58_DESC'
  | 'LOANS_BY_ASSET_AVERAGE_PRINCIPAL_AMOUNT_ASC'
  | 'LOANS_BY_ASSET_AVERAGE_PRINCIPAL_AMOUNT_DESC'
  | 'LOANS_BY_ASSET_AVERAGE_PRINCIPAL_AMOUNT_USD_ASC'
  | 'LOANS_BY_ASSET_AVERAGE_PRINCIPAL_AMOUNT_USD_DESC'
  | 'LOANS_BY_ASSET_AVERAGE_STATUS_ASC'
  | 'LOANS_BY_ASSET_AVERAGE_STATUS_DESC'
  | 'LOANS_BY_ASSET_COUNT_ASC'
  | 'LOANS_BY_ASSET_COUNT_DESC'
  | 'LOANS_BY_ASSET_DISTINCT_COUNT_ASSET_ASC'
  | 'LOANS_BY_ASSET_DISTINCT_COUNT_ASSET_DESC'
  | 'LOANS_BY_ASSET_DISTINCT_COUNT_CREATED_AT_BLOCK_INDEX_ASC'
  | 'LOANS_BY_ASSET_DISTINCT_COUNT_CREATED_AT_BLOCK_INDEX_DESC'
  | 'LOANS_BY_ASSET_DISTINCT_COUNT_ID_ASC'
  | 'LOANS_BY_ASSET_DISTINCT_COUNT_ID_DESC'
  | 'LOANS_BY_ASSET_DISTINCT_COUNT_LOAN_ACCOUNT_LP_ID_SS58_ASC'
  | 'LOANS_BY_ASSET_DISTINCT_COUNT_LOAN_ACCOUNT_LP_ID_SS58_DESC'
  | 'LOANS_BY_ASSET_DISTINCT_COUNT_PRINCIPAL_AMOUNT_ASC'
  | 'LOANS_BY_ASSET_DISTINCT_COUNT_PRINCIPAL_AMOUNT_DESC'
  | 'LOANS_BY_ASSET_DISTINCT_COUNT_PRINCIPAL_AMOUNT_USD_ASC'
  | 'LOANS_BY_ASSET_DISTINCT_COUNT_PRINCIPAL_AMOUNT_USD_DESC'
  | 'LOANS_BY_ASSET_DISTINCT_COUNT_STATUS_ASC'
  | 'LOANS_BY_ASSET_DISTINCT_COUNT_STATUS_DESC'
  | 'LOANS_BY_ASSET_MAX_ASSET_ASC'
  | 'LOANS_BY_ASSET_MAX_ASSET_DESC'
  | 'LOANS_BY_ASSET_MAX_CREATED_AT_BLOCK_INDEX_ASC'
  | 'LOANS_BY_ASSET_MAX_CREATED_AT_BLOCK_INDEX_DESC'
  | 'LOANS_BY_ASSET_MAX_ID_ASC'
  | 'LOANS_BY_ASSET_MAX_ID_DESC'
  | 'LOANS_BY_ASSET_MAX_LOAN_ACCOUNT_LP_ID_SS58_ASC'
  | 'LOANS_BY_ASSET_MAX_LOAN_ACCOUNT_LP_ID_SS58_DESC'
  | 'LOANS_BY_ASSET_MAX_PRINCIPAL_AMOUNT_ASC'
  | 'LOANS_BY_ASSET_MAX_PRINCIPAL_AMOUNT_DESC'
  | 'LOANS_BY_ASSET_MAX_PRINCIPAL_AMOUNT_USD_ASC'
  | 'LOANS_BY_ASSET_MAX_PRINCIPAL_AMOUNT_USD_DESC'
  | 'LOANS_BY_ASSET_MAX_STATUS_ASC'
  | 'LOANS_BY_ASSET_MAX_STATUS_DESC'
  | 'LOANS_BY_ASSET_MIN_ASSET_ASC'
  | 'LOANS_BY_ASSET_MIN_ASSET_DESC'
  | 'LOANS_BY_ASSET_MIN_CREATED_AT_BLOCK_INDEX_ASC'
  | 'LOANS_BY_ASSET_MIN_CREATED_AT_BLOCK_INDEX_DESC'
  | 'LOANS_BY_ASSET_MIN_ID_ASC'
  | 'LOANS_BY_ASSET_MIN_ID_DESC'
  | 'LOANS_BY_ASSET_MIN_LOAN_ACCOUNT_LP_ID_SS58_ASC'
  | 'LOANS_BY_ASSET_MIN_LOAN_ACCOUNT_LP_ID_SS58_DESC'
  | 'LOANS_BY_ASSET_MIN_PRINCIPAL_AMOUNT_ASC'
  | 'LOANS_BY_ASSET_MIN_PRINCIPAL_AMOUNT_DESC'
  | 'LOANS_BY_ASSET_MIN_PRINCIPAL_AMOUNT_USD_ASC'
  | 'LOANS_BY_ASSET_MIN_PRINCIPAL_AMOUNT_USD_DESC'
  | 'LOANS_BY_ASSET_MIN_STATUS_ASC'
  | 'LOANS_BY_ASSET_MIN_STATUS_DESC'
  | 'LOANS_BY_ASSET_STDDEV_POPULATION_ASSET_ASC'
  | 'LOANS_BY_ASSET_STDDEV_POPULATION_ASSET_DESC'
  | 'LOANS_BY_ASSET_STDDEV_POPULATION_CREATED_AT_BLOCK_INDEX_ASC'
  | 'LOANS_BY_ASSET_STDDEV_POPULATION_CREATED_AT_BLOCK_INDEX_DESC'
  | 'LOANS_BY_ASSET_STDDEV_POPULATION_ID_ASC'
  | 'LOANS_BY_ASSET_STDDEV_POPULATION_ID_DESC'
  | 'LOANS_BY_ASSET_STDDEV_POPULATION_LOAN_ACCOUNT_LP_ID_SS58_ASC'
  | 'LOANS_BY_ASSET_STDDEV_POPULATION_LOAN_ACCOUNT_LP_ID_SS58_DESC'
  | 'LOANS_BY_ASSET_STDDEV_POPULATION_PRINCIPAL_AMOUNT_ASC'
  | 'LOANS_BY_ASSET_STDDEV_POPULATION_PRINCIPAL_AMOUNT_DESC'
  | 'LOANS_BY_ASSET_STDDEV_POPULATION_PRINCIPAL_AMOUNT_USD_ASC'
  | 'LOANS_BY_ASSET_STDDEV_POPULATION_PRINCIPAL_AMOUNT_USD_DESC'
  | 'LOANS_BY_ASSET_STDDEV_POPULATION_STATUS_ASC'
  | 'LOANS_BY_ASSET_STDDEV_POPULATION_STATUS_DESC'
  | 'LOANS_BY_ASSET_STDDEV_SAMPLE_ASSET_ASC'
  | 'LOANS_BY_ASSET_STDDEV_SAMPLE_ASSET_DESC'
  | 'LOANS_BY_ASSET_STDDEV_SAMPLE_CREATED_AT_BLOCK_INDEX_ASC'
  | 'LOANS_BY_ASSET_STDDEV_SAMPLE_CREATED_AT_BLOCK_INDEX_DESC'
  | 'LOANS_BY_ASSET_STDDEV_SAMPLE_ID_ASC'
  | 'LOANS_BY_ASSET_STDDEV_SAMPLE_ID_DESC'
  | 'LOANS_BY_ASSET_STDDEV_SAMPLE_LOAN_ACCOUNT_LP_ID_SS58_ASC'
  | 'LOANS_BY_ASSET_STDDEV_SAMPLE_LOAN_ACCOUNT_LP_ID_SS58_DESC'
  | 'LOANS_BY_ASSET_STDDEV_SAMPLE_PRINCIPAL_AMOUNT_ASC'
  | 'LOANS_BY_ASSET_STDDEV_SAMPLE_PRINCIPAL_AMOUNT_DESC'
  | 'LOANS_BY_ASSET_STDDEV_SAMPLE_PRINCIPAL_AMOUNT_USD_ASC'
  | 'LOANS_BY_ASSET_STDDEV_SAMPLE_PRINCIPAL_AMOUNT_USD_DESC'
  | 'LOANS_BY_ASSET_STDDEV_SAMPLE_STATUS_ASC'
  | 'LOANS_BY_ASSET_STDDEV_SAMPLE_STATUS_DESC'
  | 'LOANS_BY_ASSET_SUM_ASSET_ASC'
  | 'LOANS_BY_ASSET_SUM_ASSET_DESC'
  | 'LOANS_BY_ASSET_SUM_CREATED_AT_BLOCK_INDEX_ASC'
  | 'LOANS_BY_ASSET_SUM_CREATED_AT_BLOCK_INDEX_DESC'
  | 'LOANS_BY_ASSET_SUM_ID_ASC'
  | 'LOANS_BY_ASSET_SUM_ID_DESC'
  | 'LOANS_BY_ASSET_SUM_LOAN_ACCOUNT_LP_ID_SS58_ASC'
  | 'LOANS_BY_ASSET_SUM_LOAN_ACCOUNT_LP_ID_SS58_DESC'
  | 'LOANS_BY_ASSET_SUM_PRINCIPAL_AMOUNT_ASC'
  | 'LOANS_BY_ASSET_SUM_PRINCIPAL_AMOUNT_DESC'
  | 'LOANS_BY_ASSET_SUM_PRINCIPAL_AMOUNT_USD_ASC'
  | 'LOANS_BY_ASSET_SUM_PRINCIPAL_AMOUNT_USD_DESC'
  | 'LOANS_BY_ASSET_SUM_STATUS_ASC'
  | 'LOANS_BY_ASSET_SUM_STATUS_DESC'
  | 'LOANS_BY_ASSET_VARIANCE_POPULATION_ASSET_ASC'
  | 'LOANS_BY_ASSET_VARIANCE_POPULATION_ASSET_DESC'
  | 'LOANS_BY_ASSET_VARIANCE_POPULATION_CREATED_AT_BLOCK_INDEX_ASC'
  | 'LOANS_BY_ASSET_VARIANCE_POPULATION_CREATED_AT_BLOCK_INDEX_DESC'
  | 'LOANS_BY_ASSET_VARIANCE_POPULATION_ID_ASC'
  | 'LOANS_BY_ASSET_VARIANCE_POPULATION_ID_DESC'
  | 'LOANS_BY_ASSET_VARIANCE_POPULATION_LOAN_ACCOUNT_LP_ID_SS58_ASC'
  | 'LOANS_BY_ASSET_VARIANCE_POPULATION_LOAN_ACCOUNT_LP_ID_SS58_DESC'
  | 'LOANS_BY_ASSET_VARIANCE_POPULATION_PRINCIPAL_AMOUNT_ASC'
  | 'LOANS_BY_ASSET_VARIANCE_POPULATION_PRINCIPAL_AMOUNT_DESC'
  | 'LOANS_BY_ASSET_VARIANCE_POPULATION_PRINCIPAL_AMOUNT_USD_ASC'
  | 'LOANS_BY_ASSET_VARIANCE_POPULATION_PRINCIPAL_AMOUNT_USD_DESC'
  | 'LOANS_BY_ASSET_VARIANCE_POPULATION_STATUS_ASC'
  | 'LOANS_BY_ASSET_VARIANCE_POPULATION_STATUS_DESC'
  | 'LOANS_BY_ASSET_VARIANCE_SAMPLE_ASSET_ASC'
  | 'LOANS_BY_ASSET_VARIANCE_SAMPLE_ASSET_DESC'
  | 'LOANS_BY_ASSET_VARIANCE_SAMPLE_CREATED_AT_BLOCK_INDEX_ASC'
  | 'LOANS_BY_ASSET_VARIANCE_SAMPLE_CREATED_AT_BLOCK_INDEX_DESC'
  | 'LOANS_BY_ASSET_VARIANCE_SAMPLE_ID_ASC'
  | 'LOANS_BY_ASSET_VARIANCE_SAMPLE_ID_DESC'
  | 'LOANS_BY_ASSET_VARIANCE_SAMPLE_LOAN_ACCOUNT_LP_ID_SS58_ASC'
  | 'LOANS_BY_ASSET_VARIANCE_SAMPLE_LOAN_ACCOUNT_LP_ID_SS58_DESC'
  | 'LOANS_BY_ASSET_VARIANCE_SAMPLE_PRINCIPAL_AMOUNT_ASC'
  | 'LOANS_BY_ASSET_VARIANCE_SAMPLE_PRINCIPAL_AMOUNT_DESC'
  | 'LOANS_BY_ASSET_VARIANCE_SAMPLE_PRINCIPAL_AMOUNT_USD_ASC'
  | 'LOANS_BY_ASSET_VARIANCE_SAMPLE_PRINCIPAL_AMOUNT_USD_DESC'
  | 'LOANS_BY_ASSET_VARIANCE_SAMPLE_STATUS_ASC'
  | 'LOANS_BY_ASSET_VARIANCE_SAMPLE_STATUS_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_AVERAGE_ASSET_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_AVERAGE_ASSET_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_AVERAGE_LP_ID_SS58_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_AVERAGE_LP_ID_SS58_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_AVERAGE_POOL_SHARE_PERCENT_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_AVERAGE_POOL_SHARE_PERCENT_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_AVERAGE_TOTAL_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_AVERAGE_TOTAL_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_AVERAGE_TOTAL_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_AVERAGE_TOTAL_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_AVERAGE_TOTAL_AVAILABLE_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_AVERAGE_TOTAL_AVAILABLE_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_AVERAGE_TOTAL_AVAILABLE_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_AVERAGE_TOTAL_AVAILABLE_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_COUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_COUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_DISTINCT_COUNT_ASSET_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_DISTINCT_COUNT_ASSET_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_DISTINCT_COUNT_LP_ID_SS58_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_DISTINCT_COUNT_LP_ID_SS58_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_DISTINCT_COUNT_POOL_SHARE_PERCENT_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_DISTINCT_COUNT_POOL_SHARE_PERCENT_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_DISTINCT_COUNT_TOTAL_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_DISTINCT_COUNT_TOTAL_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_DISTINCT_COUNT_TOTAL_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_DISTINCT_COUNT_TOTAL_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_DISTINCT_COUNT_TOTAL_AVAILABLE_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_DISTINCT_COUNT_TOTAL_AVAILABLE_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_DISTINCT_COUNT_TOTAL_AVAILABLE_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_DISTINCT_COUNT_TOTAL_AVAILABLE_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_MAX_ASSET_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_MAX_ASSET_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_MAX_LP_ID_SS58_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_MAX_LP_ID_SS58_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_MAX_POOL_SHARE_PERCENT_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_MAX_POOL_SHARE_PERCENT_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_MAX_TOTAL_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_MAX_TOTAL_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_MAX_TOTAL_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_MAX_TOTAL_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_MAX_TOTAL_AVAILABLE_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_MAX_TOTAL_AVAILABLE_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_MAX_TOTAL_AVAILABLE_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_MAX_TOTAL_AVAILABLE_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_MIN_ASSET_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_MIN_ASSET_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_MIN_LP_ID_SS58_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_MIN_LP_ID_SS58_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_MIN_POOL_SHARE_PERCENT_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_MIN_POOL_SHARE_PERCENT_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_MIN_TOTAL_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_MIN_TOTAL_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_MIN_TOTAL_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_MIN_TOTAL_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_MIN_TOTAL_AVAILABLE_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_MIN_TOTAL_AVAILABLE_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_MIN_TOTAL_AVAILABLE_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_MIN_TOTAL_AVAILABLE_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_STDDEV_POPULATION_ASSET_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_STDDEV_POPULATION_ASSET_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_STDDEV_POPULATION_LP_ID_SS58_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_STDDEV_POPULATION_LP_ID_SS58_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_STDDEV_POPULATION_POOL_SHARE_PERCENT_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_STDDEV_POPULATION_POOL_SHARE_PERCENT_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_STDDEV_POPULATION_TOTAL_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_STDDEV_POPULATION_TOTAL_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_STDDEV_POPULATION_TOTAL_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_STDDEV_POPULATION_TOTAL_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_STDDEV_POPULATION_TOTAL_AVAILABLE_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_STDDEV_POPULATION_TOTAL_AVAILABLE_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_STDDEV_POPULATION_TOTAL_AVAILABLE_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_STDDEV_POPULATION_TOTAL_AVAILABLE_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_STDDEV_SAMPLE_ASSET_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_STDDEV_SAMPLE_ASSET_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_STDDEV_SAMPLE_LP_ID_SS58_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_STDDEV_SAMPLE_LP_ID_SS58_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_STDDEV_SAMPLE_POOL_SHARE_PERCENT_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_STDDEV_SAMPLE_POOL_SHARE_PERCENT_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_STDDEV_SAMPLE_TOTAL_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_STDDEV_SAMPLE_TOTAL_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_STDDEV_SAMPLE_TOTAL_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_STDDEV_SAMPLE_TOTAL_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_STDDEV_SAMPLE_TOTAL_AVAILABLE_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_STDDEV_SAMPLE_TOTAL_AVAILABLE_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_STDDEV_SAMPLE_TOTAL_AVAILABLE_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_STDDEV_SAMPLE_TOTAL_AVAILABLE_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_SUM_ASSET_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_SUM_ASSET_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_SUM_LP_ID_SS58_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_SUM_LP_ID_SS58_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_SUM_POOL_SHARE_PERCENT_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_SUM_POOL_SHARE_PERCENT_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_SUM_TOTAL_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_SUM_TOTAL_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_SUM_TOTAL_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_SUM_TOTAL_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_SUM_TOTAL_AVAILABLE_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_SUM_TOTAL_AVAILABLE_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_SUM_TOTAL_AVAILABLE_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_SUM_TOTAL_AVAILABLE_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_VARIANCE_POPULATION_ASSET_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_VARIANCE_POPULATION_ASSET_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_VARIANCE_POPULATION_LP_ID_SS58_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_VARIANCE_POPULATION_LP_ID_SS58_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_VARIANCE_POPULATION_POOL_SHARE_PERCENT_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_VARIANCE_POPULATION_POOL_SHARE_PERCENT_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_VARIANCE_POPULATION_TOTAL_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_VARIANCE_POPULATION_TOTAL_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_VARIANCE_POPULATION_TOTAL_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_VARIANCE_POPULATION_TOTAL_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_VARIANCE_POPULATION_TOTAL_AVAILABLE_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_VARIANCE_POPULATION_TOTAL_AVAILABLE_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_VARIANCE_POPULATION_TOTAL_AVAILABLE_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_VARIANCE_POPULATION_TOTAL_AVAILABLE_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_VARIANCE_SAMPLE_ASSET_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_VARIANCE_SAMPLE_ASSET_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_VARIANCE_SAMPLE_LP_ID_SS58_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_VARIANCE_SAMPLE_LP_ID_SS58_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_VARIANCE_SAMPLE_POOL_SHARE_PERCENT_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_VARIANCE_SAMPLE_POOL_SHARE_PERCENT_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_VARIANCE_SAMPLE_TOTAL_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_VARIANCE_SAMPLE_TOTAL_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_VARIANCE_SAMPLE_TOTAL_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_VARIANCE_SAMPLE_TOTAL_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_VARIANCE_SAMPLE_TOTAL_AVAILABLE_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_VARIANCE_SAMPLE_TOTAL_AVAILABLE_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_ASSET_VARIANCE_SAMPLE_TOTAL_AVAILABLE_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_ASSET_VARIANCE_SAMPLE_TOTAL_AVAILABLE_AMOUNT_USD_DESC'
  | 'NATURAL'
  | 'ORACLE_PRICE_ID_ASC'
  | 'ORACLE_PRICE_ID_DESC'
  | 'ORIGINATION_FEE_BPS_ASC'
  | 'ORIGINATION_FEE_BPS_DESC'
  | 'TOTAL_AMOUNT_ASC'
  | 'TOTAL_AMOUNT_DESC'
  | 'TOTAL_AMOUNT_USD_ASC'
  | 'TOTAL_AMOUNT_USD_DESC'
  | 'TOTAL_AVAILABLE_AMOUNT_ASC'
  | 'TOTAL_AVAILABLE_AMOUNT_DESC'
  | 'TOTAL_AVAILABLE_AMOUNT_USD_ASC'
  | 'TOTAL_AVAILABLE_AMOUNT_USD_DESC'
  | 'TOTAL_BORROWED_AMOUNT_ASC'
  | 'TOTAL_BORROWED_AMOUNT_DESC'
  | 'TOTAL_BORROWED_AMOUNT_USD_ASC'
  | 'TOTAL_BORROWED_AMOUNT_USD_DESC'
  | 'UTILISATION_RATE_BPS_ASC'
  | 'UTILISATION_RATE_BPS_DESC'
  | 'WITHDRAWING_LENDER_FUNDS_ENABLED_ASC'
  | 'WITHDRAWING_LENDER_FUNDS_ENABLED_DESC';

export type LendingSafeMode = Node & {
  __typename?: 'LendingSafeMode';
  addingCollateralEnabled: Scalars['Boolean']['output'];
  asset: ChainflipAsset;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  removingCollateralEnabled: Scalars['Boolean']['output'];
};

export type LendingSafeModeAggregates = {
  __typename?: 'LendingSafeModeAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<LendingSafeModeAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<LendingSafeModeDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<LendingSafeModeMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<LendingSafeModeMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<LendingSafeModeStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<LendingSafeModeStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<LendingSafeModeSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<LendingSafeModeVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<LendingSafeModeVarianceSampleAggregates>;
};

export type LendingSafeModeAverageAggregates = {
  __typename?: 'LendingSafeModeAverageAggregates';
  /** Mean average of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `LendingSafeMode` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type LendingSafeModeCondition = {
  /** Checks for equality with the object’s `addingCollateralEnabled` field. */
  addingCollateralEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `asset` field. */
  asset?: InputMaybe<ChainflipAsset>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `removingCollateralEnabled` field. */
  removingCollateralEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

export type LendingSafeModeDistinctCountAggregates = {
  __typename?: 'LendingSafeModeDistinctCountAggregates';
  /** Distinct count of addingCollateralEnabled across the matching connection */
  addingCollateralEnabled?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of asset across the matching connection */
  asset?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of id across the matching connection */
  id?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of removingCollateralEnabled across the matching connection */
  removingCollateralEnabled?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `LendingSafeMode` object types. All fields are combined with a logical ‘and.’ */
export type LendingSafeModeFilter = {
  /** Filter by the object’s `addingCollateralEnabled` field. */
  addingCollateralEnabled?: InputMaybe<BooleanFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<LendingSafeModeFilter>>;
  /** Filter by the object’s `asset` field. */
  asset?: InputMaybe<ChainflipAssetFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<LendingSafeModeFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<LendingSafeModeFilter>>;
  /** Filter by the object’s `removingCollateralEnabled` field. */
  removingCollateralEnabled?: InputMaybe<BooleanFilter>;
};

/** Grouping methods for `LendingSafeMode` for usage during aggregation. */
export type LendingSafeModeGroupBy =
  | 'ADDING_COLLATERAL_ENABLED'
  | 'REMOVING_COLLATERAL_ENABLED';

export type LendingSafeModeHavingAverageInput = {
  id?: InputMaybe<HavingIntFilter>;
};

export type LendingSafeModeHavingDistinctCountInput = {
  id?: InputMaybe<HavingIntFilter>;
};

/** Conditions for `LendingSafeMode` aggregates. */
export type LendingSafeModeHavingInput = {
  AND?: InputMaybe<Array<LendingSafeModeHavingInput>>;
  OR?: InputMaybe<Array<LendingSafeModeHavingInput>>;
  average?: InputMaybe<LendingSafeModeHavingAverageInput>;
  distinctCount?: InputMaybe<LendingSafeModeHavingDistinctCountInput>;
  max?: InputMaybe<LendingSafeModeHavingMaxInput>;
  min?: InputMaybe<LendingSafeModeHavingMinInput>;
  stddevPopulation?: InputMaybe<LendingSafeModeHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<LendingSafeModeHavingStddevSampleInput>;
  sum?: InputMaybe<LendingSafeModeHavingSumInput>;
  variancePopulation?: InputMaybe<LendingSafeModeHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<LendingSafeModeHavingVarianceSampleInput>;
};

export type LendingSafeModeHavingMaxInput = {
  id?: InputMaybe<HavingIntFilter>;
};

export type LendingSafeModeHavingMinInput = {
  id?: InputMaybe<HavingIntFilter>;
};

export type LendingSafeModeHavingStddevPopulationInput = {
  id?: InputMaybe<HavingIntFilter>;
};

export type LendingSafeModeHavingStddevSampleInput = {
  id?: InputMaybe<HavingIntFilter>;
};

export type LendingSafeModeHavingSumInput = {
  id?: InputMaybe<HavingIntFilter>;
};

export type LendingSafeModeHavingVariancePopulationInput = {
  id?: InputMaybe<HavingIntFilter>;
};

export type LendingSafeModeHavingVarianceSampleInput = {
  id?: InputMaybe<HavingIntFilter>;
};

export type LendingSafeModeMaxAggregates = {
  __typename?: 'LendingSafeModeMaxAggregates';
  /** Maximum of id across the matching connection */
  id?: Maybe<Scalars['Int']['output']>;
};

export type LendingSafeModeMinAggregates = {
  __typename?: 'LendingSafeModeMinAggregates';
  /** Minimum of id across the matching connection */
  id?: Maybe<Scalars['Int']['output']>;
};

export type LendingSafeModeStddevPopulationAggregates = {
  __typename?: 'LendingSafeModeStddevPopulationAggregates';
  /** Population standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
};

export type LendingSafeModeStddevSampleAggregates = {
  __typename?: 'LendingSafeModeStddevSampleAggregates';
  /** Sample standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
};

export type LendingSafeModeSumAggregates = {
  __typename?: 'LendingSafeModeSumAggregates';
  /** Sum of id across the matching connection */
  id: Scalars['BigInt']['output'];
};

export type LendingSafeModeVariancePopulationAggregates = {
  __typename?: 'LendingSafeModeVariancePopulationAggregates';
  /** Population variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
};

export type LendingSafeModeVarianceSampleAggregates = {
  __typename?: 'LendingSafeModeVarianceSampleAggregates';
  /** Sample variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
};

/** A connection to a list of `LendingSafeMode` values. */
export type LendingSafeModesConnection = {
  __typename?: 'LendingSafeModesConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<LendingSafeModeAggregates>;
  /** A list of edges which contains the `LendingSafeMode` and cursor to aid in pagination. */
  edges: Array<LendingSafeModesEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<LendingSafeModeAggregates>>;
  /** A list of `LendingSafeMode` objects. */
  nodes: Array<LendingSafeMode>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `LendingSafeMode` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `LendingSafeMode` values. */
export type LendingSafeModesConnectionGroupedAggregatesArgs = {
  groupBy: Array<LendingSafeModeGroupBy>;
  having?: InputMaybe<LendingSafeModeHavingInput>;
};

/** A `LendingSafeMode` edge in the connection. */
export type LendingSafeModesEdge = {
  __typename?: 'LendingSafeModesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `LendingSafeMode` at the end of the edge. */
  node: LendingSafeMode;
};

/** Methods to use when ordering `LendingSafeMode`. */
export type LendingSafeModesOrderBy =
  | 'ADDING_COLLATERAL_ENABLED_ASC'
  | 'ADDING_COLLATERAL_ENABLED_DESC'
  | 'ASSET_ASC'
  | 'ASSET_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'REMOVING_COLLATERAL_ENABLED_ASC'
  | 'REMOVING_COLLATERAL_ENABLED_DESC';

export type Loan = Node & {
  __typename?: 'Loan';
  asset: ChainflipAsset;
  createdAtBlockIndex: Scalars['Int']['output'];
  id: Scalars['BigInt']['output'];
  /** Reads a single `LendingPool` that is related to this `Loan`. */
  lendingPoolByAsset: LendingPool;
  loanAccountLpIdSs58: Scalars['String']['output'];
  /** Reads a single `LpLoanAccount` that is related to this `Loan`. */
  lpLoanAccountByLoanAccountLpIdSs58: LpLoanAccount;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  principalAmount: Scalars['BigFloat']['output'];
  principalAmountUsd: Scalars['BigFloat']['output'];
  status: LoanStatus;
};

export type LoanAggregates = {
  __typename?: 'LoanAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<LoanAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<LoanDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<LoanMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<LoanMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<LoanStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<LoanStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<LoanSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<LoanVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<LoanVarianceSampleAggregates>;
};

/** A filter to be used against aggregates of `Loan` object types. */
export type LoanAggregatesFilter = {
  /** Mean average aggregate over matching `Loan` objects. */
  average?: InputMaybe<LoanAverageAggregateFilter>;
  /** Distinct count aggregate over matching `Loan` objects. */
  distinctCount?: InputMaybe<LoanDistinctCountAggregateFilter>;
  /** A filter that must pass for the relevant `Loan` object to be included within the aggregate. */
  filter?: InputMaybe<LoanFilter>;
  /** Maximum aggregate over matching `Loan` objects. */
  max?: InputMaybe<LoanMaxAggregateFilter>;
  /** Minimum aggregate over matching `Loan` objects. */
  min?: InputMaybe<LoanMinAggregateFilter>;
  /** Population standard deviation aggregate over matching `Loan` objects. */
  stddevPopulation?: InputMaybe<LoanStddevPopulationAggregateFilter>;
  /** Sample standard deviation aggregate over matching `Loan` objects. */
  stddevSample?: InputMaybe<LoanStddevSampleAggregateFilter>;
  /** Sum aggregate over matching `Loan` objects. */
  sum?: InputMaybe<LoanSumAggregateFilter>;
  /** Population variance aggregate over matching `Loan` objects. */
  variancePopulation?: InputMaybe<LoanVariancePopulationAggregateFilter>;
  /** Sample variance aggregate over matching `Loan` objects. */
  varianceSample?: InputMaybe<LoanVarianceSampleAggregateFilter>;
};

export type LoanAverageAggregateFilter = {
  createdAtBlockIndex?: InputMaybe<BigFloatFilter>;
  id?: InputMaybe<BigFloatFilter>;
  principalAmount?: InputMaybe<BigFloatFilter>;
  principalAmountUsd?: InputMaybe<BigFloatFilter>;
};

export type LoanAverageAggregates = {
  __typename?: 'LoanAverageAggregates';
  /** Mean average of createdAtBlockIndex across the matching connection */
  createdAtBlockIndex?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of principalAmount across the matching connection */
  principalAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of principalAmountUsd across the matching connection */
  principalAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
};

/** A condition to be used against `Loan` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type LoanCondition = {
  /** Checks for equality with the object’s `asset` field. */
  asset?: InputMaybe<ChainflipAsset>;
  /** Checks for equality with the object’s `createdAtBlockIndex` field. */
  createdAtBlockIndex?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `loanAccountLpIdSs58` field. */
  loanAccountLpIdSs58?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `principalAmount` field. */
  principalAmount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `principalAmountUsd` field. */
  principalAmountUsd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<LoanStatus>;
};

export type LoanDistinctCountAggregateFilter = {
  asset?: InputMaybe<BigIntFilter>;
  createdAtBlockIndex?: InputMaybe<BigIntFilter>;
  id?: InputMaybe<BigIntFilter>;
  loanAccountLpIdSs58?: InputMaybe<BigIntFilter>;
  principalAmount?: InputMaybe<BigIntFilter>;
  principalAmountUsd?: InputMaybe<BigIntFilter>;
  status?: InputMaybe<BigIntFilter>;
};

export type LoanDistinctCountAggregates = {
  __typename?: 'LoanDistinctCountAggregates';
  /** Distinct count of asset across the matching connection */
  asset?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of createdAtBlockIndex across the matching connection */
  createdAtBlockIndex?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of id across the matching connection */
  id?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of loanAccountLpIdSs58 across the matching connection */
  loanAccountLpIdSs58?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of principalAmount across the matching connection */
  principalAmount?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of principalAmountUsd across the matching connection */
  principalAmountUsd?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of status across the matching connection */
  status?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `Loan` object types. All fields are combined with a logical ‘and.’ */
export type LoanFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<LoanFilter>>;
  /** Filter by the object’s `asset` field. */
  asset?: InputMaybe<ChainflipAssetFilter>;
  /** Filter by the object’s `createdAtBlockIndex` field. */
  createdAtBlockIndex?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `lendingPoolByAsset` relation. */
  lendingPoolByAsset?: InputMaybe<LendingPoolFilter>;
  /** Filter by the object’s `loanAccountLpIdSs58` field. */
  loanAccountLpIdSs58?: InputMaybe<StringFilter>;
  /** Filter by the object’s `lpLoanAccountByLoanAccountLpIdSs58` relation. */
  lpLoanAccountByLoanAccountLpIdSs58?: InputMaybe<LpLoanAccountFilter>;
  /** Negates the expression. */
  not?: InputMaybe<LoanFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<LoanFilter>>;
  /** Filter by the object’s `principalAmount` field. */
  principalAmount?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `principalAmountUsd` field. */
  principalAmountUsd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<LoanStatusFilter>;
};

/** Grouping methods for `Loan` for usage during aggregation. */
export type LoanGroupBy =
  | 'ASSET'
  | 'CREATED_AT_BLOCK_INDEX'
  | 'LOAN_ACCOUNT_LP_ID_SS58'
  | 'PRINCIPAL_AMOUNT'
  | 'PRINCIPAL_AMOUNT_USD'
  | 'STATUS';

export type LoanHavingAverageInput = {
  createdAtBlockIndex?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingBigintFilter>;
  principalAmount?: InputMaybe<HavingBigfloatFilter>;
  principalAmountUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LoanHavingDistinctCountInput = {
  createdAtBlockIndex?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingBigintFilter>;
  principalAmount?: InputMaybe<HavingBigfloatFilter>;
  principalAmountUsd?: InputMaybe<HavingBigfloatFilter>;
};

/** Conditions for `Loan` aggregates. */
export type LoanHavingInput = {
  AND?: InputMaybe<Array<LoanHavingInput>>;
  OR?: InputMaybe<Array<LoanHavingInput>>;
  average?: InputMaybe<LoanHavingAverageInput>;
  distinctCount?: InputMaybe<LoanHavingDistinctCountInput>;
  max?: InputMaybe<LoanHavingMaxInput>;
  min?: InputMaybe<LoanHavingMinInput>;
  stddevPopulation?: InputMaybe<LoanHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<LoanHavingStddevSampleInput>;
  sum?: InputMaybe<LoanHavingSumInput>;
  variancePopulation?: InputMaybe<LoanHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<LoanHavingVarianceSampleInput>;
};

export type LoanHavingMaxInput = {
  createdAtBlockIndex?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingBigintFilter>;
  principalAmount?: InputMaybe<HavingBigfloatFilter>;
  principalAmountUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LoanHavingMinInput = {
  createdAtBlockIndex?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingBigintFilter>;
  principalAmount?: InputMaybe<HavingBigfloatFilter>;
  principalAmountUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LoanHavingStddevPopulationInput = {
  createdAtBlockIndex?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingBigintFilter>;
  principalAmount?: InputMaybe<HavingBigfloatFilter>;
  principalAmountUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LoanHavingStddevSampleInput = {
  createdAtBlockIndex?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingBigintFilter>;
  principalAmount?: InputMaybe<HavingBigfloatFilter>;
  principalAmountUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LoanHavingSumInput = {
  createdAtBlockIndex?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingBigintFilter>;
  principalAmount?: InputMaybe<HavingBigfloatFilter>;
  principalAmountUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LoanHavingVariancePopulationInput = {
  createdAtBlockIndex?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingBigintFilter>;
  principalAmount?: InputMaybe<HavingBigfloatFilter>;
  principalAmountUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LoanHavingVarianceSampleInput = {
  createdAtBlockIndex?: InputMaybe<HavingIntFilter>;
  id?: InputMaybe<HavingBigintFilter>;
  principalAmount?: InputMaybe<HavingBigfloatFilter>;
  principalAmountUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LoanMaxAggregateFilter = {
  createdAtBlockIndex?: InputMaybe<IntFilter>;
  id?: InputMaybe<BigIntFilter>;
  principalAmount?: InputMaybe<BigFloatFilter>;
  principalAmountUsd?: InputMaybe<BigFloatFilter>;
};

export type LoanMaxAggregates = {
  __typename?: 'LoanMaxAggregates';
  /** Maximum of createdAtBlockIndex across the matching connection */
  createdAtBlockIndex?: Maybe<Scalars['Int']['output']>;
  /** Maximum of id across the matching connection */
  id?: Maybe<Scalars['BigInt']['output']>;
  /** Maximum of principalAmount across the matching connection */
  principalAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of principalAmountUsd across the matching connection */
  principalAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type LoanMinAggregateFilter = {
  createdAtBlockIndex?: InputMaybe<IntFilter>;
  id?: InputMaybe<BigIntFilter>;
  principalAmount?: InputMaybe<BigFloatFilter>;
  principalAmountUsd?: InputMaybe<BigFloatFilter>;
};

export type LoanMinAggregates = {
  __typename?: 'LoanMinAggregates';
  /** Minimum of createdAtBlockIndex across the matching connection */
  createdAtBlockIndex?: Maybe<Scalars['Int']['output']>;
  /** Minimum of id across the matching connection */
  id?: Maybe<Scalars['BigInt']['output']>;
  /** Minimum of principalAmount across the matching connection */
  principalAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of principalAmountUsd across the matching connection */
  principalAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type LoanStatus =
  | 'Active'
  | 'HardLiquidation'
  | 'SoftLiquidation';

/** A filter to be used against LoanStatus fields. All fields are combined with a logical ‘and.’ */
export type LoanStatusFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<LoanStatus>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<LoanStatus>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<LoanStatus>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<LoanStatus>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<LoanStatus>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<LoanStatus>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<LoanStatus>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<LoanStatus>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<LoanStatus>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<LoanStatus>>;
};

export type LoanStddevPopulationAggregateFilter = {
  createdAtBlockIndex?: InputMaybe<BigFloatFilter>;
  id?: InputMaybe<BigFloatFilter>;
  principalAmount?: InputMaybe<BigFloatFilter>;
  principalAmountUsd?: InputMaybe<BigFloatFilter>;
};

export type LoanStddevPopulationAggregates = {
  __typename?: 'LoanStddevPopulationAggregates';
  /** Population standard deviation of createdAtBlockIndex across the matching connection */
  createdAtBlockIndex?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of principalAmount across the matching connection */
  principalAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of principalAmountUsd across the matching connection */
  principalAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type LoanStddevSampleAggregateFilter = {
  createdAtBlockIndex?: InputMaybe<BigFloatFilter>;
  id?: InputMaybe<BigFloatFilter>;
  principalAmount?: InputMaybe<BigFloatFilter>;
  principalAmountUsd?: InputMaybe<BigFloatFilter>;
};

export type LoanStddevSampleAggregates = {
  __typename?: 'LoanStddevSampleAggregates';
  /** Sample standard deviation of createdAtBlockIndex across the matching connection */
  createdAtBlockIndex?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of principalAmount across the matching connection */
  principalAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of principalAmountUsd across the matching connection */
  principalAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type LoanSumAggregateFilter = {
  createdAtBlockIndex?: InputMaybe<BigIntFilter>;
  id?: InputMaybe<BigFloatFilter>;
  principalAmount?: InputMaybe<BigFloatFilter>;
  principalAmountUsd?: InputMaybe<BigFloatFilter>;
};

export type LoanSumAggregates = {
  __typename?: 'LoanSumAggregates';
  /** Sum of createdAtBlockIndex across the matching connection */
  createdAtBlockIndex: Scalars['BigInt']['output'];
  /** Sum of id across the matching connection */
  id: Scalars['BigFloat']['output'];
  /** Sum of principalAmount across the matching connection */
  principalAmount: Scalars['BigFloat']['output'];
  /** Sum of principalAmountUsd across the matching connection */
  principalAmountUsd: Scalars['BigFloat']['output'];
};

export type LoanVariancePopulationAggregateFilter = {
  createdAtBlockIndex?: InputMaybe<BigFloatFilter>;
  id?: InputMaybe<BigFloatFilter>;
  principalAmount?: InputMaybe<BigFloatFilter>;
  principalAmountUsd?: InputMaybe<BigFloatFilter>;
};

export type LoanVariancePopulationAggregates = {
  __typename?: 'LoanVariancePopulationAggregates';
  /** Population variance of createdAtBlockIndex across the matching connection */
  createdAtBlockIndex?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of principalAmount across the matching connection */
  principalAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of principalAmountUsd across the matching connection */
  principalAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type LoanVarianceSampleAggregateFilter = {
  createdAtBlockIndex?: InputMaybe<BigFloatFilter>;
  id?: InputMaybe<BigFloatFilter>;
  principalAmount?: InputMaybe<BigFloatFilter>;
  principalAmountUsd?: InputMaybe<BigFloatFilter>;
};

export type LoanVarianceSampleAggregates = {
  __typename?: 'LoanVarianceSampleAggregates';
  /** Sample variance of createdAtBlockIndex across the matching connection */
  createdAtBlockIndex?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of principalAmount across the matching connection */
  principalAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of principalAmountUsd across the matching connection */
  principalAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
};

/** A connection to a list of `Loan` values. */
export type LoansConnection = {
  __typename?: 'LoansConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<LoanAggregates>;
  /** A list of edges which contains the `Loan` and cursor to aid in pagination. */
  edges: Array<LoansEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<LoanAggregates>>;
  /** A list of `Loan` objects. */
  nodes: Array<Loan>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Loan` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `Loan` values. */
export type LoansConnectionGroupedAggregatesArgs = {
  groupBy: Array<LoanGroupBy>;
  having?: InputMaybe<LoanHavingInput>;
};

/** A `Loan` edge in the connection. */
export type LoansEdge = {
  __typename?: 'LoansEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Loan` at the end of the edge. */
  node: Loan;
};

/** Methods to use when ordering `Loan`. */
export type LoansOrderBy =
  | 'ASSET_ASC'
  | 'ASSET_DESC'
  | 'CREATED_AT_BLOCK_INDEX_ASC'
  | 'CREATED_AT_BLOCK_INDEX_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'LOAN_ACCOUNT_LP_ID_SS58_ASC'
  | 'LOAN_ACCOUNT_LP_ID_SS58_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'PRINCIPAL_AMOUNT_ASC'
  | 'PRINCIPAL_AMOUNT_DESC'
  | 'PRINCIPAL_AMOUNT_USD_ASC'
  | 'PRINCIPAL_AMOUNT_USD_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC';

export type LpAccount = Node & {
  __typename?: 'LpAccount';
  /** Reads a single `Account` that is related to this `LpAccount`. */
  accountByIdSs58: Account;
  alias?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `BoostBalance`. */
  boostBalancesByLpIdSs58: BoostBalancesConnection;
  /** Reads and enables pagination through a set of `DepositBalance`. */
  depositBalancesByLpIdSs58: DepositBalancesConnection;
  earnedFeesValueUsd: Scalars['BigFloat']['output'];
  flipBalance: Scalars['BigFloat']['output'];
  idSs58: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `LpLendingBalance`. */
  lpLendingBalancesByLpIdSs58: LpLendingBalancesConnection;
  /** Reads and enables pagination through a set of `LpLoanAccount`. */
  lpLoanAccountsByLpIdSs58: LpLoanAccountsConnection;
  /** Reads and enables pagination through a set of `LpTotalBalance`. */
  lpTotalBalancesByLpIdSs58: LpTotalBalancesConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  openOrders: Scalars['JSON']['output'];
  /** Reads and enables pagination through a set of `TradingStrategy`. */
  tradingStrategiesByOwnerAccountIdSs58: TradingStrategiesConnection;
};


export type LpAccountBoostBalancesByLpIdSs58Args = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<BoostBalanceCondition>;
  filter?: InputMaybe<BoostBalanceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BoostBalancesOrderBy>>;
};


export type LpAccountDepositBalancesByLpIdSs58Args = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DepositBalanceCondition>;
  filter?: InputMaybe<DepositBalanceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DepositBalancesOrderBy>>;
};


export type LpAccountLpLendingBalancesByLpIdSs58Args = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LpLendingBalanceCondition>;
  filter?: InputMaybe<LpLendingBalanceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LpLendingBalancesOrderBy>>;
};


export type LpAccountLpLoanAccountsByLpIdSs58Args = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LpLoanAccountCondition>;
  filter?: InputMaybe<LpLoanAccountFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LpLoanAccountsOrderBy>>;
};


export type LpAccountLpTotalBalancesByLpIdSs58Args = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LpTotalBalanceCondition>;
  filter?: InputMaybe<LpTotalBalanceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LpTotalBalancesOrderBy>>;
};


export type LpAccountTradingStrategiesByOwnerAccountIdSs58Args = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TradingStrategyCondition>;
  filter?: InputMaybe<TradingStrategyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TradingStrategiesOrderBy>>;
};

export type LpAccountAggregates = {
  __typename?: 'LpAccountAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<LpAccountAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<LpAccountDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<LpAccountMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<LpAccountMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<LpAccountStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<LpAccountStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<LpAccountSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<LpAccountVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<LpAccountVarianceSampleAggregates>;
};

export type LpAccountAverageAggregates = {
  __typename?: 'LpAccountAverageAggregates';
  /** Mean average of earnedFeesValueUsd across the matching connection */
  earnedFeesValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of flipBalance across the matching connection */
  flipBalance?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `LpAccount` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type LpAccountCondition = {
  /** Checks for equality with the object’s `alias` field. */
  alias?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `earnedFeesValueUsd` field. */
  earnedFeesValueUsd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `flipBalance` field. */
  flipBalance?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `idSs58` field. */
  idSs58?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `openOrders` field. */
  openOrders?: InputMaybe<Scalars['JSON']['input']>;
};

export type LpAccountDistinctCountAggregates = {
  __typename?: 'LpAccountDistinctCountAggregates';
  /** Distinct count of alias across the matching connection */
  alias?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of earnedFeesValueUsd across the matching connection */
  earnedFeesValueUsd?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of flipBalance across the matching connection */
  flipBalance?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of idSs58 across the matching connection */
  idSs58?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of openOrders across the matching connection */
  openOrders?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `LpAccount` object types. All fields are combined with a logical ‘and.’ */
export type LpAccountFilter = {
  /** Filter by the object’s `accountByIdSs58` relation. */
  accountByIdSs58?: InputMaybe<AccountFilter>;
  /** Filter by the object’s `alias` field. */
  alias?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<LpAccountFilter>>;
  /** Filter by the object’s `boostBalancesByLpIdSs58` relation. */
  boostBalancesByLpIdSs58?: InputMaybe<LpAccountToManyBoostBalanceFilter>;
  /** Some related `boostBalancesByLpIdSs58` exist. */
  boostBalancesByLpIdSs58Exist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `depositBalancesByLpIdSs58` relation. */
  depositBalancesByLpIdSs58?: InputMaybe<LpAccountToManyDepositBalanceFilter>;
  /** Some related `depositBalancesByLpIdSs58` exist. */
  depositBalancesByLpIdSs58Exist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `earnedFeesValueUsd` field. */
  earnedFeesValueUsd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `flipBalance` field. */
  flipBalance?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `idSs58` field. */
  idSs58?: InputMaybe<StringFilter>;
  /** Filter by the object’s `lpLendingBalancesByLpIdSs58` relation. */
  lpLendingBalancesByLpIdSs58?: InputMaybe<LpAccountToManyLpLendingBalanceFilter>;
  /** Some related `lpLendingBalancesByLpIdSs58` exist. */
  lpLendingBalancesByLpIdSs58Exist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `lpLoanAccountsByLpIdSs58` relation. */
  lpLoanAccountsByLpIdSs58?: InputMaybe<LpAccountToManyLpLoanAccountFilter>;
  /** Some related `lpLoanAccountsByLpIdSs58` exist. */
  lpLoanAccountsByLpIdSs58Exist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `lpTotalBalancesByLpIdSs58` relation. */
  lpTotalBalancesByLpIdSs58?: InputMaybe<LpAccountToManyLpTotalBalanceFilter>;
  /** Some related `lpTotalBalancesByLpIdSs58` exist. */
  lpTotalBalancesByLpIdSs58Exist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Negates the expression. */
  not?: InputMaybe<LpAccountFilter>;
  /** Filter by the object’s `openOrders` field. */
  openOrders?: InputMaybe<JsonFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<LpAccountFilter>>;
  /** Filter by the object’s `tradingStrategiesByOwnerAccountIdSs58` relation. */
  tradingStrategiesByOwnerAccountIdSs58?: InputMaybe<LpAccountToManyTradingStrategyFilter>;
  /** Some related `tradingStrategiesByOwnerAccountIdSs58` exist. */
  tradingStrategiesByOwnerAccountIdSs58Exist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Grouping methods for `LpAccount` for usage during aggregation. */
export type LpAccountGroupBy =
  | 'ALIAS'
  | 'EARNED_FEES_VALUE_USD'
  | 'FLIP_BALANCE'
  | 'OPEN_ORDERS';

export type LpAccountHavingAverageInput = {
  earnedFeesValueUsd?: InputMaybe<HavingBigfloatFilter>;
  flipBalance?: InputMaybe<HavingBigfloatFilter>;
};

export type LpAccountHavingDistinctCountInput = {
  earnedFeesValueUsd?: InputMaybe<HavingBigfloatFilter>;
  flipBalance?: InputMaybe<HavingBigfloatFilter>;
};

/** Conditions for `LpAccount` aggregates. */
export type LpAccountHavingInput = {
  AND?: InputMaybe<Array<LpAccountHavingInput>>;
  OR?: InputMaybe<Array<LpAccountHavingInput>>;
  average?: InputMaybe<LpAccountHavingAverageInput>;
  distinctCount?: InputMaybe<LpAccountHavingDistinctCountInput>;
  max?: InputMaybe<LpAccountHavingMaxInput>;
  min?: InputMaybe<LpAccountHavingMinInput>;
  stddevPopulation?: InputMaybe<LpAccountHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<LpAccountHavingStddevSampleInput>;
  sum?: InputMaybe<LpAccountHavingSumInput>;
  variancePopulation?: InputMaybe<LpAccountHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<LpAccountHavingVarianceSampleInput>;
};

export type LpAccountHavingMaxInput = {
  earnedFeesValueUsd?: InputMaybe<HavingBigfloatFilter>;
  flipBalance?: InputMaybe<HavingBigfloatFilter>;
};

export type LpAccountHavingMinInput = {
  earnedFeesValueUsd?: InputMaybe<HavingBigfloatFilter>;
  flipBalance?: InputMaybe<HavingBigfloatFilter>;
};

export type LpAccountHavingStddevPopulationInput = {
  earnedFeesValueUsd?: InputMaybe<HavingBigfloatFilter>;
  flipBalance?: InputMaybe<HavingBigfloatFilter>;
};

export type LpAccountHavingStddevSampleInput = {
  earnedFeesValueUsd?: InputMaybe<HavingBigfloatFilter>;
  flipBalance?: InputMaybe<HavingBigfloatFilter>;
};

export type LpAccountHavingSumInput = {
  earnedFeesValueUsd?: InputMaybe<HavingBigfloatFilter>;
  flipBalance?: InputMaybe<HavingBigfloatFilter>;
};

export type LpAccountHavingVariancePopulationInput = {
  earnedFeesValueUsd?: InputMaybe<HavingBigfloatFilter>;
  flipBalance?: InputMaybe<HavingBigfloatFilter>;
};

export type LpAccountHavingVarianceSampleInput = {
  earnedFeesValueUsd?: InputMaybe<HavingBigfloatFilter>;
  flipBalance?: InputMaybe<HavingBigfloatFilter>;
};

export type LpAccountMaxAggregates = {
  __typename?: 'LpAccountMaxAggregates';
  /** Maximum of earnedFeesValueUsd across the matching connection */
  earnedFeesValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of flipBalance across the matching connection */
  flipBalance?: Maybe<Scalars['BigFloat']['output']>;
};

export type LpAccountMinAggregates = {
  __typename?: 'LpAccountMinAggregates';
  /** Minimum of earnedFeesValueUsd across the matching connection */
  earnedFeesValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of flipBalance across the matching connection */
  flipBalance?: Maybe<Scalars['BigFloat']['output']>;
};

export type LpAccountStddevPopulationAggregates = {
  __typename?: 'LpAccountStddevPopulationAggregates';
  /** Population standard deviation of earnedFeesValueUsd across the matching connection */
  earnedFeesValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of flipBalance across the matching connection */
  flipBalance?: Maybe<Scalars['BigFloat']['output']>;
};

export type LpAccountStddevSampleAggregates = {
  __typename?: 'LpAccountStddevSampleAggregates';
  /** Sample standard deviation of earnedFeesValueUsd across the matching connection */
  earnedFeesValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of flipBalance across the matching connection */
  flipBalance?: Maybe<Scalars['BigFloat']['output']>;
};

export type LpAccountSumAggregates = {
  __typename?: 'LpAccountSumAggregates';
  /** Sum of earnedFeesValueUsd across the matching connection */
  earnedFeesValueUsd: Scalars['BigFloat']['output'];
  /** Sum of flipBalance across the matching connection */
  flipBalance: Scalars['BigFloat']['output'];
};

/** A filter to be used against many `BoostBalance` object types. All fields are combined with a logical ‘and.’ */
export type LpAccountToManyBoostBalanceFilter = {
  /** Aggregates across related `BoostBalance` match the filter criteria. */
  aggregates?: InputMaybe<BoostBalanceAggregatesFilter>;
  /** Every related `BoostBalance` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<BoostBalanceFilter>;
  /** No related `BoostBalance` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<BoostBalanceFilter>;
  /** Some related `BoostBalance` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<BoostBalanceFilter>;
};

/** A filter to be used against many `DepositBalance` object types. All fields are combined with a logical ‘and.’ */
export type LpAccountToManyDepositBalanceFilter = {
  /** Aggregates across related `DepositBalance` match the filter criteria. */
  aggregates?: InputMaybe<DepositBalanceAggregatesFilter>;
  /** Every related `DepositBalance` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DepositBalanceFilter>;
  /** No related `DepositBalance` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DepositBalanceFilter>;
  /** Some related `DepositBalance` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DepositBalanceFilter>;
};

/** A filter to be used against many `LpLendingBalance` object types. All fields are combined with a logical ‘and.’ */
export type LpAccountToManyLpLendingBalanceFilter = {
  /** Aggregates across related `LpLendingBalance` match the filter criteria. */
  aggregates?: InputMaybe<LpLendingBalanceAggregatesFilter>;
  /** Every related `LpLendingBalance` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<LpLendingBalanceFilter>;
  /** No related `LpLendingBalance` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<LpLendingBalanceFilter>;
  /** Some related `LpLendingBalance` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<LpLendingBalanceFilter>;
};

/** A filter to be used against many `LpLoanAccount` object types. All fields are combined with a logical ‘and.’ */
export type LpAccountToManyLpLoanAccountFilter = {
  /** Aggregates across related `LpLoanAccount` match the filter criteria. */
  aggregates?: InputMaybe<LpLoanAccountAggregatesFilter>;
  /** Every related `LpLoanAccount` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<LpLoanAccountFilter>;
  /** No related `LpLoanAccount` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<LpLoanAccountFilter>;
  /** Some related `LpLoanAccount` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<LpLoanAccountFilter>;
};

/** A filter to be used against many `LpTotalBalance` object types. All fields are combined with a logical ‘and.’ */
export type LpAccountToManyLpTotalBalanceFilter = {
  /** Aggregates across related `LpTotalBalance` match the filter criteria. */
  aggregates?: InputMaybe<LpTotalBalanceAggregatesFilter>;
  /** Every related `LpTotalBalance` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<LpTotalBalanceFilter>;
  /** No related `LpTotalBalance` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<LpTotalBalanceFilter>;
  /** Some related `LpTotalBalance` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<LpTotalBalanceFilter>;
};

/** A filter to be used against many `TradingStrategy` object types. All fields are combined with a logical ‘and.’ */
export type LpAccountToManyTradingStrategyFilter = {
  /** Aggregates across related `TradingStrategy` match the filter criteria. */
  aggregates?: InputMaybe<TradingStrategyAggregatesFilter>;
  /** Every related `TradingStrategy` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TradingStrategyFilter>;
  /** No related `TradingStrategy` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TradingStrategyFilter>;
  /** Some related `TradingStrategy` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TradingStrategyFilter>;
};

export type LpAccountVariancePopulationAggregates = {
  __typename?: 'LpAccountVariancePopulationAggregates';
  /** Population variance of earnedFeesValueUsd across the matching connection */
  earnedFeesValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of flipBalance across the matching connection */
  flipBalance?: Maybe<Scalars['BigFloat']['output']>;
};

export type LpAccountVarianceSampleAggregates = {
  __typename?: 'LpAccountVarianceSampleAggregates';
  /** Sample variance of earnedFeesValueUsd across the matching connection */
  earnedFeesValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of flipBalance across the matching connection */
  flipBalance?: Maybe<Scalars['BigFloat']['output']>;
};

/** A connection to a list of `LpAccount` values. */
export type LpAccountsConnection = {
  __typename?: 'LpAccountsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<LpAccountAggregates>;
  /** A list of edges which contains the `LpAccount` and cursor to aid in pagination. */
  edges: Array<LpAccountsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<LpAccountAggregates>>;
  /** A list of `LpAccount` objects. */
  nodes: Array<LpAccount>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `LpAccount` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `LpAccount` values. */
export type LpAccountsConnectionGroupedAggregatesArgs = {
  groupBy: Array<LpAccountGroupBy>;
  having?: InputMaybe<LpAccountHavingInput>;
};

/** A `LpAccount` edge in the connection. */
export type LpAccountsEdge = {
  __typename?: 'LpAccountsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `LpAccount` at the end of the edge. */
  node: LpAccount;
};

/** Methods to use when ordering `LpAccount`. */
export type LpAccountsOrderBy =
  | 'ALIAS_ASC'
  | 'ALIAS_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_AVERAGE_AVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_AVERAGE_AVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_AVERAGE_AVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_AVERAGE_AVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_AVERAGE_LP_ID_SS58_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_AVERAGE_LP_ID_SS58_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_AVERAGE_POOL_ID_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_AVERAGE_POOL_ID_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_AVERAGE_POOL_SHARE_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_AVERAGE_POOL_SHARE_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_AVERAGE_UNAVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_AVERAGE_UNAVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_AVERAGE_UNAVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_AVERAGE_UNAVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_COUNT_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_COUNT_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_AVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_AVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_AVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_AVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_LP_ID_SS58_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_LP_ID_SS58_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_POOL_ID_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_POOL_ID_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_POOL_SHARE_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_POOL_SHARE_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_UNAVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_UNAVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_UNAVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_UNAVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_MAX_AVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_MAX_AVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_MAX_AVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_MAX_AVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_MAX_LP_ID_SS58_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_MAX_LP_ID_SS58_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_MAX_POOL_ID_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_MAX_POOL_ID_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_MAX_POOL_SHARE_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_MAX_POOL_SHARE_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_MAX_UNAVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_MAX_UNAVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_MAX_UNAVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_MAX_UNAVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_MIN_AVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_MIN_AVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_MIN_AVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_MIN_AVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_MIN_LP_ID_SS58_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_MIN_LP_ID_SS58_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_MIN_POOL_ID_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_MIN_POOL_ID_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_MIN_POOL_SHARE_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_MIN_POOL_SHARE_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_MIN_UNAVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_MIN_UNAVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_MIN_UNAVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_MIN_UNAVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_AVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_AVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_AVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_AVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_LP_ID_SS58_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_LP_ID_SS58_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_POOL_ID_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_POOL_ID_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_POOL_SHARE_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_POOL_SHARE_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_UNAVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_UNAVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_UNAVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_UNAVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_AVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_AVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_AVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_AVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_LP_ID_SS58_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_LP_ID_SS58_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_POOL_ID_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_POOL_ID_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_POOL_SHARE_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_POOL_SHARE_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_UNAVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_UNAVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_UNAVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_UNAVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_SUM_AVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_SUM_AVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_SUM_AVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_SUM_AVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_SUM_LP_ID_SS58_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_SUM_LP_ID_SS58_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_SUM_POOL_ID_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_SUM_POOL_ID_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_SUM_POOL_SHARE_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_SUM_POOL_SHARE_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_SUM_UNAVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_SUM_UNAVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_SUM_UNAVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_SUM_UNAVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_AVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_AVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_AVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_AVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_LP_ID_SS58_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_LP_ID_SS58_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_POOL_ID_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_POOL_ID_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_POOL_SHARE_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_POOL_SHARE_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_UNAVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_UNAVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_UNAVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_UNAVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_AVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_AVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_AVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_AVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_LP_ID_SS58_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_LP_ID_SS58_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_POOL_ID_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_POOL_ID_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_POOL_SHARE_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_POOL_SHARE_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_UNAVAILABLE_AMOUNT_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_UNAVAILABLE_AMOUNT_DESC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_UNAVAILABLE_AMOUNT_VALUE_USD_ASC'
  | 'BOOST_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_UNAVAILABLE_AMOUNT_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_AVERAGE_AMOUNT_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_AVERAGE_AMOUNT_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_AVERAGE_ASSET_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_AVERAGE_ASSET_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_AVERAGE_BOOST_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_AVERAGE_BOOST_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_AVERAGE_BOOST_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_AVERAGE_BOOST_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_AVERAGE_CHAIN_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_AVERAGE_CHAIN_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_AVERAGE_LENDING_COLLATERAL_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_AVERAGE_LENDING_COLLATERAL_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_AVERAGE_LENDING_COLLATERAL_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_AVERAGE_LENDING_COLLATERAL_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_AVERAGE_LENDING_SUPPLY_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_AVERAGE_LENDING_SUPPLY_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_AVERAGE_LENDING_SUPPLY_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_AVERAGE_LENDING_SUPPLY_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_AVERAGE_LP_ID_SS58_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_AVERAGE_LP_ID_SS58_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_AVERAGE_STRATEGY_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_AVERAGE_STRATEGY_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_AVERAGE_STRATEGY_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_AVERAGE_STRATEGY_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_AVERAGE_TOTAL_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_AVERAGE_TOTAL_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_AVERAGE_TOTAL_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_AVERAGE_TOTAL_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_AVERAGE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_AVERAGE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_COUNT_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_COUNT_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_AMOUNT_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_AMOUNT_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_ASSET_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_ASSET_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_BOOST_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_BOOST_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_BOOST_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_BOOST_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_CHAIN_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_CHAIN_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_LENDING_COLLATERAL_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_LENDING_COLLATERAL_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_LENDING_COLLATERAL_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_LENDING_COLLATERAL_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_LENDING_SUPPLY_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_LENDING_SUPPLY_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_LENDING_SUPPLY_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_LENDING_SUPPLY_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_LP_ID_SS58_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_LP_ID_SS58_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_STRATEGY_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_STRATEGY_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_STRATEGY_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_STRATEGY_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_TOTAL_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_TOTAL_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_TOTAL_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_TOTAL_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MAX_AMOUNT_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MAX_AMOUNT_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MAX_ASSET_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MAX_ASSET_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MAX_BOOST_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MAX_BOOST_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MAX_BOOST_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MAX_BOOST_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MAX_CHAIN_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MAX_CHAIN_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MAX_LENDING_COLLATERAL_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MAX_LENDING_COLLATERAL_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MAX_LENDING_COLLATERAL_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MAX_LENDING_COLLATERAL_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MAX_LENDING_SUPPLY_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MAX_LENDING_SUPPLY_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MAX_LENDING_SUPPLY_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MAX_LENDING_SUPPLY_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MAX_LP_ID_SS58_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MAX_LP_ID_SS58_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MAX_STRATEGY_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MAX_STRATEGY_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MAX_STRATEGY_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MAX_STRATEGY_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MAX_TOTAL_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MAX_TOTAL_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MAX_TOTAL_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MAX_TOTAL_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MAX_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MAX_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MIN_AMOUNT_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MIN_AMOUNT_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MIN_ASSET_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MIN_ASSET_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MIN_BOOST_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MIN_BOOST_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MIN_BOOST_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MIN_BOOST_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MIN_CHAIN_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MIN_CHAIN_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MIN_LENDING_COLLATERAL_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MIN_LENDING_COLLATERAL_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MIN_LENDING_COLLATERAL_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MIN_LENDING_COLLATERAL_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MIN_LENDING_SUPPLY_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MIN_LENDING_SUPPLY_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MIN_LENDING_SUPPLY_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MIN_LENDING_SUPPLY_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MIN_LP_ID_SS58_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MIN_LP_ID_SS58_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MIN_STRATEGY_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MIN_STRATEGY_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MIN_STRATEGY_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MIN_STRATEGY_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MIN_TOTAL_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MIN_TOTAL_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MIN_TOTAL_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MIN_TOTAL_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MIN_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_MIN_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_AMOUNT_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_AMOUNT_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_ASSET_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_ASSET_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_BOOST_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_BOOST_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_BOOST_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_BOOST_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_CHAIN_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_CHAIN_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_LENDING_COLLATERAL_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_LENDING_COLLATERAL_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_LENDING_COLLATERAL_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_LENDING_COLLATERAL_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_LENDING_SUPPLY_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_LENDING_SUPPLY_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_LENDING_SUPPLY_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_LENDING_SUPPLY_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_LP_ID_SS58_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_LP_ID_SS58_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_STRATEGY_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_STRATEGY_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_STRATEGY_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_STRATEGY_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_TOTAL_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_TOTAL_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_TOTAL_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_TOTAL_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_AMOUNT_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_AMOUNT_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_ASSET_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_ASSET_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_BOOST_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_BOOST_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_BOOST_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_BOOST_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_CHAIN_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_CHAIN_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_LENDING_COLLATERAL_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_LENDING_COLLATERAL_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_LENDING_COLLATERAL_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_LENDING_COLLATERAL_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_LENDING_SUPPLY_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_LENDING_SUPPLY_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_LENDING_SUPPLY_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_LENDING_SUPPLY_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_LP_ID_SS58_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_LP_ID_SS58_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_STRATEGY_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_STRATEGY_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_STRATEGY_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_STRATEGY_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_TOTAL_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_TOTAL_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_TOTAL_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_TOTAL_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_SUM_AMOUNT_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_SUM_AMOUNT_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_SUM_ASSET_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_SUM_ASSET_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_SUM_BOOST_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_SUM_BOOST_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_SUM_BOOST_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_SUM_BOOST_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_SUM_CHAIN_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_SUM_CHAIN_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_SUM_LENDING_COLLATERAL_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_SUM_LENDING_COLLATERAL_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_SUM_LENDING_COLLATERAL_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_SUM_LENDING_COLLATERAL_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_SUM_LENDING_SUPPLY_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_SUM_LENDING_SUPPLY_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_SUM_LENDING_SUPPLY_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_SUM_LENDING_SUPPLY_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_SUM_LP_ID_SS58_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_SUM_LP_ID_SS58_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_SUM_STRATEGY_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_SUM_STRATEGY_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_SUM_STRATEGY_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_SUM_STRATEGY_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_SUM_TOTAL_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_SUM_TOTAL_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_SUM_TOTAL_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_SUM_TOTAL_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_SUM_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_SUM_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_AMOUNT_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_AMOUNT_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_ASSET_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_ASSET_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_BOOST_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_BOOST_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_BOOST_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_BOOST_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_CHAIN_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_CHAIN_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_LENDING_COLLATERAL_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_LENDING_COLLATERAL_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_LENDING_COLLATERAL_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_LENDING_COLLATERAL_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_LENDING_SUPPLY_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_LENDING_SUPPLY_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_LENDING_SUPPLY_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_LENDING_SUPPLY_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_LP_ID_SS58_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_LP_ID_SS58_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_STRATEGY_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_STRATEGY_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_STRATEGY_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_STRATEGY_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_TOTAL_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_TOTAL_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_TOTAL_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_TOTAL_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_AMOUNT_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_AMOUNT_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_ASSET_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_ASSET_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_BOOST_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_BOOST_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_BOOST_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_BOOST_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_CHAIN_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_CHAIN_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_LENDING_COLLATERAL_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_LENDING_COLLATERAL_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_LENDING_COLLATERAL_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_LENDING_COLLATERAL_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_LENDING_SUPPLY_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_LENDING_SUPPLY_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_LENDING_SUPPLY_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_LENDING_SUPPLY_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_LP_ID_SS58_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_LP_ID_SS58_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_STRATEGY_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_STRATEGY_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_STRATEGY_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_STRATEGY_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_TOTAL_BALANCE_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_TOTAL_BALANCE_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_TOTAL_BALANCE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_TOTAL_BALANCE_VALUE_USD_DESC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_VALUE_USD_ASC'
  | 'DEPOSIT_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_VALUE_USD_DESC'
  | 'EARNED_FEES_VALUE_USD_ASC'
  | 'EARNED_FEES_VALUE_USD_DESC'
  | 'FLIP_BALANCE_ASC'
  | 'FLIP_BALANCE_DESC'
  | 'ID_SS58_ASC'
  | 'ID_SS58_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_AVERAGE_ASSET_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_AVERAGE_ASSET_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_AVERAGE_LP_ID_SS58_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_AVERAGE_LP_ID_SS58_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_AVERAGE_POOL_SHARE_PERCENT_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_AVERAGE_POOL_SHARE_PERCENT_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_AVERAGE_TOTAL_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_AVERAGE_TOTAL_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_AVERAGE_TOTAL_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_AVERAGE_TOTAL_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_AVERAGE_TOTAL_AVAILABLE_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_AVERAGE_TOTAL_AVAILABLE_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_AVERAGE_TOTAL_AVAILABLE_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_AVERAGE_TOTAL_AVAILABLE_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_COUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_COUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_ASSET_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_ASSET_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_LP_ID_SS58_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_LP_ID_SS58_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_POOL_SHARE_PERCENT_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_POOL_SHARE_PERCENT_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_TOTAL_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_TOTAL_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_TOTAL_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_TOTAL_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_TOTAL_AVAILABLE_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_TOTAL_AVAILABLE_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_TOTAL_AVAILABLE_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_TOTAL_AVAILABLE_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_MAX_ASSET_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_MAX_ASSET_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_MAX_LP_ID_SS58_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_MAX_LP_ID_SS58_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_MAX_POOL_SHARE_PERCENT_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_MAX_POOL_SHARE_PERCENT_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_MAX_TOTAL_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_MAX_TOTAL_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_MAX_TOTAL_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_MAX_TOTAL_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_MAX_TOTAL_AVAILABLE_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_MAX_TOTAL_AVAILABLE_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_MAX_TOTAL_AVAILABLE_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_MAX_TOTAL_AVAILABLE_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_MIN_ASSET_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_MIN_ASSET_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_MIN_LP_ID_SS58_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_MIN_LP_ID_SS58_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_MIN_POOL_SHARE_PERCENT_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_MIN_POOL_SHARE_PERCENT_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_MIN_TOTAL_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_MIN_TOTAL_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_MIN_TOTAL_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_MIN_TOTAL_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_MIN_TOTAL_AVAILABLE_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_MIN_TOTAL_AVAILABLE_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_MIN_TOTAL_AVAILABLE_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_MIN_TOTAL_AVAILABLE_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_ASSET_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_ASSET_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_LP_ID_SS58_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_LP_ID_SS58_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_POOL_SHARE_PERCENT_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_POOL_SHARE_PERCENT_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_TOTAL_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_TOTAL_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_TOTAL_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_TOTAL_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_TOTAL_AVAILABLE_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_TOTAL_AVAILABLE_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_TOTAL_AVAILABLE_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_TOTAL_AVAILABLE_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_ASSET_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_ASSET_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_LP_ID_SS58_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_LP_ID_SS58_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_POOL_SHARE_PERCENT_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_POOL_SHARE_PERCENT_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_TOTAL_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_TOTAL_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_TOTAL_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_TOTAL_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_TOTAL_AVAILABLE_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_TOTAL_AVAILABLE_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_TOTAL_AVAILABLE_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_TOTAL_AVAILABLE_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_SUM_ASSET_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_SUM_ASSET_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_SUM_LP_ID_SS58_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_SUM_LP_ID_SS58_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_SUM_POOL_SHARE_PERCENT_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_SUM_POOL_SHARE_PERCENT_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_SUM_TOTAL_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_SUM_TOTAL_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_SUM_TOTAL_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_SUM_TOTAL_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_SUM_TOTAL_AVAILABLE_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_SUM_TOTAL_AVAILABLE_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_SUM_TOTAL_AVAILABLE_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_SUM_TOTAL_AVAILABLE_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_ASSET_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_ASSET_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_LP_ID_SS58_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_LP_ID_SS58_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_POOL_SHARE_PERCENT_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_POOL_SHARE_PERCENT_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_TOTAL_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_TOTAL_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_TOTAL_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_TOTAL_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_TOTAL_AVAILABLE_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_TOTAL_AVAILABLE_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_TOTAL_AVAILABLE_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_TOTAL_AVAILABLE_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_ASSET_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_ASSET_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_LP_ID_SS58_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_LP_ID_SS58_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_POOL_SHARE_PERCENT_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_POOL_SHARE_PERCENT_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_TOTAL_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_TOTAL_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_TOTAL_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_TOTAL_AMOUNT_USD_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_TOTAL_AVAILABLE_AMOUNT_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_TOTAL_AVAILABLE_AMOUNT_DESC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_TOTAL_AVAILABLE_AMOUNT_USD_ASC'
  | 'LP_LENDING_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_TOTAL_AVAILABLE_AMOUNT_USD_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_AVERAGE_BORROW_POWER_USED_BPS_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_AVERAGE_BORROW_POWER_USED_BPS_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_AVERAGE_LOAN_TO_VALUE_BPS_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_AVERAGE_LOAN_TO_VALUE_BPS_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_AVERAGE_LP_ID_SS58_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_AVERAGE_LP_ID_SS58_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_AVERAGE_PRIMARY_COLLATERAL_ASSET_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_AVERAGE_PRIMARY_COLLATERAL_ASSET_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_AVERAGE_TOTAL_BORROW_AMOUNT_USD_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_AVERAGE_TOTAL_BORROW_AMOUNT_USD_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_AVERAGE_TOTAL_COLLATERAL_BALANCE_USD_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_AVERAGE_TOTAL_COLLATERAL_BALANCE_USD_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_COUNT_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_COUNT_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_DISTINCT_COUNT_BORROW_POWER_USED_BPS_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_DISTINCT_COUNT_BORROW_POWER_USED_BPS_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_DISTINCT_COUNT_LOAN_TO_VALUE_BPS_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_DISTINCT_COUNT_LOAN_TO_VALUE_BPS_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_DISTINCT_COUNT_LP_ID_SS58_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_DISTINCT_COUNT_LP_ID_SS58_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_DISTINCT_COUNT_PRIMARY_COLLATERAL_ASSET_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_DISTINCT_COUNT_PRIMARY_COLLATERAL_ASSET_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_DISTINCT_COUNT_TOTAL_BORROW_AMOUNT_USD_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_DISTINCT_COUNT_TOTAL_BORROW_AMOUNT_USD_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_DISTINCT_COUNT_TOTAL_COLLATERAL_BALANCE_USD_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_DISTINCT_COUNT_TOTAL_COLLATERAL_BALANCE_USD_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_MAX_BORROW_POWER_USED_BPS_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_MAX_BORROW_POWER_USED_BPS_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_MAX_LOAN_TO_VALUE_BPS_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_MAX_LOAN_TO_VALUE_BPS_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_MAX_LP_ID_SS58_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_MAX_LP_ID_SS58_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_MAX_PRIMARY_COLLATERAL_ASSET_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_MAX_PRIMARY_COLLATERAL_ASSET_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_MAX_TOTAL_BORROW_AMOUNT_USD_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_MAX_TOTAL_BORROW_AMOUNT_USD_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_MAX_TOTAL_COLLATERAL_BALANCE_USD_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_MAX_TOTAL_COLLATERAL_BALANCE_USD_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_MIN_BORROW_POWER_USED_BPS_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_MIN_BORROW_POWER_USED_BPS_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_MIN_LOAN_TO_VALUE_BPS_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_MIN_LOAN_TO_VALUE_BPS_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_MIN_LP_ID_SS58_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_MIN_LP_ID_SS58_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_MIN_PRIMARY_COLLATERAL_ASSET_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_MIN_PRIMARY_COLLATERAL_ASSET_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_MIN_TOTAL_BORROW_AMOUNT_USD_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_MIN_TOTAL_BORROW_AMOUNT_USD_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_MIN_TOTAL_COLLATERAL_BALANCE_USD_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_MIN_TOTAL_COLLATERAL_BALANCE_USD_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_STDDEV_POPULATION_BORROW_POWER_USED_BPS_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_STDDEV_POPULATION_BORROW_POWER_USED_BPS_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_STDDEV_POPULATION_LOAN_TO_VALUE_BPS_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_STDDEV_POPULATION_LOAN_TO_VALUE_BPS_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_STDDEV_POPULATION_LP_ID_SS58_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_STDDEV_POPULATION_LP_ID_SS58_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_STDDEV_POPULATION_PRIMARY_COLLATERAL_ASSET_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_STDDEV_POPULATION_PRIMARY_COLLATERAL_ASSET_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_STDDEV_POPULATION_TOTAL_BORROW_AMOUNT_USD_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_STDDEV_POPULATION_TOTAL_BORROW_AMOUNT_USD_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_STDDEV_POPULATION_TOTAL_COLLATERAL_BALANCE_USD_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_STDDEV_POPULATION_TOTAL_COLLATERAL_BALANCE_USD_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_STDDEV_SAMPLE_BORROW_POWER_USED_BPS_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_STDDEV_SAMPLE_BORROW_POWER_USED_BPS_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_STDDEV_SAMPLE_LOAN_TO_VALUE_BPS_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_STDDEV_SAMPLE_LOAN_TO_VALUE_BPS_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_STDDEV_SAMPLE_LP_ID_SS58_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_STDDEV_SAMPLE_LP_ID_SS58_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_STDDEV_SAMPLE_PRIMARY_COLLATERAL_ASSET_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_STDDEV_SAMPLE_PRIMARY_COLLATERAL_ASSET_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_STDDEV_SAMPLE_TOTAL_BORROW_AMOUNT_USD_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_STDDEV_SAMPLE_TOTAL_BORROW_AMOUNT_USD_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_STDDEV_SAMPLE_TOTAL_COLLATERAL_BALANCE_USD_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_STDDEV_SAMPLE_TOTAL_COLLATERAL_BALANCE_USD_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_SUM_BORROW_POWER_USED_BPS_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_SUM_BORROW_POWER_USED_BPS_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_SUM_LOAN_TO_VALUE_BPS_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_SUM_LOAN_TO_VALUE_BPS_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_SUM_LP_ID_SS58_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_SUM_LP_ID_SS58_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_SUM_PRIMARY_COLLATERAL_ASSET_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_SUM_PRIMARY_COLLATERAL_ASSET_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_SUM_TOTAL_BORROW_AMOUNT_USD_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_SUM_TOTAL_BORROW_AMOUNT_USD_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_SUM_TOTAL_COLLATERAL_BALANCE_USD_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_SUM_TOTAL_COLLATERAL_BALANCE_USD_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_VARIANCE_POPULATION_BORROW_POWER_USED_BPS_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_VARIANCE_POPULATION_BORROW_POWER_USED_BPS_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_VARIANCE_POPULATION_LOAN_TO_VALUE_BPS_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_VARIANCE_POPULATION_LOAN_TO_VALUE_BPS_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_VARIANCE_POPULATION_LP_ID_SS58_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_VARIANCE_POPULATION_LP_ID_SS58_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_VARIANCE_POPULATION_PRIMARY_COLLATERAL_ASSET_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_VARIANCE_POPULATION_PRIMARY_COLLATERAL_ASSET_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_VARIANCE_POPULATION_TOTAL_BORROW_AMOUNT_USD_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_VARIANCE_POPULATION_TOTAL_BORROW_AMOUNT_USD_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_VARIANCE_POPULATION_TOTAL_COLLATERAL_BALANCE_USD_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_VARIANCE_POPULATION_TOTAL_COLLATERAL_BALANCE_USD_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_VARIANCE_SAMPLE_BORROW_POWER_USED_BPS_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_VARIANCE_SAMPLE_BORROW_POWER_USED_BPS_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_VARIANCE_SAMPLE_LOAN_TO_VALUE_BPS_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_VARIANCE_SAMPLE_LOAN_TO_VALUE_BPS_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_VARIANCE_SAMPLE_LP_ID_SS58_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_VARIANCE_SAMPLE_LP_ID_SS58_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_VARIANCE_SAMPLE_PRIMARY_COLLATERAL_ASSET_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_VARIANCE_SAMPLE_PRIMARY_COLLATERAL_ASSET_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_VARIANCE_SAMPLE_TOTAL_BORROW_AMOUNT_USD_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_VARIANCE_SAMPLE_TOTAL_BORROW_AMOUNT_USD_DESC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_VARIANCE_SAMPLE_TOTAL_COLLATERAL_BALANCE_USD_ASC'
  | 'LP_LOAN_ACCOUNTS_BY_LP_ID_SS58_VARIANCE_SAMPLE_TOTAL_COLLATERAL_BALANCE_USD_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_AVERAGE_AMOUNT_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_AVERAGE_AMOUNT_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_AVERAGE_ASSET_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_AVERAGE_ASSET_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_AVERAGE_CHAIN_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_AVERAGE_CHAIN_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_AVERAGE_CREATED_AT_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_AVERAGE_CREATED_AT_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_AVERAGE_LP_ID_SS58_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_AVERAGE_LP_ID_SS58_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_AVERAGE_UPDATED_AT_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_AVERAGE_UPDATED_AT_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_AVERAGE_VALUE_USD_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_AVERAGE_VALUE_USD_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_COUNT_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_COUNT_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_AMOUNT_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_AMOUNT_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_ASSET_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_ASSET_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_CHAIN_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_CHAIN_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_CREATED_AT_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_CREATED_AT_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_LP_ID_SS58_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_LP_ID_SS58_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_UPDATED_AT_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_UPDATED_AT_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_VALUE_USD_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_DISTINCT_COUNT_VALUE_USD_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_MAX_AMOUNT_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_MAX_AMOUNT_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_MAX_ASSET_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_MAX_ASSET_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_MAX_CHAIN_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_MAX_CHAIN_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_MAX_CREATED_AT_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_MAX_CREATED_AT_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_MAX_LP_ID_SS58_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_MAX_LP_ID_SS58_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_MAX_UPDATED_AT_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_MAX_UPDATED_AT_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_MAX_VALUE_USD_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_MAX_VALUE_USD_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_MIN_AMOUNT_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_MIN_AMOUNT_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_MIN_ASSET_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_MIN_ASSET_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_MIN_CHAIN_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_MIN_CHAIN_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_MIN_CREATED_AT_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_MIN_CREATED_AT_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_MIN_LP_ID_SS58_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_MIN_LP_ID_SS58_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_MIN_UPDATED_AT_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_MIN_UPDATED_AT_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_MIN_VALUE_USD_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_MIN_VALUE_USD_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_AMOUNT_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_AMOUNT_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_ASSET_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_ASSET_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_CHAIN_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_CHAIN_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_CREATED_AT_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_CREATED_AT_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_LP_ID_SS58_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_LP_ID_SS58_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_UPDATED_AT_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_UPDATED_AT_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_VALUE_USD_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_STDDEV_POPULATION_VALUE_USD_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_AMOUNT_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_AMOUNT_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_ASSET_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_ASSET_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_CHAIN_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_CHAIN_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_CREATED_AT_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_CREATED_AT_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_LP_ID_SS58_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_LP_ID_SS58_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_UPDATED_AT_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_UPDATED_AT_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_VALUE_USD_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_STDDEV_SAMPLE_VALUE_USD_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_SUM_AMOUNT_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_SUM_AMOUNT_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_SUM_ASSET_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_SUM_ASSET_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_SUM_CHAIN_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_SUM_CHAIN_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_SUM_CREATED_AT_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_SUM_CREATED_AT_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_SUM_LP_ID_SS58_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_SUM_LP_ID_SS58_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_SUM_UPDATED_AT_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_SUM_UPDATED_AT_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_SUM_VALUE_USD_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_SUM_VALUE_USD_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_AMOUNT_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_AMOUNT_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_ASSET_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_ASSET_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_CHAIN_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_CHAIN_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_CREATED_AT_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_CREATED_AT_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_LP_ID_SS58_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_LP_ID_SS58_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_UPDATED_AT_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_UPDATED_AT_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_VALUE_USD_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_VARIANCE_POPULATION_VALUE_USD_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_AMOUNT_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_AMOUNT_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_ASSET_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_ASSET_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_CHAIN_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_CHAIN_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_CREATED_AT_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_CREATED_AT_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_LP_ID_SS58_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_LP_ID_SS58_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_UPDATED_AT_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_UPDATED_AT_DESC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_VALUE_USD_ASC'
  | 'LP_TOTAL_BALANCES_BY_LP_ID_SS58_VARIANCE_SAMPLE_VALUE_USD_DESC'
  | 'NATURAL'
  | 'OPEN_ORDERS_ASC'
  | 'OPEN_ORDERS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_AVERAGE_BASE_ASSET_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_AVERAGE_BASE_ASSET_BALANCE_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_AVERAGE_BASE_ASSET_BALANCE_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_AVERAGE_BASE_ASSET_BALANCE_USD_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_AVERAGE_BASE_ASSET_BALANCE_USD_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_AVERAGE_BASE_ASSET_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_AVERAGE_KEY_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_AVERAGE_KEY_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_AVERAGE_OWNER_ACCOUNT_ID_SS58_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_AVERAGE_OWNER_ACCOUNT_ID_SS58_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_AVERAGE_QUOTE_ASSET_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_AVERAGE_QUOTE_ASSET_BALANCE_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_AVERAGE_QUOTE_ASSET_BALANCE_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_AVERAGE_QUOTE_ASSET_BALANCE_USD_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_AVERAGE_QUOTE_ASSET_BALANCE_USD_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_AVERAGE_QUOTE_ASSET_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_AVERAGE_STRATEGY_ACCOUNT_ID_SS58_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_AVERAGE_STRATEGY_ACCOUNT_ID_SS58_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_AVERAGE_TYPE_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_AVERAGE_TYPE_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_COUNT_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_COUNT_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_DISTINCT_COUNT_BASE_ASSET_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_DISTINCT_COUNT_BASE_ASSET_BALANCE_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_DISTINCT_COUNT_BASE_ASSET_BALANCE_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_DISTINCT_COUNT_BASE_ASSET_BALANCE_USD_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_DISTINCT_COUNT_BASE_ASSET_BALANCE_USD_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_DISTINCT_COUNT_BASE_ASSET_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_DISTINCT_COUNT_KEY_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_DISTINCT_COUNT_KEY_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_DISTINCT_COUNT_OWNER_ACCOUNT_ID_SS58_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_DISTINCT_COUNT_OWNER_ACCOUNT_ID_SS58_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_DISTINCT_COUNT_QUOTE_ASSET_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_DISTINCT_COUNT_QUOTE_ASSET_BALANCE_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_DISTINCT_COUNT_QUOTE_ASSET_BALANCE_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_DISTINCT_COUNT_QUOTE_ASSET_BALANCE_USD_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_DISTINCT_COUNT_QUOTE_ASSET_BALANCE_USD_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_DISTINCT_COUNT_QUOTE_ASSET_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_DISTINCT_COUNT_STRATEGY_ACCOUNT_ID_SS58_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_DISTINCT_COUNT_STRATEGY_ACCOUNT_ID_SS58_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_DISTINCT_COUNT_TYPE_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_DISTINCT_COUNT_TYPE_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MAX_BASE_ASSET_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MAX_BASE_ASSET_BALANCE_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MAX_BASE_ASSET_BALANCE_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MAX_BASE_ASSET_BALANCE_USD_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MAX_BASE_ASSET_BALANCE_USD_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MAX_BASE_ASSET_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MAX_KEY_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MAX_KEY_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MAX_OWNER_ACCOUNT_ID_SS58_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MAX_OWNER_ACCOUNT_ID_SS58_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MAX_QUOTE_ASSET_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MAX_QUOTE_ASSET_BALANCE_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MAX_QUOTE_ASSET_BALANCE_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MAX_QUOTE_ASSET_BALANCE_USD_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MAX_QUOTE_ASSET_BALANCE_USD_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MAX_QUOTE_ASSET_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MAX_STRATEGY_ACCOUNT_ID_SS58_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MAX_STRATEGY_ACCOUNT_ID_SS58_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MAX_TYPE_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MAX_TYPE_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MIN_BASE_ASSET_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MIN_BASE_ASSET_BALANCE_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MIN_BASE_ASSET_BALANCE_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MIN_BASE_ASSET_BALANCE_USD_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MIN_BASE_ASSET_BALANCE_USD_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MIN_BASE_ASSET_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MIN_KEY_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MIN_KEY_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MIN_OWNER_ACCOUNT_ID_SS58_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MIN_OWNER_ACCOUNT_ID_SS58_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MIN_QUOTE_ASSET_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MIN_QUOTE_ASSET_BALANCE_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MIN_QUOTE_ASSET_BALANCE_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MIN_QUOTE_ASSET_BALANCE_USD_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MIN_QUOTE_ASSET_BALANCE_USD_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MIN_QUOTE_ASSET_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MIN_STRATEGY_ACCOUNT_ID_SS58_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MIN_STRATEGY_ACCOUNT_ID_SS58_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MIN_TYPE_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_MIN_TYPE_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_POPULATION_BASE_ASSET_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_POPULATION_BASE_ASSET_BALANCE_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_POPULATION_BASE_ASSET_BALANCE_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_POPULATION_BASE_ASSET_BALANCE_USD_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_POPULATION_BASE_ASSET_BALANCE_USD_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_POPULATION_BASE_ASSET_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_POPULATION_KEY_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_POPULATION_KEY_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_POPULATION_OWNER_ACCOUNT_ID_SS58_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_POPULATION_OWNER_ACCOUNT_ID_SS58_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_POPULATION_QUOTE_ASSET_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_POPULATION_QUOTE_ASSET_BALANCE_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_POPULATION_QUOTE_ASSET_BALANCE_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_POPULATION_QUOTE_ASSET_BALANCE_USD_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_POPULATION_QUOTE_ASSET_BALANCE_USD_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_POPULATION_QUOTE_ASSET_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_POPULATION_STRATEGY_ACCOUNT_ID_SS58_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_POPULATION_STRATEGY_ACCOUNT_ID_SS58_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_POPULATION_TYPE_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_POPULATION_TYPE_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_SAMPLE_BASE_ASSET_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_SAMPLE_BASE_ASSET_BALANCE_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_SAMPLE_BASE_ASSET_BALANCE_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_SAMPLE_BASE_ASSET_BALANCE_USD_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_SAMPLE_BASE_ASSET_BALANCE_USD_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_SAMPLE_BASE_ASSET_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_SAMPLE_KEY_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_SAMPLE_KEY_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_SAMPLE_OWNER_ACCOUNT_ID_SS58_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_SAMPLE_OWNER_ACCOUNT_ID_SS58_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_SAMPLE_QUOTE_ASSET_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_SAMPLE_QUOTE_ASSET_BALANCE_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_SAMPLE_QUOTE_ASSET_BALANCE_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_SAMPLE_QUOTE_ASSET_BALANCE_USD_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_SAMPLE_QUOTE_ASSET_BALANCE_USD_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_SAMPLE_QUOTE_ASSET_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_SAMPLE_STRATEGY_ACCOUNT_ID_SS58_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_SAMPLE_STRATEGY_ACCOUNT_ID_SS58_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_SAMPLE_TYPE_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_STDDEV_SAMPLE_TYPE_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_SUM_BASE_ASSET_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_SUM_BASE_ASSET_BALANCE_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_SUM_BASE_ASSET_BALANCE_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_SUM_BASE_ASSET_BALANCE_USD_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_SUM_BASE_ASSET_BALANCE_USD_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_SUM_BASE_ASSET_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_SUM_KEY_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_SUM_KEY_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_SUM_OWNER_ACCOUNT_ID_SS58_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_SUM_OWNER_ACCOUNT_ID_SS58_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_SUM_QUOTE_ASSET_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_SUM_QUOTE_ASSET_BALANCE_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_SUM_QUOTE_ASSET_BALANCE_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_SUM_QUOTE_ASSET_BALANCE_USD_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_SUM_QUOTE_ASSET_BALANCE_USD_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_SUM_QUOTE_ASSET_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_SUM_STRATEGY_ACCOUNT_ID_SS58_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_SUM_STRATEGY_ACCOUNT_ID_SS58_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_SUM_TYPE_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_SUM_TYPE_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_POPULATION_BASE_ASSET_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_POPULATION_BASE_ASSET_BALANCE_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_POPULATION_BASE_ASSET_BALANCE_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_POPULATION_BASE_ASSET_BALANCE_USD_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_POPULATION_BASE_ASSET_BALANCE_USD_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_POPULATION_BASE_ASSET_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_POPULATION_KEY_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_POPULATION_KEY_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_POPULATION_OWNER_ACCOUNT_ID_SS58_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_POPULATION_OWNER_ACCOUNT_ID_SS58_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_POPULATION_QUOTE_ASSET_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_POPULATION_QUOTE_ASSET_BALANCE_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_POPULATION_QUOTE_ASSET_BALANCE_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_POPULATION_QUOTE_ASSET_BALANCE_USD_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_POPULATION_QUOTE_ASSET_BALANCE_USD_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_POPULATION_QUOTE_ASSET_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_POPULATION_STRATEGY_ACCOUNT_ID_SS58_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_POPULATION_STRATEGY_ACCOUNT_ID_SS58_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_POPULATION_TYPE_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_POPULATION_TYPE_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_SAMPLE_BASE_ASSET_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_SAMPLE_BASE_ASSET_BALANCE_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_SAMPLE_BASE_ASSET_BALANCE_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_SAMPLE_BASE_ASSET_BALANCE_USD_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_SAMPLE_BASE_ASSET_BALANCE_USD_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_SAMPLE_BASE_ASSET_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_SAMPLE_KEY_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_SAMPLE_KEY_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_SAMPLE_OWNER_ACCOUNT_ID_SS58_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_SAMPLE_OWNER_ACCOUNT_ID_SS58_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_SAMPLE_QUOTE_ASSET_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_SAMPLE_QUOTE_ASSET_BALANCE_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_SAMPLE_QUOTE_ASSET_BALANCE_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_SAMPLE_QUOTE_ASSET_BALANCE_USD_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_SAMPLE_QUOTE_ASSET_BALANCE_USD_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_SAMPLE_QUOTE_ASSET_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_SAMPLE_STRATEGY_ACCOUNT_ID_SS58_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_SAMPLE_STRATEGY_ACCOUNT_ID_SS58_DESC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_SAMPLE_TYPE_ASC'
  | 'TRADING_STRATEGIES_BY_OWNER_ACCOUNT_ID_SS58_VARIANCE_SAMPLE_TYPE_DESC';

export type LpCollateralBalance = {
  __typename?: 'LpCollateralBalance';
  amount: Scalars['BigFloat']['output'];
  amountUsd: Scalars['BigFloat']['output'];
  asset: ChainflipAsset;
  loanAccountLpIdSs58: Scalars['String']['output'];
  /** Reads a single `LpLoanAccount` that is related to this `LpCollateralBalance`. */
  lpLoanAccountByLoanAccountLpIdSs58: LpLoanAccount;
};

export type LpCollateralBalanceAggregates = {
  __typename?: 'LpCollateralBalanceAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<LpCollateralBalanceAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<LpCollateralBalanceDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<LpCollateralBalanceMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<LpCollateralBalanceMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<LpCollateralBalanceStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<LpCollateralBalanceStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<LpCollateralBalanceSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<LpCollateralBalanceVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<LpCollateralBalanceVarianceSampleAggregates>;
};

/** A filter to be used against aggregates of `LpCollateralBalance` object types. */
export type LpCollateralBalanceAggregatesFilter = {
  /** Mean average aggregate over matching `LpCollateralBalance` objects. */
  average?: InputMaybe<LpCollateralBalanceAverageAggregateFilter>;
  /** Distinct count aggregate over matching `LpCollateralBalance` objects. */
  distinctCount?: InputMaybe<LpCollateralBalanceDistinctCountAggregateFilter>;
  /** A filter that must pass for the relevant `LpCollateralBalance` object to be included within the aggregate. */
  filter?: InputMaybe<LpCollateralBalanceFilter>;
  /** Maximum aggregate over matching `LpCollateralBalance` objects. */
  max?: InputMaybe<LpCollateralBalanceMaxAggregateFilter>;
  /** Minimum aggregate over matching `LpCollateralBalance` objects. */
  min?: InputMaybe<LpCollateralBalanceMinAggregateFilter>;
  /** Population standard deviation aggregate over matching `LpCollateralBalance` objects. */
  stddevPopulation?: InputMaybe<LpCollateralBalanceStddevPopulationAggregateFilter>;
  /** Sample standard deviation aggregate over matching `LpCollateralBalance` objects. */
  stddevSample?: InputMaybe<LpCollateralBalanceStddevSampleAggregateFilter>;
  /** Sum aggregate over matching `LpCollateralBalance` objects. */
  sum?: InputMaybe<LpCollateralBalanceSumAggregateFilter>;
  /** Population variance aggregate over matching `LpCollateralBalance` objects. */
  variancePopulation?: InputMaybe<LpCollateralBalanceVariancePopulationAggregateFilter>;
  /** Sample variance aggregate over matching `LpCollateralBalance` objects. */
  varianceSample?: InputMaybe<LpCollateralBalanceVarianceSampleAggregateFilter>;
};

export type LpCollateralBalanceAverageAggregateFilter = {
  amount?: InputMaybe<BigFloatFilter>;
  amountUsd?: InputMaybe<BigFloatFilter>;
};

export type LpCollateralBalanceAverageAggregates = {
  __typename?: 'LpCollateralBalanceAverageAggregates';
  /** Mean average of amount across the matching connection */
  amount?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of amountUsd across the matching connection */
  amountUsd?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `LpCollateralBalance` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type LpCollateralBalanceCondition = {
  /** Checks for equality with the object’s `amount` field. */
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `amountUsd` field. */
  amountUsd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `asset` field. */
  asset?: InputMaybe<ChainflipAsset>;
  /** Checks for equality with the object’s `loanAccountLpIdSs58` field. */
  loanAccountLpIdSs58?: InputMaybe<Scalars['String']['input']>;
};

export type LpCollateralBalanceDistinctCountAggregateFilter = {
  amount?: InputMaybe<BigIntFilter>;
  amountUsd?: InputMaybe<BigIntFilter>;
  asset?: InputMaybe<BigIntFilter>;
  loanAccountLpIdSs58?: InputMaybe<BigIntFilter>;
};

export type LpCollateralBalanceDistinctCountAggregates = {
  __typename?: 'LpCollateralBalanceDistinctCountAggregates';
  /** Distinct count of amount across the matching connection */
  amount?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of amountUsd across the matching connection */
  amountUsd?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of asset across the matching connection */
  asset?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of loanAccountLpIdSs58 across the matching connection */
  loanAccountLpIdSs58?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `LpCollateralBalance` object types. All fields are combined with a logical ‘and.’ */
export type LpCollateralBalanceFilter = {
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `amountUsd` field. */
  amountUsd?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<LpCollateralBalanceFilter>>;
  /** Filter by the object’s `asset` field. */
  asset?: InputMaybe<ChainflipAssetFilter>;
  /** Filter by the object’s `loanAccountLpIdSs58` field. */
  loanAccountLpIdSs58?: InputMaybe<StringFilter>;
  /** Filter by the object’s `lpLoanAccountByLoanAccountLpIdSs58` relation. */
  lpLoanAccountByLoanAccountLpIdSs58?: InputMaybe<LpLoanAccountFilter>;
  /** Negates the expression. */
  not?: InputMaybe<LpCollateralBalanceFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<LpCollateralBalanceFilter>>;
};

/** Grouping methods for `LpCollateralBalance` for usage during aggregation. */
export type LpCollateralBalanceGroupBy =
  | 'AMOUNT'
  | 'AMOUNT_USD'
  | 'ASSET'
  | 'LOAN_ACCOUNT_LP_ID_SS58';

export type LpCollateralBalanceHavingAverageInput = {
  amount?: InputMaybe<HavingBigfloatFilter>;
  amountUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LpCollateralBalanceHavingDistinctCountInput = {
  amount?: InputMaybe<HavingBigfloatFilter>;
  amountUsd?: InputMaybe<HavingBigfloatFilter>;
};

/** Conditions for `LpCollateralBalance` aggregates. */
export type LpCollateralBalanceHavingInput = {
  AND?: InputMaybe<Array<LpCollateralBalanceHavingInput>>;
  OR?: InputMaybe<Array<LpCollateralBalanceHavingInput>>;
  average?: InputMaybe<LpCollateralBalanceHavingAverageInput>;
  distinctCount?: InputMaybe<LpCollateralBalanceHavingDistinctCountInput>;
  max?: InputMaybe<LpCollateralBalanceHavingMaxInput>;
  min?: InputMaybe<LpCollateralBalanceHavingMinInput>;
  stddevPopulation?: InputMaybe<LpCollateralBalanceHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<LpCollateralBalanceHavingStddevSampleInput>;
  sum?: InputMaybe<LpCollateralBalanceHavingSumInput>;
  variancePopulation?: InputMaybe<LpCollateralBalanceHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<LpCollateralBalanceHavingVarianceSampleInput>;
};

export type LpCollateralBalanceHavingMaxInput = {
  amount?: InputMaybe<HavingBigfloatFilter>;
  amountUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LpCollateralBalanceHavingMinInput = {
  amount?: InputMaybe<HavingBigfloatFilter>;
  amountUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LpCollateralBalanceHavingStddevPopulationInput = {
  amount?: InputMaybe<HavingBigfloatFilter>;
  amountUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LpCollateralBalanceHavingStddevSampleInput = {
  amount?: InputMaybe<HavingBigfloatFilter>;
  amountUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LpCollateralBalanceHavingSumInput = {
  amount?: InputMaybe<HavingBigfloatFilter>;
  amountUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LpCollateralBalanceHavingVariancePopulationInput = {
  amount?: InputMaybe<HavingBigfloatFilter>;
  amountUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LpCollateralBalanceHavingVarianceSampleInput = {
  amount?: InputMaybe<HavingBigfloatFilter>;
  amountUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LpCollateralBalanceMaxAggregateFilter = {
  amount?: InputMaybe<BigFloatFilter>;
  amountUsd?: InputMaybe<BigFloatFilter>;
};

export type LpCollateralBalanceMaxAggregates = {
  __typename?: 'LpCollateralBalanceMaxAggregates';
  /** Maximum of amount across the matching connection */
  amount?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of amountUsd across the matching connection */
  amountUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type LpCollateralBalanceMinAggregateFilter = {
  amount?: InputMaybe<BigFloatFilter>;
  amountUsd?: InputMaybe<BigFloatFilter>;
};

export type LpCollateralBalanceMinAggregates = {
  __typename?: 'LpCollateralBalanceMinAggregates';
  /** Minimum of amount across the matching connection */
  amount?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of amountUsd across the matching connection */
  amountUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type LpCollateralBalanceStddevPopulationAggregateFilter = {
  amount?: InputMaybe<BigFloatFilter>;
  amountUsd?: InputMaybe<BigFloatFilter>;
};

export type LpCollateralBalanceStddevPopulationAggregates = {
  __typename?: 'LpCollateralBalanceStddevPopulationAggregates';
  /** Population standard deviation of amount across the matching connection */
  amount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of amountUsd across the matching connection */
  amountUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type LpCollateralBalanceStddevSampleAggregateFilter = {
  amount?: InputMaybe<BigFloatFilter>;
  amountUsd?: InputMaybe<BigFloatFilter>;
};

export type LpCollateralBalanceStddevSampleAggregates = {
  __typename?: 'LpCollateralBalanceStddevSampleAggregates';
  /** Sample standard deviation of amount across the matching connection */
  amount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of amountUsd across the matching connection */
  amountUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type LpCollateralBalanceSumAggregateFilter = {
  amount?: InputMaybe<BigFloatFilter>;
  amountUsd?: InputMaybe<BigFloatFilter>;
};

export type LpCollateralBalanceSumAggregates = {
  __typename?: 'LpCollateralBalanceSumAggregates';
  /** Sum of amount across the matching connection */
  amount: Scalars['BigFloat']['output'];
  /** Sum of amountUsd across the matching connection */
  amountUsd: Scalars['BigFloat']['output'];
};

export type LpCollateralBalanceVariancePopulationAggregateFilter = {
  amount?: InputMaybe<BigFloatFilter>;
  amountUsd?: InputMaybe<BigFloatFilter>;
};

export type LpCollateralBalanceVariancePopulationAggregates = {
  __typename?: 'LpCollateralBalanceVariancePopulationAggregates';
  /** Population variance of amount across the matching connection */
  amount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of amountUsd across the matching connection */
  amountUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type LpCollateralBalanceVarianceSampleAggregateFilter = {
  amount?: InputMaybe<BigFloatFilter>;
  amountUsd?: InputMaybe<BigFloatFilter>;
};

export type LpCollateralBalanceVarianceSampleAggregates = {
  __typename?: 'LpCollateralBalanceVarianceSampleAggregates';
  /** Sample variance of amount across the matching connection */
  amount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of amountUsd across the matching connection */
  amountUsd?: Maybe<Scalars['BigFloat']['output']>;
};

/** A connection to a list of `LpCollateralBalance` values. */
export type LpCollateralBalancesConnection = {
  __typename?: 'LpCollateralBalancesConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<LpCollateralBalanceAggregates>;
  /** A list of edges which contains the `LpCollateralBalance` and cursor to aid in pagination. */
  edges: Array<LpCollateralBalancesEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<LpCollateralBalanceAggregates>>;
  /** A list of `LpCollateralBalance` objects. */
  nodes: Array<LpCollateralBalance>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `LpCollateralBalance` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `LpCollateralBalance` values. */
export type LpCollateralBalancesConnectionGroupedAggregatesArgs = {
  groupBy: Array<LpCollateralBalanceGroupBy>;
  having?: InputMaybe<LpCollateralBalanceHavingInput>;
};

/** A `LpCollateralBalance` edge in the connection. */
export type LpCollateralBalancesEdge = {
  __typename?: 'LpCollateralBalancesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `LpCollateralBalance` at the end of the edge. */
  node: LpCollateralBalance;
};

/** Methods to use when ordering `LpCollateralBalance`. */
export type LpCollateralBalancesOrderBy =
  | 'AMOUNT_ASC'
  | 'AMOUNT_DESC'
  | 'AMOUNT_USD_ASC'
  | 'AMOUNT_USD_DESC'
  | 'ASSET_ASC'
  | 'ASSET_DESC'
  | 'LOAN_ACCOUNT_LP_ID_SS58_ASC'
  | 'LOAN_ACCOUNT_LP_ID_SS58_DESC'
  | 'NATURAL';

export type LpLendingBalance = {
  __typename?: 'LpLendingBalance';
  asset: ChainflipAsset;
  /** Reads a single `LendingPool` that is related to this `LpLendingBalance`. */
  lendingPoolByAsset: LendingPool;
  /** Reads a single `LpAccount` that is related to this `LpLendingBalance`. */
  lpAccountByLpIdSs58: LpAccount;
  lpIdSs58: Scalars['String']['output'];
  poolSharePercent: Scalars['Float']['output'];
  totalAmount: Scalars['BigFloat']['output'];
  totalAmountUsd: Scalars['BigFloat']['output'];
  totalAvailableAmount: Scalars['BigFloat']['output'];
  totalAvailableAmountUsd: Scalars['BigFloat']['output'];
};

export type LpLendingBalanceAggregates = {
  __typename?: 'LpLendingBalanceAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<LpLendingBalanceAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<LpLendingBalanceDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<LpLendingBalanceMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<LpLendingBalanceMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<LpLendingBalanceStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<LpLendingBalanceStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<LpLendingBalanceSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<LpLendingBalanceVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<LpLendingBalanceVarianceSampleAggregates>;
};

/** A filter to be used against aggregates of `LpLendingBalance` object types. */
export type LpLendingBalanceAggregatesFilter = {
  /** Mean average aggregate over matching `LpLendingBalance` objects. */
  average?: InputMaybe<LpLendingBalanceAverageAggregateFilter>;
  /** Distinct count aggregate over matching `LpLendingBalance` objects. */
  distinctCount?: InputMaybe<LpLendingBalanceDistinctCountAggregateFilter>;
  /** A filter that must pass for the relevant `LpLendingBalance` object to be included within the aggregate. */
  filter?: InputMaybe<LpLendingBalanceFilter>;
  /** Maximum aggregate over matching `LpLendingBalance` objects. */
  max?: InputMaybe<LpLendingBalanceMaxAggregateFilter>;
  /** Minimum aggregate over matching `LpLendingBalance` objects. */
  min?: InputMaybe<LpLendingBalanceMinAggregateFilter>;
  /** Population standard deviation aggregate over matching `LpLendingBalance` objects. */
  stddevPopulation?: InputMaybe<LpLendingBalanceStddevPopulationAggregateFilter>;
  /** Sample standard deviation aggregate over matching `LpLendingBalance` objects. */
  stddevSample?: InputMaybe<LpLendingBalanceStddevSampleAggregateFilter>;
  /** Sum aggregate over matching `LpLendingBalance` objects. */
  sum?: InputMaybe<LpLendingBalanceSumAggregateFilter>;
  /** Population variance aggregate over matching `LpLendingBalance` objects. */
  variancePopulation?: InputMaybe<LpLendingBalanceVariancePopulationAggregateFilter>;
  /** Sample variance aggregate over matching `LpLendingBalance` objects. */
  varianceSample?: InputMaybe<LpLendingBalanceVarianceSampleAggregateFilter>;
};

export type LpLendingBalanceAverageAggregateFilter = {
  poolSharePercent?: InputMaybe<FloatFilter>;
  totalAmount?: InputMaybe<BigFloatFilter>;
  totalAmountUsd?: InputMaybe<BigFloatFilter>;
  totalAvailableAmount?: InputMaybe<BigFloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<BigFloatFilter>;
};

export type LpLendingBalanceAverageAggregates = {
  __typename?: 'LpLendingBalanceAverageAggregates';
  /** Mean average of poolSharePercent across the matching connection */
  poolSharePercent?: Maybe<Scalars['Float']['output']>;
  /** Mean average of totalAmount across the matching connection */
  totalAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of totalAmountUsd across the matching connection */
  totalAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of totalAvailableAmount across the matching connection */
  totalAvailableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of totalAvailableAmountUsd across the matching connection */
  totalAvailableAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `LpLendingBalance` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type LpLendingBalanceCondition = {
  /** Checks for equality with the object’s `asset` field. */
  asset?: InputMaybe<ChainflipAsset>;
  /** Checks for equality with the object’s `lpIdSs58` field. */
  lpIdSs58?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `poolSharePercent` field. */
  poolSharePercent?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `totalAmount` field. */
  totalAmount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalAmountUsd` field. */
  totalAmountUsd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalAvailableAmount` field. */
  totalAvailableAmount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalAvailableAmountUsd` field. */
  totalAvailableAmountUsd?: InputMaybe<Scalars['BigFloat']['input']>;
};

export type LpLendingBalanceDistinctCountAggregateFilter = {
  asset?: InputMaybe<BigIntFilter>;
  lpIdSs58?: InputMaybe<BigIntFilter>;
  poolSharePercent?: InputMaybe<BigIntFilter>;
  totalAmount?: InputMaybe<BigIntFilter>;
  totalAmountUsd?: InputMaybe<BigIntFilter>;
  totalAvailableAmount?: InputMaybe<BigIntFilter>;
  totalAvailableAmountUsd?: InputMaybe<BigIntFilter>;
};

export type LpLendingBalanceDistinctCountAggregates = {
  __typename?: 'LpLendingBalanceDistinctCountAggregates';
  /** Distinct count of asset across the matching connection */
  asset?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of lpIdSs58 across the matching connection */
  lpIdSs58?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of poolSharePercent across the matching connection */
  poolSharePercent?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of totalAmount across the matching connection */
  totalAmount?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of totalAmountUsd across the matching connection */
  totalAmountUsd?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of totalAvailableAmount across the matching connection */
  totalAvailableAmount?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of totalAvailableAmountUsd across the matching connection */
  totalAvailableAmountUsd?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `LpLendingBalance` object types. All fields are combined with a logical ‘and.’ */
export type LpLendingBalanceFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<LpLendingBalanceFilter>>;
  /** Filter by the object’s `asset` field. */
  asset?: InputMaybe<ChainflipAssetFilter>;
  /** Filter by the object’s `lendingPoolByAsset` relation. */
  lendingPoolByAsset?: InputMaybe<LendingPoolFilter>;
  /** Filter by the object’s `lpAccountByLpIdSs58` relation. */
  lpAccountByLpIdSs58?: InputMaybe<LpAccountFilter>;
  /** Filter by the object’s `lpIdSs58` field. */
  lpIdSs58?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<LpLendingBalanceFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<LpLendingBalanceFilter>>;
  /** Filter by the object’s `poolSharePercent` field. */
  poolSharePercent?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `totalAmount` field. */
  totalAmount?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalAmountUsd` field. */
  totalAmountUsd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalAvailableAmount` field. */
  totalAvailableAmount?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalAvailableAmountUsd` field. */
  totalAvailableAmountUsd?: InputMaybe<BigFloatFilter>;
};

/** Grouping methods for `LpLendingBalance` for usage during aggregation. */
export type LpLendingBalanceGroupBy =
  | 'ASSET'
  | 'LP_ID_SS58'
  | 'POOL_SHARE_PERCENT'
  | 'TOTAL_AMOUNT'
  | 'TOTAL_AMOUNT_USD'
  | 'TOTAL_AVAILABLE_AMOUNT'
  | 'TOTAL_AVAILABLE_AMOUNT_USD';

export type LpLendingBalanceHavingAverageInput = {
  poolSharePercent?: InputMaybe<HavingFloatFilter>;
  totalAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LpLendingBalanceHavingDistinctCountInput = {
  poolSharePercent?: InputMaybe<HavingFloatFilter>;
  totalAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<HavingBigfloatFilter>;
};

/** Conditions for `LpLendingBalance` aggregates. */
export type LpLendingBalanceHavingInput = {
  AND?: InputMaybe<Array<LpLendingBalanceHavingInput>>;
  OR?: InputMaybe<Array<LpLendingBalanceHavingInput>>;
  average?: InputMaybe<LpLendingBalanceHavingAverageInput>;
  distinctCount?: InputMaybe<LpLendingBalanceHavingDistinctCountInput>;
  max?: InputMaybe<LpLendingBalanceHavingMaxInput>;
  min?: InputMaybe<LpLendingBalanceHavingMinInput>;
  stddevPopulation?: InputMaybe<LpLendingBalanceHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<LpLendingBalanceHavingStddevSampleInput>;
  sum?: InputMaybe<LpLendingBalanceHavingSumInput>;
  variancePopulation?: InputMaybe<LpLendingBalanceHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<LpLendingBalanceHavingVarianceSampleInput>;
};

export type LpLendingBalanceHavingMaxInput = {
  poolSharePercent?: InputMaybe<HavingFloatFilter>;
  totalAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LpLendingBalanceHavingMinInput = {
  poolSharePercent?: InputMaybe<HavingFloatFilter>;
  totalAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LpLendingBalanceHavingStddevPopulationInput = {
  poolSharePercent?: InputMaybe<HavingFloatFilter>;
  totalAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LpLendingBalanceHavingStddevSampleInput = {
  poolSharePercent?: InputMaybe<HavingFloatFilter>;
  totalAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LpLendingBalanceHavingSumInput = {
  poolSharePercent?: InputMaybe<HavingFloatFilter>;
  totalAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LpLendingBalanceHavingVariancePopulationInput = {
  poolSharePercent?: InputMaybe<HavingFloatFilter>;
  totalAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LpLendingBalanceHavingVarianceSampleInput = {
  poolSharePercent?: InputMaybe<HavingFloatFilter>;
  totalAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmount?: InputMaybe<HavingBigfloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LpLendingBalanceMaxAggregateFilter = {
  poolSharePercent?: InputMaybe<FloatFilter>;
  totalAmount?: InputMaybe<BigFloatFilter>;
  totalAmountUsd?: InputMaybe<BigFloatFilter>;
  totalAvailableAmount?: InputMaybe<BigFloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<BigFloatFilter>;
};

export type LpLendingBalanceMaxAggregates = {
  __typename?: 'LpLendingBalanceMaxAggregates';
  /** Maximum of poolSharePercent across the matching connection */
  poolSharePercent?: Maybe<Scalars['Float']['output']>;
  /** Maximum of totalAmount across the matching connection */
  totalAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of totalAmountUsd across the matching connection */
  totalAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of totalAvailableAmount across the matching connection */
  totalAvailableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of totalAvailableAmountUsd across the matching connection */
  totalAvailableAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type LpLendingBalanceMinAggregateFilter = {
  poolSharePercent?: InputMaybe<FloatFilter>;
  totalAmount?: InputMaybe<BigFloatFilter>;
  totalAmountUsd?: InputMaybe<BigFloatFilter>;
  totalAvailableAmount?: InputMaybe<BigFloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<BigFloatFilter>;
};

export type LpLendingBalanceMinAggregates = {
  __typename?: 'LpLendingBalanceMinAggregates';
  /** Minimum of poolSharePercent across the matching connection */
  poolSharePercent?: Maybe<Scalars['Float']['output']>;
  /** Minimum of totalAmount across the matching connection */
  totalAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of totalAmountUsd across the matching connection */
  totalAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of totalAvailableAmount across the matching connection */
  totalAvailableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of totalAvailableAmountUsd across the matching connection */
  totalAvailableAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type LpLendingBalanceStddevPopulationAggregateFilter = {
  poolSharePercent?: InputMaybe<FloatFilter>;
  totalAmount?: InputMaybe<BigFloatFilter>;
  totalAmountUsd?: InputMaybe<BigFloatFilter>;
  totalAvailableAmount?: InputMaybe<BigFloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<BigFloatFilter>;
};

export type LpLendingBalanceStddevPopulationAggregates = {
  __typename?: 'LpLendingBalanceStddevPopulationAggregates';
  /** Population standard deviation of poolSharePercent across the matching connection */
  poolSharePercent?: Maybe<Scalars['Float']['output']>;
  /** Population standard deviation of totalAmount across the matching connection */
  totalAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of totalAmountUsd across the matching connection */
  totalAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of totalAvailableAmount across the matching connection */
  totalAvailableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of totalAvailableAmountUsd across the matching connection */
  totalAvailableAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type LpLendingBalanceStddevSampleAggregateFilter = {
  poolSharePercent?: InputMaybe<FloatFilter>;
  totalAmount?: InputMaybe<BigFloatFilter>;
  totalAmountUsd?: InputMaybe<BigFloatFilter>;
  totalAvailableAmount?: InputMaybe<BigFloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<BigFloatFilter>;
};

export type LpLendingBalanceStddevSampleAggregates = {
  __typename?: 'LpLendingBalanceStddevSampleAggregates';
  /** Sample standard deviation of poolSharePercent across the matching connection */
  poolSharePercent?: Maybe<Scalars['Float']['output']>;
  /** Sample standard deviation of totalAmount across the matching connection */
  totalAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of totalAmountUsd across the matching connection */
  totalAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of totalAvailableAmount across the matching connection */
  totalAvailableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of totalAvailableAmountUsd across the matching connection */
  totalAvailableAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type LpLendingBalanceSumAggregateFilter = {
  poolSharePercent?: InputMaybe<FloatFilter>;
  totalAmount?: InputMaybe<BigFloatFilter>;
  totalAmountUsd?: InputMaybe<BigFloatFilter>;
  totalAvailableAmount?: InputMaybe<BigFloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<BigFloatFilter>;
};

export type LpLendingBalanceSumAggregates = {
  __typename?: 'LpLendingBalanceSumAggregates';
  /** Sum of poolSharePercent across the matching connection */
  poolSharePercent: Scalars['Float']['output'];
  /** Sum of totalAmount across the matching connection */
  totalAmount: Scalars['BigFloat']['output'];
  /** Sum of totalAmountUsd across the matching connection */
  totalAmountUsd: Scalars['BigFloat']['output'];
  /** Sum of totalAvailableAmount across the matching connection */
  totalAvailableAmount: Scalars['BigFloat']['output'];
  /** Sum of totalAvailableAmountUsd across the matching connection */
  totalAvailableAmountUsd: Scalars['BigFloat']['output'];
};

export type LpLendingBalanceVariancePopulationAggregateFilter = {
  poolSharePercent?: InputMaybe<FloatFilter>;
  totalAmount?: InputMaybe<BigFloatFilter>;
  totalAmountUsd?: InputMaybe<BigFloatFilter>;
  totalAvailableAmount?: InputMaybe<BigFloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<BigFloatFilter>;
};

export type LpLendingBalanceVariancePopulationAggregates = {
  __typename?: 'LpLendingBalanceVariancePopulationAggregates';
  /** Population variance of poolSharePercent across the matching connection */
  poolSharePercent?: Maybe<Scalars['Float']['output']>;
  /** Population variance of totalAmount across the matching connection */
  totalAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of totalAmountUsd across the matching connection */
  totalAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of totalAvailableAmount across the matching connection */
  totalAvailableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of totalAvailableAmountUsd across the matching connection */
  totalAvailableAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type LpLendingBalanceVarianceSampleAggregateFilter = {
  poolSharePercent?: InputMaybe<FloatFilter>;
  totalAmount?: InputMaybe<BigFloatFilter>;
  totalAmountUsd?: InputMaybe<BigFloatFilter>;
  totalAvailableAmount?: InputMaybe<BigFloatFilter>;
  totalAvailableAmountUsd?: InputMaybe<BigFloatFilter>;
};

export type LpLendingBalanceVarianceSampleAggregates = {
  __typename?: 'LpLendingBalanceVarianceSampleAggregates';
  /** Sample variance of poolSharePercent across the matching connection */
  poolSharePercent?: Maybe<Scalars['Float']['output']>;
  /** Sample variance of totalAmount across the matching connection */
  totalAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of totalAmountUsd across the matching connection */
  totalAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of totalAvailableAmount across the matching connection */
  totalAvailableAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of totalAvailableAmountUsd across the matching connection */
  totalAvailableAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
};

/** A connection to a list of `LpLendingBalance` values. */
export type LpLendingBalancesConnection = {
  __typename?: 'LpLendingBalancesConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<LpLendingBalanceAggregates>;
  /** A list of edges which contains the `LpLendingBalance` and cursor to aid in pagination. */
  edges: Array<LpLendingBalancesEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<LpLendingBalanceAggregates>>;
  /** A list of `LpLendingBalance` objects. */
  nodes: Array<LpLendingBalance>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `LpLendingBalance` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `LpLendingBalance` values. */
export type LpLendingBalancesConnectionGroupedAggregatesArgs = {
  groupBy: Array<LpLendingBalanceGroupBy>;
  having?: InputMaybe<LpLendingBalanceHavingInput>;
};

/** A `LpLendingBalance` edge in the connection. */
export type LpLendingBalancesEdge = {
  __typename?: 'LpLendingBalancesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `LpLendingBalance` at the end of the edge. */
  node: LpLendingBalance;
};

/** Methods to use when ordering `LpLendingBalance`. */
export type LpLendingBalancesOrderBy =
  | 'ASSET_ASC'
  | 'ASSET_DESC'
  | 'LP_ID_SS58_ASC'
  | 'LP_ID_SS58_DESC'
  | 'NATURAL'
  | 'POOL_SHARE_PERCENT_ASC'
  | 'POOL_SHARE_PERCENT_DESC'
  | 'TOTAL_AMOUNT_ASC'
  | 'TOTAL_AMOUNT_DESC'
  | 'TOTAL_AMOUNT_USD_ASC'
  | 'TOTAL_AMOUNT_USD_DESC'
  | 'TOTAL_AVAILABLE_AMOUNT_ASC'
  | 'TOTAL_AVAILABLE_AMOUNT_DESC'
  | 'TOTAL_AVAILABLE_AMOUNT_USD_ASC'
  | 'TOTAL_AVAILABLE_AMOUNT_USD_DESC';

export type LpLoanAccount = {
  __typename?: 'LpLoanAccount';
  borrowPowerUsedBps: Scalars['Int']['output'];
  loanToValueBps: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `Loan`. */
  loansByLoanAccountLpIdSs58: LoansConnection;
  /** Reads a single `LpAccount` that is related to this `LpLoanAccount`. */
  lpAccountByLpIdSs58: LpAccount;
  /** Reads and enables pagination through a set of `LpCollateralBalance`. */
  lpCollateralBalancesByLoanAccountLpIdSs58: LpCollateralBalancesConnection;
  lpIdSs58: Scalars['String']['output'];
  primaryCollateralAsset?: Maybe<ChainflipAsset>;
  totalBorrowAmountUsd: Scalars['BigFloat']['output'];
  totalCollateralBalanceUsd: Scalars['BigFloat']['output'];
};


export type LpLoanAccountLoansByLoanAccountLpIdSs58Args = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LoanCondition>;
  filter?: InputMaybe<LoanFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LoansOrderBy>>;
};


export type LpLoanAccountLpCollateralBalancesByLoanAccountLpIdSs58Args = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LpCollateralBalanceCondition>;
  filter?: InputMaybe<LpCollateralBalanceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LpCollateralBalancesOrderBy>>;
};

export type LpLoanAccountAggregates = {
  __typename?: 'LpLoanAccountAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<LpLoanAccountAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<LpLoanAccountDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<LpLoanAccountMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<LpLoanAccountMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<LpLoanAccountStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<LpLoanAccountStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<LpLoanAccountSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<LpLoanAccountVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<LpLoanAccountVarianceSampleAggregates>;
};

/** A filter to be used against aggregates of `LpLoanAccount` object types. */
export type LpLoanAccountAggregatesFilter = {
  /** Mean average aggregate over matching `LpLoanAccount` objects. */
  average?: InputMaybe<LpLoanAccountAverageAggregateFilter>;
  /** Distinct count aggregate over matching `LpLoanAccount` objects. */
  distinctCount?: InputMaybe<LpLoanAccountDistinctCountAggregateFilter>;
  /** A filter that must pass for the relevant `LpLoanAccount` object to be included within the aggregate. */
  filter?: InputMaybe<LpLoanAccountFilter>;
  /** Maximum aggregate over matching `LpLoanAccount` objects. */
  max?: InputMaybe<LpLoanAccountMaxAggregateFilter>;
  /** Minimum aggregate over matching `LpLoanAccount` objects. */
  min?: InputMaybe<LpLoanAccountMinAggregateFilter>;
  /** Population standard deviation aggregate over matching `LpLoanAccount` objects. */
  stddevPopulation?: InputMaybe<LpLoanAccountStddevPopulationAggregateFilter>;
  /** Sample standard deviation aggregate over matching `LpLoanAccount` objects. */
  stddevSample?: InputMaybe<LpLoanAccountStddevSampleAggregateFilter>;
  /** Sum aggregate over matching `LpLoanAccount` objects. */
  sum?: InputMaybe<LpLoanAccountSumAggregateFilter>;
  /** Population variance aggregate over matching `LpLoanAccount` objects. */
  variancePopulation?: InputMaybe<LpLoanAccountVariancePopulationAggregateFilter>;
  /** Sample variance aggregate over matching `LpLoanAccount` objects. */
  varianceSample?: InputMaybe<LpLoanAccountVarianceSampleAggregateFilter>;
};

export type LpLoanAccountAverageAggregateFilter = {
  borrowPowerUsedBps?: InputMaybe<BigFloatFilter>;
  loanToValueBps?: InputMaybe<BigFloatFilter>;
  totalBorrowAmountUsd?: InputMaybe<BigFloatFilter>;
  totalCollateralBalanceUsd?: InputMaybe<BigFloatFilter>;
};

export type LpLoanAccountAverageAggregates = {
  __typename?: 'LpLoanAccountAverageAggregates';
  /** Mean average of borrowPowerUsedBps across the matching connection */
  borrowPowerUsedBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of loanToValueBps across the matching connection */
  loanToValueBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of totalBorrowAmountUsd across the matching connection */
  totalBorrowAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of totalCollateralBalanceUsd across the matching connection */
  totalCollateralBalanceUsd?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `LpLoanAccount` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type LpLoanAccountCondition = {
  /** Checks for equality with the object’s `borrowPowerUsedBps` field. */
  borrowPowerUsedBps?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `loanToValueBps` field. */
  loanToValueBps?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `lpIdSs58` field. */
  lpIdSs58?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `primaryCollateralAsset` field. */
  primaryCollateralAsset?: InputMaybe<ChainflipAsset>;
  /** Checks for equality with the object’s `totalBorrowAmountUsd` field. */
  totalBorrowAmountUsd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalCollateralBalanceUsd` field. */
  totalCollateralBalanceUsd?: InputMaybe<Scalars['BigFloat']['input']>;
};

export type LpLoanAccountDistinctCountAggregateFilter = {
  borrowPowerUsedBps?: InputMaybe<BigIntFilter>;
  loanToValueBps?: InputMaybe<BigIntFilter>;
  lpIdSs58?: InputMaybe<BigIntFilter>;
  primaryCollateralAsset?: InputMaybe<BigIntFilter>;
  totalBorrowAmountUsd?: InputMaybe<BigIntFilter>;
  totalCollateralBalanceUsd?: InputMaybe<BigIntFilter>;
};

export type LpLoanAccountDistinctCountAggregates = {
  __typename?: 'LpLoanAccountDistinctCountAggregates';
  /** Distinct count of borrowPowerUsedBps across the matching connection */
  borrowPowerUsedBps?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of loanToValueBps across the matching connection */
  loanToValueBps?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of lpIdSs58 across the matching connection */
  lpIdSs58?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of primaryCollateralAsset across the matching connection */
  primaryCollateralAsset?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of totalBorrowAmountUsd across the matching connection */
  totalBorrowAmountUsd?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of totalCollateralBalanceUsd across the matching connection */
  totalCollateralBalanceUsd?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `LpLoanAccount` object types. All fields are combined with a logical ‘and.’ */
export type LpLoanAccountFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<LpLoanAccountFilter>>;
  /** Filter by the object’s `borrowPowerUsedBps` field. */
  borrowPowerUsedBps?: InputMaybe<IntFilter>;
  /** Filter by the object’s `loanToValueBps` field. */
  loanToValueBps?: InputMaybe<IntFilter>;
  /** Filter by the object’s `loansByLoanAccountLpIdSs58` relation. */
  loansByLoanAccountLpIdSs58?: InputMaybe<LpLoanAccountToManyLoanFilter>;
  /** Some related `loansByLoanAccountLpIdSs58` exist. */
  loansByLoanAccountLpIdSs58Exist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `lpAccountByLpIdSs58` relation. */
  lpAccountByLpIdSs58?: InputMaybe<LpAccountFilter>;
  /** Filter by the object’s `lpCollateralBalancesByLoanAccountLpIdSs58` relation. */
  lpCollateralBalancesByLoanAccountLpIdSs58?: InputMaybe<LpLoanAccountToManyLpCollateralBalanceFilter>;
  /** Some related `lpCollateralBalancesByLoanAccountLpIdSs58` exist. */
  lpCollateralBalancesByLoanAccountLpIdSs58Exist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `lpIdSs58` field. */
  lpIdSs58?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<LpLoanAccountFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<LpLoanAccountFilter>>;
  /** Filter by the object’s `primaryCollateralAsset` field. */
  primaryCollateralAsset?: InputMaybe<ChainflipAssetFilter>;
  /** Filter by the object’s `totalBorrowAmountUsd` field. */
  totalBorrowAmountUsd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalCollateralBalanceUsd` field. */
  totalCollateralBalanceUsd?: InputMaybe<BigFloatFilter>;
};

/** Grouping methods for `LpLoanAccount` for usage during aggregation. */
export type LpLoanAccountGroupBy =
  | 'BORROW_POWER_USED_BPS'
  | 'LOAN_TO_VALUE_BPS'
  | 'PRIMARY_COLLATERAL_ASSET'
  | 'TOTAL_BORROW_AMOUNT_USD'
  | 'TOTAL_COLLATERAL_BALANCE_USD';

export type LpLoanAccountHavingAverageInput = {
  borrowPowerUsedBps?: InputMaybe<HavingIntFilter>;
  loanToValueBps?: InputMaybe<HavingIntFilter>;
  totalBorrowAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalCollateralBalanceUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LpLoanAccountHavingDistinctCountInput = {
  borrowPowerUsedBps?: InputMaybe<HavingIntFilter>;
  loanToValueBps?: InputMaybe<HavingIntFilter>;
  totalBorrowAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalCollateralBalanceUsd?: InputMaybe<HavingBigfloatFilter>;
};

/** Conditions for `LpLoanAccount` aggregates. */
export type LpLoanAccountHavingInput = {
  AND?: InputMaybe<Array<LpLoanAccountHavingInput>>;
  OR?: InputMaybe<Array<LpLoanAccountHavingInput>>;
  average?: InputMaybe<LpLoanAccountHavingAverageInput>;
  distinctCount?: InputMaybe<LpLoanAccountHavingDistinctCountInput>;
  max?: InputMaybe<LpLoanAccountHavingMaxInput>;
  min?: InputMaybe<LpLoanAccountHavingMinInput>;
  stddevPopulation?: InputMaybe<LpLoanAccountHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<LpLoanAccountHavingStddevSampleInput>;
  sum?: InputMaybe<LpLoanAccountHavingSumInput>;
  variancePopulation?: InputMaybe<LpLoanAccountHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<LpLoanAccountHavingVarianceSampleInput>;
};

export type LpLoanAccountHavingMaxInput = {
  borrowPowerUsedBps?: InputMaybe<HavingIntFilter>;
  loanToValueBps?: InputMaybe<HavingIntFilter>;
  totalBorrowAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalCollateralBalanceUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LpLoanAccountHavingMinInput = {
  borrowPowerUsedBps?: InputMaybe<HavingIntFilter>;
  loanToValueBps?: InputMaybe<HavingIntFilter>;
  totalBorrowAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalCollateralBalanceUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LpLoanAccountHavingStddevPopulationInput = {
  borrowPowerUsedBps?: InputMaybe<HavingIntFilter>;
  loanToValueBps?: InputMaybe<HavingIntFilter>;
  totalBorrowAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalCollateralBalanceUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LpLoanAccountHavingStddevSampleInput = {
  borrowPowerUsedBps?: InputMaybe<HavingIntFilter>;
  loanToValueBps?: InputMaybe<HavingIntFilter>;
  totalBorrowAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalCollateralBalanceUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LpLoanAccountHavingSumInput = {
  borrowPowerUsedBps?: InputMaybe<HavingIntFilter>;
  loanToValueBps?: InputMaybe<HavingIntFilter>;
  totalBorrowAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalCollateralBalanceUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LpLoanAccountHavingVariancePopulationInput = {
  borrowPowerUsedBps?: InputMaybe<HavingIntFilter>;
  loanToValueBps?: InputMaybe<HavingIntFilter>;
  totalBorrowAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalCollateralBalanceUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LpLoanAccountHavingVarianceSampleInput = {
  borrowPowerUsedBps?: InputMaybe<HavingIntFilter>;
  loanToValueBps?: InputMaybe<HavingIntFilter>;
  totalBorrowAmountUsd?: InputMaybe<HavingBigfloatFilter>;
  totalCollateralBalanceUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LpLoanAccountMaxAggregateFilter = {
  borrowPowerUsedBps?: InputMaybe<IntFilter>;
  loanToValueBps?: InputMaybe<IntFilter>;
  totalBorrowAmountUsd?: InputMaybe<BigFloatFilter>;
  totalCollateralBalanceUsd?: InputMaybe<BigFloatFilter>;
};

export type LpLoanAccountMaxAggregates = {
  __typename?: 'LpLoanAccountMaxAggregates';
  /** Maximum of borrowPowerUsedBps across the matching connection */
  borrowPowerUsedBps?: Maybe<Scalars['Int']['output']>;
  /** Maximum of loanToValueBps across the matching connection */
  loanToValueBps?: Maybe<Scalars['Int']['output']>;
  /** Maximum of totalBorrowAmountUsd across the matching connection */
  totalBorrowAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of totalCollateralBalanceUsd across the matching connection */
  totalCollateralBalanceUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type LpLoanAccountMinAggregateFilter = {
  borrowPowerUsedBps?: InputMaybe<IntFilter>;
  loanToValueBps?: InputMaybe<IntFilter>;
  totalBorrowAmountUsd?: InputMaybe<BigFloatFilter>;
  totalCollateralBalanceUsd?: InputMaybe<BigFloatFilter>;
};

export type LpLoanAccountMinAggregates = {
  __typename?: 'LpLoanAccountMinAggregates';
  /** Minimum of borrowPowerUsedBps across the matching connection */
  borrowPowerUsedBps?: Maybe<Scalars['Int']['output']>;
  /** Minimum of loanToValueBps across the matching connection */
  loanToValueBps?: Maybe<Scalars['Int']['output']>;
  /** Minimum of totalBorrowAmountUsd across the matching connection */
  totalBorrowAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of totalCollateralBalanceUsd across the matching connection */
  totalCollateralBalanceUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type LpLoanAccountStddevPopulationAggregateFilter = {
  borrowPowerUsedBps?: InputMaybe<BigFloatFilter>;
  loanToValueBps?: InputMaybe<BigFloatFilter>;
  totalBorrowAmountUsd?: InputMaybe<BigFloatFilter>;
  totalCollateralBalanceUsd?: InputMaybe<BigFloatFilter>;
};

export type LpLoanAccountStddevPopulationAggregates = {
  __typename?: 'LpLoanAccountStddevPopulationAggregates';
  /** Population standard deviation of borrowPowerUsedBps across the matching connection */
  borrowPowerUsedBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of loanToValueBps across the matching connection */
  loanToValueBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of totalBorrowAmountUsd across the matching connection */
  totalBorrowAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of totalCollateralBalanceUsd across the matching connection */
  totalCollateralBalanceUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type LpLoanAccountStddevSampleAggregateFilter = {
  borrowPowerUsedBps?: InputMaybe<BigFloatFilter>;
  loanToValueBps?: InputMaybe<BigFloatFilter>;
  totalBorrowAmountUsd?: InputMaybe<BigFloatFilter>;
  totalCollateralBalanceUsd?: InputMaybe<BigFloatFilter>;
};

export type LpLoanAccountStddevSampleAggregates = {
  __typename?: 'LpLoanAccountStddevSampleAggregates';
  /** Sample standard deviation of borrowPowerUsedBps across the matching connection */
  borrowPowerUsedBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of loanToValueBps across the matching connection */
  loanToValueBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of totalBorrowAmountUsd across the matching connection */
  totalBorrowAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of totalCollateralBalanceUsd across the matching connection */
  totalCollateralBalanceUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type LpLoanAccountSumAggregateFilter = {
  borrowPowerUsedBps?: InputMaybe<BigIntFilter>;
  loanToValueBps?: InputMaybe<BigIntFilter>;
  totalBorrowAmountUsd?: InputMaybe<BigFloatFilter>;
  totalCollateralBalanceUsd?: InputMaybe<BigFloatFilter>;
};

export type LpLoanAccountSumAggregates = {
  __typename?: 'LpLoanAccountSumAggregates';
  /** Sum of borrowPowerUsedBps across the matching connection */
  borrowPowerUsedBps: Scalars['BigInt']['output'];
  /** Sum of loanToValueBps across the matching connection */
  loanToValueBps: Scalars['BigInt']['output'];
  /** Sum of totalBorrowAmountUsd across the matching connection */
  totalBorrowAmountUsd: Scalars['BigFloat']['output'];
  /** Sum of totalCollateralBalanceUsd across the matching connection */
  totalCollateralBalanceUsd: Scalars['BigFloat']['output'];
};

/** A filter to be used against many `Loan` object types. All fields are combined with a logical ‘and.’ */
export type LpLoanAccountToManyLoanFilter = {
  /** Aggregates across related `Loan` match the filter criteria. */
  aggregates?: InputMaybe<LoanAggregatesFilter>;
  /** Every related `Loan` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<LoanFilter>;
  /** No related `Loan` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<LoanFilter>;
  /** Some related `Loan` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<LoanFilter>;
};

/** A filter to be used against many `LpCollateralBalance` object types. All fields are combined with a logical ‘and.’ */
export type LpLoanAccountToManyLpCollateralBalanceFilter = {
  /** Aggregates across related `LpCollateralBalance` match the filter criteria. */
  aggregates?: InputMaybe<LpCollateralBalanceAggregatesFilter>;
  /** Every related `LpCollateralBalance` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<LpCollateralBalanceFilter>;
  /** No related `LpCollateralBalance` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<LpCollateralBalanceFilter>;
  /** Some related `LpCollateralBalance` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<LpCollateralBalanceFilter>;
};

export type LpLoanAccountVariancePopulationAggregateFilter = {
  borrowPowerUsedBps?: InputMaybe<BigFloatFilter>;
  loanToValueBps?: InputMaybe<BigFloatFilter>;
  totalBorrowAmountUsd?: InputMaybe<BigFloatFilter>;
  totalCollateralBalanceUsd?: InputMaybe<BigFloatFilter>;
};

export type LpLoanAccountVariancePopulationAggregates = {
  __typename?: 'LpLoanAccountVariancePopulationAggregates';
  /** Population variance of borrowPowerUsedBps across the matching connection */
  borrowPowerUsedBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of loanToValueBps across the matching connection */
  loanToValueBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of totalBorrowAmountUsd across the matching connection */
  totalBorrowAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of totalCollateralBalanceUsd across the matching connection */
  totalCollateralBalanceUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type LpLoanAccountVarianceSampleAggregateFilter = {
  borrowPowerUsedBps?: InputMaybe<BigFloatFilter>;
  loanToValueBps?: InputMaybe<BigFloatFilter>;
  totalBorrowAmountUsd?: InputMaybe<BigFloatFilter>;
  totalCollateralBalanceUsd?: InputMaybe<BigFloatFilter>;
};

export type LpLoanAccountVarianceSampleAggregates = {
  __typename?: 'LpLoanAccountVarianceSampleAggregates';
  /** Sample variance of borrowPowerUsedBps across the matching connection */
  borrowPowerUsedBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of loanToValueBps across the matching connection */
  loanToValueBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of totalBorrowAmountUsd across the matching connection */
  totalBorrowAmountUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of totalCollateralBalanceUsd across the matching connection */
  totalCollateralBalanceUsd?: Maybe<Scalars['BigFloat']['output']>;
};

/** A connection to a list of `LpLoanAccount` values. */
export type LpLoanAccountsConnection = {
  __typename?: 'LpLoanAccountsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<LpLoanAccountAggregates>;
  /** A list of edges which contains the `LpLoanAccount` and cursor to aid in pagination. */
  edges: Array<LpLoanAccountsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<LpLoanAccountAggregates>>;
  /** A list of `LpLoanAccount` objects. */
  nodes: Array<LpLoanAccount>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `LpLoanAccount` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `LpLoanAccount` values. */
export type LpLoanAccountsConnectionGroupedAggregatesArgs = {
  groupBy: Array<LpLoanAccountGroupBy>;
  having?: InputMaybe<LpLoanAccountHavingInput>;
};

/** A `LpLoanAccount` edge in the connection. */
export type LpLoanAccountsEdge = {
  __typename?: 'LpLoanAccountsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `LpLoanAccount` at the end of the edge. */
  node: LpLoanAccount;
};

/** Methods to use when ordering `LpLoanAccount`. */
export type LpLoanAccountsOrderBy =
  | 'BORROW_POWER_USED_BPS_ASC'
  | 'BORROW_POWER_USED_BPS_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_AVERAGE_ASSET_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_AVERAGE_ASSET_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_AVERAGE_CREATED_AT_BLOCK_INDEX_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_AVERAGE_CREATED_AT_BLOCK_INDEX_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_AVERAGE_ID_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_AVERAGE_ID_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_AVERAGE_LOAN_ACCOUNT_LP_ID_SS58_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_AVERAGE_LOAN_ACCOUNT_LP_ID_SS58_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_AVERAGE_PRINCIPAL_AMOUNT_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_AVERAGE_PRINCIPAL_AMOUNT_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_AVERAGE_PRINCIPAL_AMOUNT_USD_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_AVERAGE_PRINCIPAL_AMOUNT_USD_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_AVERAGE_STATUS_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_AVERAGE_STATUS_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_COUNT_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_COUNT_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_DISTINCT_COUNT_ASSET_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_DISTINCT_COUNT_ASSET_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_DISTINCT_COUNT_CREATED_AT_BLOCK_INDEX_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_DISTINCT_COUNT_CREATED_AT_BLOCK_INDEX_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_DISTINCT_COUNT_ID_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_DISTINCT_COUNT_ID_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_DISTINCT_COUNT_LOAN_ACCOUNT_LP_ID_SS58_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_DISTINCT_COUNT_LOAN_ACCOUNT_LP_ID_SS58_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_DISTINCT_COUNT_PRINCIPAL_AMOUNT_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_DISTINCT_COUNT_PRINCIPAL_AMOUNT_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_DISTINCT_COUNT_PRINCIPAL_AMOUNT_USD_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_DISTINCT_COUNT_PRINCIPAL_AMOUNT_USD_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_DISTINCT_COUNT_STATUS_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_DISTINCT_COUNT_STATUS_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_MAX_ASSET_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_MAX_ASSET_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_MAX_CREATED_AT_BLOCK_INDEX_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_MAX_CREATED_AT_BLOCK_INDEX_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_MAX_ID_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_MAX_ID_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_MAX_LOAN_ACCOUNT_LP_ID_SS58_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_MAX_LOAN_ACCOUNT_LP_ID_SS58_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_MAX_PRINCIPAL_AMOUNT_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_MAX_PRINCIPAL_AMOUNT_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_MAX_PRINCIPAL_AMOUNT_USD_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_MAX_PRINCIPAL_AMOUNT_USD_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_MAX_STATUS_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_MAX_STATUS_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_MIN_ASSET_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_MIN_ASSET_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_MIN_CREATED_AT_BLOCK_INDEX_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_MIN_CREATED_AT_BLOCK_INDEX_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_MIN_ID_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_MIN_ID_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_MIN_LOAN_ACCOUNT_LP_ID_SS58_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_MIN_LOAN_ACCOUNT_LP_ID_SS58_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_MIN_PRINCIPAL_AMOUNT_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_MIN_PRINCIPAL_AMOUNT_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_MIN_PRINCIPAL_AMOUNT_USD_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_MIN_PRINCIPAL_AMOUNT_USD_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_MIN_STATUS_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_MIN_STATUS_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_POPULATION_ASSET_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_POPULATION_ASSET_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_POPULATION_CREATED_AT_BLOCK_INDEX_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_POPULATION_CREATED_AT_BLOCK_INDEX_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_POPULATION_ID_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_POPULATION_ID_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_POPULATION_LOAN_ACCOUNT_LP_ID_SS58_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_POPULATION_LOAN_ACCOUNT_LP_ID_SS58_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_POPULATION_PRINCIPAL_AMOUNT_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_POPULATION_PRINCIPAL_AMOUNT_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_POPULATION_PRINCIPAL_AMOUNT_USD_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_POPULATION_PRINCIPAL_AMOUNT_USD_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_POPULATION_STATUS_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_POPULATION_STATUS_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_SAMPLE_ASSET_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_SAMPLE_ASSET_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_SAMPLE_CREATED_AT_BLOCK_INDEX_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_SAMPLE_CREATED_AT_BLOCK_INDEX_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_SAMPLE_ID_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_SAMPLE_ID_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_SAMPLE_LOAN_ACCOUNT_LP_ID_SS58_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_SAMPLE_LOAN_ACCOUNT_LP_ID_SS58_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_SAMPLE_PRINCIPAL_AMOUNT_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_SAMPLE_PRINCIPAL_AMOUNT_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_SAMPLE_PRINCIPAL_AMOUNT_USD_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_SAMPLE_PRINCIPAL_AMOUNT_USD_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_SAMPLE_STATUS_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_SAMPLE_STATUS_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_SUM_ASSET_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_SUM_ASSET_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_SUM_CREATED_AT_BLOCK_INDEX_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_SUM_CREATED_AT_BLOCK_INDEX_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_SUM_ID_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_SUM_ID_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_SUM_LOAN_ACCOUNT_LP_ID_SS58_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_SUM_LOAN_ACCOUNT_LP_ID_SS58_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_SUM_PRINCIPAL_AMOUNT_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_SUM_PRINCIPAL_AMOUNT_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_SUM_PRINCIPAL_AMOUNT_USD_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_SUM_PRINCIPAL_AMOUNT_USD_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_SUM_STATUS_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_SUM_STATUS_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_POPULATION_ASSET_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_POPULATION_ASSET_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_POPULATION_CREATED_AT_BLOCK_INDEX_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_POPULATION_CREATED_AT_BLOCK_INDEX_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_POPULATION_ID_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_POPULATION_ID_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_POPULATION_LOAN_ACCOUNT_LP_ID_SS58_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_POPULATION_LOAN_ACCOUNT_LP_ID_SS58_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_POPULATION_PRINCIPAL_AMOUNT_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_POPULATION_PRINCIPAL_AMOUNT_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_POPULATION_PRINCIPAL_AMOUNT_USD_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_POPULATION_PRINCIPAL_AMOUNT_USD_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_POPULATION_STATUS_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_POPULATION_STATUS_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_SAMPLE_ASSET_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_SAMPLE_ASSET_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_SAMPLE_CREATED_AT_BLOCK_INDEX_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_SAMPLE_CREATED_AT_BLOCK_INDEX_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_SAMPLE_ID_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_SAMPLE_ID_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_SAMPLE_LOAN_ACCOUNT_LP_ID_SS58_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_SAMPLE_LOAN_ACCOUNT_LP_ID_SS58_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_SAMPLE_PRINCIPAL_AMOUNT_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_SAMPLE_PRINCIPAL_AMOUNT_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_SAMPLE_PRINCIPAL_AMOUNT_USD_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_SAMPLE_PRINCIPAL_AMOUNT_USD_DESC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_SAMPLE_STATUS_ASC'
  | 'LOANS_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_SAMPLE_STATUS_DESC'
  | 'LOAN_TO_VALUE_BPS_ASC'
  | 'LOAN_TO_VALUE_BPS_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_AVERAGE_AMOUNT_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_AVERAGE_AMOUNT_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_AVERAGE_AMOUNT_USD_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_AVERAGE_AMOUNT_USD_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_AVERAGE_ASSET_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_AVERAGE_ASSET_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_AVERAGE_LOAN_ACCOUNT_LP_ID_SS58_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_AVERAGE_LOAN_ACCOUNT_LP_ID_SS58_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_COUNT_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_COUNT_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_DISTINCT_COUNT_AMOUNT_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_DISTINCT_COUNT_AMOUNT_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_DISTINCT_COUNT_AMOUNT_USD_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_DISTINCT_COUNT_AMOUNT_USD_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_DISTINCT_COUNT_ASSET_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_DISTINCT_COUNT_ASSET_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_DISTINCT_COUNT_LOAN_ACCOUNT_LP_ID_SS58_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_DISTINCT_COUNT_LOAN_ACCOUNT_LP_ID_SS58_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_MAX_AMOUNT_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_MAX_AMOUNT_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_MAX_AMOUNT_USD_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_MAX_AMOUNT_USD_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_MAX_ASSET_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_MAX_ASSET_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_MAX_LOAN_ACCOUNT_LP_ID_SS58_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_MAX_LOAN_ACCOUNT_LP_ID_SS58_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_MIN_AMOUNT_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_MIN_AMOUNT_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_MIN_AMOUNT_USD_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_MIN_AMOUNT_USD_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_MIN_ASSET_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_MIN_ASSET_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_MIN_LOAN_ACCOUNT_LP_ID_SS58_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_MIN_LOAN_ACCOUNT_LP_ID_SS58_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_POPULATION_AMOUNT_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_POPULATION_AMOUNT_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_POPULATION_AMOUNT_USD_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_POPULATION_AMOUNT_USD_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_POPULATION_ASSET_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_POPULATION_ASSET_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_POPULATION_LOAN_ACCOUNT_LP_ID_SS58_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_POPULATION_LOAN_ACCOUNT_LP_ID_SS58_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_SAMPLE_AMOUNT_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_SAMPLE_AMOUNT_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_SAMPLE_AMOUNT_USD_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_SAMPLE_AMOUNT_USD_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_SAMPLE_ASSET_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_SAMPLE_ASSET_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_SAMPLE_LOAN_ACCOUNT_LP_ID_SS58_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_STDDEV_SAMPLE_LOAN_ACCOUNT_LP_ID_SS58_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_SUM_AMOUNT_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_SUM_AMOUNT_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_SUM_AMOUNT_USD_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_SUM_AMOUNT_USD_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_SUM_ASSET_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_SUM_ASSET_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_SUM_LOAN_ACCOUNT_LP_ID_SS58_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_SUM_LOAN_ACCOUNT_LP_ID_SS58_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_POPULATION_AMOUNT_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_POPULATION_AMOUNT_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_POPULATION_AMOUNT_USD_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_POPULATION_AMOUNT_USD_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_POPULATION_ASSET_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_POPULATION_ASSET_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_POPULATION_LOAN_ACCOUNT_LP_ID_SS58_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_POPULATION_LOAN_ACCOUNT_LP_ID_SS58_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_SAMPLE_AMOUNT_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_SAMPLE_AMOUNT_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_SAMPLE_AMOUNT_USD_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_SAMPLE_AMOUNT_USD_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_SAMPLE_ASSET_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_SAMPLE_ASSET_DESC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_SAMPLE_LOAN_ACCOUNT_LP_ID_SS58_ASC'
  | 'LP_COLLATERAL_BALANCES_BY_LOAN_ACCOUNT_LP_ID_SS58_VARIANCE_SAMPLE_LOAN_ACCOUNT_LP_ID_SS58_DESC'
  | 'LP_ID_SS58_ASC'
  | 'LP_ID_SS58_DESC'
  | 'NATURAL'
  | 'PRIMARY_COLLATERAL_ASSET_ASC'
  | 'PRIMARY_COLLATERAL_ASSET_DESC'
  | 'TOTAL_BORROW_AMOUNT_USD_ASC'
  | 'TOTAL_BORROW_AMOUNT_USD_DESC'
  | 'TOTAL_COLLATERAL_BALANCE_USD_ASC'
  | 'TOTAL_COLLATERAL_BALANCE_USD_DESC';

export type LpTotalBalance = {
  __typename?: 'LpTotalBalance';
  amount: Scalars['BigFloat']['output'];
  asset: ChainflipAsset;
  chain: ChainflipChain;
  createdAt: Scalars['Datetime']['output'];
  /** Reads a single `LpAccount` that is related to this `LpTotalBalance`. */
  lpAccountByLpIdSs58: LpAccount;
  lpIdSs58: Scalars['String']['output'];
  updatedAt: Scalars['Datetime']['output'];
  valueUsd: Scalars['BigFloat']['output'];
};

export type LpTotalBalanceAggregates = {
  __typename?: 'LpTotalBalanceAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<LpTotalBalanceAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<LpTotalBalanceDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<LpTotalBalanceMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<LpTotalBalanceMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<LpTotalBalanceStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<LpTotalBalanceStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<LpTotalBalanceSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<LpTotalBalanceVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<LpTotalBalanceVarianceSampleAggregates>;
};

/** A filter to be used against aggregates of `LpTotalBalance` object types. */
export type LpTotalBalanceAggregatesFilter = {
  /** Mean average aggregate over matching `LpTotalBalance` objects. */
  average?: InputMaybe<LpTotalBalanceAverageAggregateFilter>;
  /** Distinct count aggregate over matching `LpTotalBalance` objects. */
  distinctCount?: InputMaybe<LpTotalBalanceDistinctCountAggregateFilter>;
  /** A filter that must pass for the relevant `LpTotalBalance` object to be included within the aggregate. */
  filter?: InputMaybe<LpTotalBalanceFilter>;
  /** Maximum aggregate over matching `LpTotalBalance` objects. */
  max?: InputMaybe<LpTotalBalanceMaxAggregateFilter>;
  /** Minimum aggregate over matching `LpTotalBalance` objects. */
  min?: InputMaybe<LpTotalBalanceMinAggregateFilter>;
  /** Population standard deviation aggregate over matching `LpTotalBalance` objects. */
  stddevPopulation?: InputMaybe<LpTotalBalanceStddevPopulationAggregateFilter>;
  /** Sample standard deviation aggregate over matching `LpTotalBalance` objects. */
  stddevSample?: InputMaybe<LpTotalBalanceStddevSampleAggregateFilter>;
  /** Sum aggregate over matching `LpTotalBalance` objects. */
  sum?: InputMaybe<LpTotalBalanceSumAggregateFilter>;
  /** Population variance aggregate over matching `LpTotalBalance` objects. */
  variancePopulation?: InputMaybe<LpTotalBalanceVariancePopulationAggregateFilter>;
  /** Sample variance aggregate over matching `LpTotalBalance` objects. */
  varianceSample?: InputMaybe<LpTotalBalanceVarianceSampleAggregateFilter>;
};

export type LpTotalBalanceAverageAggregateFilter = {
  amount?: InputMaybe<BigFloatFilter>;
  valueUsd?: InputMaybe<BigFloatFilter>;
};

export type LpTotalBalanceAverageAggregates = {
  __typename?: 'LpTotalBalanceAverageAggregates';
  /** Mean average of amount across the matching connection */
  amount?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of valueUsd across the matching connection */
  valueUsd?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `LpTotalBalance` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type LpTotalBalanceCondition = {
  /** Checks for equality with the object’s `amount` field. */
  amount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `asset` field. */
  asset?: InputMaybe<ChainflipAsset>;
  /** Checks for equality with the object’s `chain` field. */
  chain?: InputMaybe<ChainflipChain>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `lpIdSs58` field. */
  lpIdSs58?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `valueUsd` field. */
  valueUsd?: InputMaybe<Scalars['BigFloat']['input']>;
};

export type LpTotalBalanceDistinctCountAggregateFilter = {
  amount?: InputMaybe<BigIntFilter>;
  asset?: InputMaybe<BigIntFilter>;
  chain?: InputMaybe<BigIntFilter>;
  createdAt?: InputMaybe<BigIntFilter>;
  lpIdSs58?: InputMaybe<BigIntFilter>;
  updatedAt?: InputMaybe<BigIntFilter>;
  valueUsd?: InputMaybe<BigIntFilter>;
};

export type LpTotalBalanceDistinctCountAggregates = {
  __typename?: 'LpTotalBalanceDistinctCountAggregates';
  /** Distinct count of amount across the matching connection */
  amount?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of asset across the matching connection */
  asset?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of chain across the matching connection */
  chain?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of createdAt across the matching connection */
  createdAt?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of lpIdSs58 across the matching connection */
  lpIdSs58?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of updatedAt across the matching connection */
  updatedAt?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of valueUsd across the matching connection */
  valueUsd?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `LpTotalBalance` object types. All fields are combined with a logical ‘and.’ */
export type LpTotalBalanceFilter = {
  /** Filter by the object’s `amount` field. */
  amount?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<LpTotalBalanceFilter>>;
  /** Filter by the object’s `asset` field. */
  asset?: InputMaybe<ChainflipAssetFilter>;
  /** Filter by the object’s `chain` field. */
  chain?: InputMaybe<ChainflipChainFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `lpAccountByLpIdSs58` relation. */
  lpAccountByLpIdSs58?: InputMaybe<LpAccountFilter>;
  /** Filter by the object’s `lpIdSs58` field. */
  lpIdSs58?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<LpTotalBalanceFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<LpTotalBalanceFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `valueUsd` field. */
  valueUsd?: InputMaybe<BigFloatFilter>;
};

/** Grouping methods for `LpTotalBalance` for usage during aggregation. */
export type LpTotalBalanceGroupBy =
  | 'AMOUNT'
  | 'ASSET'
  | 'CHAIN'
  | 'CREATED_AT'
  | 'CREATED_AT_TRUNCATED_TO_DAY'
  | 'CREATED_AT_TRUNCATED_TO_HOUR'
  | 'CREATED_AT_TRUNCATED_TO_MONTH'
  | 'CREATED_AT_TRUNCATED_TO_WEEK'
  | 'LP_ID_SS58'
  | 'UPDATED_AT'
  | 'UPDATED_AT_TRUNCATED_TO_DAY'
  | 'UPDATED_AT_TRUNCATED_TO_HOUR'
  | 'UPDATED_AT_TRUNCATED_TO_MONTH'
  | 'UPDATED_AT_TRUNCATED_TO_WEEK'
  | 'VALUE_USD';

export type LpTotalBalanceHavingAverageInput = {
  amount?: InputMaybe<HavingBigfloatFilter>;
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
  valueUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LpTotalBalanceHavingDistinctCountInput = {
  amount?: InputMaybe<HavingBigfloatFilter>;
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
  valueUsd?: InputMaybe<HavingBigfloatFilter>;
};

/** Conditions for `LpTotalBalance` aggregates. */
export type LpTotalBalanceHavingInput = {
  AND?: InputMaybe<Array<LpTotalBalanceHavingInput>>;
  OR?: InputMaybe<Array<LpTotalBalanceHavingInput>>;
  average?: InputMaybe<LpTotalBalanceHavingAverageInput>;
  distinctCount?: InputMaybe<LpTotalBalanceHavingDistinctCountInput>;
  max?: InputMaybe<LpTotalBalanceHavingMaxInput>;
  min?: InputMaybe<LpTotalBalanceHavingMinInput>;
  stddevPopulation?: InputMaybe<LpTotalBalanceHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<LpTotalBalanceHavingStddevSampleInput>;
  sum?: InputMaybe<LpTotalBalanceHavingSumInput>;
  variancePopulation?: InputMaybe<LpTotalBalanceHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<LpTotalBalanceHavingVarianceSampleInput>;
};

export type LpTotalBalanceHavingMaxInput = {
  amount?: InputMaybe<HavingBigfloatFilter>;
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
  valueUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LpTotalBalanceHavingMinInput = {
  amount?: InputMaybe<HavingBigfloatFilter>;
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
  valueUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LpTotalBalanceHavingStddevPopulationInput = {
  amount?: InputMaybe<HavingBigfloatFilter>;
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
  valueUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LpTotalBalanceHavingStddevSampleInput = {
  amount?: InputMaybe<HavingBigfloatFilter>;
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
  valueUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LpTotalBalanceHavingSumInput = {
  amount?: InputMaybe<HavingBigfloatFilter>;
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
  valueUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LpTotalBalanceHavingVariancePopulationInput = {
  amount?: InputMaybe<HavingBigfloatFilter>;
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
  valueUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LpTotalBalanceHavingVarianceSampleInput = {
  amount?: InputMaybe<HavingBigfloatFilter>;
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
  valueUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type LpTotalBalanceMaxAggregateFilter = {
  amount?: InputMaybe<BigFloatFilter>;
  createdAt?: InputMaybe<DatetimeFilter>;
  updatedAt?: InputMaybe<DatetimeFilter>;
  valueUsd?: InputMaybe<BigFloatFilter>;
};

export type LpTotalBalanceMaxAggregates = {
  __typename?: 'LpTotalBalanceMaxAggregates';
  /** Maximum of amount across the matching connection */
  amount?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of createdAt across the matching connection */
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  /** Maximum of updatedAt across the matching connection */
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Maximum of valueUsd across the matching connection */
  valueUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type LpTotalBalanceMinAggregateFilter = {
  amount?: InputMaybe<BigFloatFilter>;
  createdAt?: InputMaybe<DatetimeFilter>;
  updatedAt?: InputMaybe<DatetimeFilter>;
  valueUsd?: InputMaybe<BigFloatFilter>;
};

export type LpTotalBalanceMinAggregates = {
  __typename?: 'LpTotalBalanceMinAggregates';
  /** Minimum of amount across the matching connection */
  amount?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of createdAt across the matching connection */
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  /** Minimum of updatedAt across the matching connection */
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Minimum of valueUsd across the matching connection */
  valueUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type LpTotalBalanceStddevPopulationAggregateFilter = {
  amount?: InputMaybe<BigFloatFilter>;
  valueUsd?: InputMaybe<BigFloatFilter>;
};

export type LpTotalBalanceStddevPopulationAggregates = {
  __typename?: 'LpTotalBalanceStddevPopulationAggregates';
  /** Population standard deviation of amount across the matching connection */
  amount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of valueUsd across the matching connection */
  valueUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type LpTotalBalanceStddevSampleAggregateFilter = {
  amount?: InputMaybe<BigFloatFilter>;
  valueUsd?: InputMaybe<BigFloatFilter>;
};

export type LpTotalBalanceStddevSampleAggregates = {
  __typename?: 'LpTotalBalanceStddevSampleAggregates';
  /** Sample standard deviation of amount across the matching connection */
  amount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of valueUsd across the matching connection */
  valueUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type LpTotalBalanceSumAggregateFilter = {
  amount?: InputMaybe<BigFloatFilter>;
  valueUsd?: InputMaybe<BigFloatFilter>;
};

export type LpTotalBalanceSumAggregates = {
  __typename?: 'LpTotalBalanceSumAggregates';
  /** Sum of amount across the matching connection */
  amount: Scalars['BigFloat']['output'];
  /** Sum of valueUsd across the matching connection */
  valueUsd: Scalars['BigFloat']['output'];
};

export type LpTotalBalanceVariancePopulationAggregateFilter = {
  amount?: InputMaybe<BigFloatFilter>;
  valueUsd?: InputMaybe<BigFloatFilter>;
};

export type LpTotalBalanceVariancePopulationAggregates = {
  __typename?: 'LpTotalBalanceVariancePopulationAggregates';
  /** Population variance of amount across the matching connection */
  amount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of valueUsd across the matching connection */
  valueUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type LpTotalBalanceVarianceSampleAggregateFilter = {
  amount?: InputMaybe<BigFloatFilter>;
  valueUsd?: InputMaybe<BigFloatFilter>;
};

export type LpTotalBalanceVarianceSampleAggregates = {
  __typename?: 'LpTotalBalanceVarianceSampleAggregates';
  /** Sample variance of amount across the matching connection */
  amount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of valueUsd across the matching connection */
  valueUsd?: Maybe<Scalars['BigFloat']['output']>;
};

/** A connection to a list of `LpTotalBalance` values. */
export type LpTotalBalancesConnection = {
  __typename?: 'LpTotalBalancesConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<LpTotalBalanceAggregates>;
  /** A list of edges which contains the `LpTotalBalance` and cursor to aid in pagination. */
  edges: Array<LpTotalBalancesEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<LpTotalBalanceAggregates>>;
  /** A list of `LpTotalBalance` objects. */
  nodes: Array<LpTotalBalance>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `LpTotalBalance` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `LpTotalBalance` values. */
export type LpTotalBalancesConnectionGroupedAggregatesArgs = {
  groupBy: Array<LpTotalBalanceGroupBy>;
  having?: InputMaybe<LpTotalBalanceHavingInput>;
};

/** A `LpTotalBalance` edge in the connection. */
export type LpTotalBalancesEdge = {
  __typename?: 'LpTotalBalancesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `LpTotalBalance` at the end of the edge. */
  node: LpTotalBalance;
};

/** Methods to use when ordering `LpTotalBalance`. */
export type LpTotalBalancesOrderBy =
  | 'AMOUNT_ASC'
  | 'AMOUNT_DESC'
  | 'ASSET_ASC'
  | 'ASSET_DESC'
  | 'CHAIN_ASC'
  | 'CHAIN_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'LP_ID_SS58_ASC'
  | 'LP_ID_SS58_DESC'
  | 'NATURAL'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC'
  | 'VALUE_USD_ASC'
  | 'VALUE_USD_DESC';

/** A connection to a list of `Metadatum` values. */
export type MetadataConnection = {
  __typename?: 'MetadataConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<MetadatumAggregates>;
  /** A list of edges which contains the `Metadatum` and cursor to aid in pagination. */
  edges: Array<MetadataEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<MetadatumAggregates>>;
  /** A list of `Metadatum` objects. */
  nodes: Array<Metadatum>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Metadatum` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `Metadatum` values. */
export type MetadataConnectionGroupedAggregatesArgs = {
  groupBy: Array<MetadataGroupBy>;
  having?: InputMaybe<MetadataHavingInput>;
};

/** A `Metadatum` edge in the connection. */
export type MetadataEdge = {
  __typename?: 'MetadataEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Metadatum` at the end of the edge. */
  node: Metadatum;
};

/** Grouping methods for `Metadatum` for usage during aggregation. */
export type MetadataGroupBy =
  | 'BLOCK_HASH'
  | 'BLOCK_HEIGHT'
  | 'HEX'
  | 'SPEC_NAME'
  | 'SPEC_VERSION';

export type MetadataHavingAverageInput = {
  blockHeight?: InputMaybe<HavingIntFilter>;
  specVersion?: InputMaybe<HavingIntFilter>;
};

export type MetadataHavingDistinctCountInput = {
  blockHeight?: InputMaybe<HavingIntFilter>;
  specVersion?: InputMaybe<HavingIntFilter>;
};

/** Conditions for `Metadatum` aggregates. */
export type MetadataHavingInput = {
  AND?: InputMaybe<Array<MetadataHavingInput>>;
  OR?: InputMaybe<Array<MetadataHavingInput>>;
  average?: InputMaybe<MetadataHavingAverageInput>;
  distinctCount?: InputMaybe<MetadataHavingDistinctCountInput>;
  max?: InputMaybe<MetadataHavingMaxInput>;
  min?: InputMaybe<MetadataHavingMinInput>;
  stddevPopulation?: InputMaybe<MetadataHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<MetadataHavingStddevSampleInput>;
  sum?: InputMaybe<MetadataHavingSumInput>;
  variancePopulation?: InputMaybe<MetadataHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<MetadataHavingVarianceSampleInput>;
};

export type MetadataHavingMaxInput = {
  blockHeight?: InputMaybe<HavingIntFilter>;
  specVersion?: InputMaybe<HavingIntFilter>;
};

export type MetadataHavingMinInput = {
  blockHeight?: InputMaybe<HavingIntFilter>;
  specVersion?: InputMaybe<HavingIntFilter>;
};

export type MetadataHavingStddevPopulationInput = {
  blockHeight?: InputMaybe<HavingIntFilter>;
  specVersion?: InputMaybe<HavingIntFilter>;
};

export type MetadataHavingStddevSampleInput = {
  blockHeight?: InputMaybe<HavingIntFilter>;
  specVersion?: InputMaybe<HavingIntFilter>;
};

export type MetadataHavingSumInput = {
  blockHeight?: InputMaybe<HavingIntFilter>;
  specVersion?: InputMaybe<HavingIntFilter>;
};

export type MetadataHavingVariancePopulationInput = {
  blockHeight?: InputMaybe<HavingIntFilter>;
  specVersion?: InputMaybe<HavingIntFilter>;
};

export type MetadataHavingVarianceSampleInput = {
  blockHeight?: InputMaybe<HavingIntFilter>;
  specVersion?: InputMaybe<HavingIntFilter>;
};

/** Methods to use when ordering `Metadatum`. */
export type MetadataOrderBy =
  | 'BLOCK_HASH_ASC'
  | 'BLOCK_HASH_DESC'
  | 'BLOCK_HEIGHT_ASC'
  | 'BLOCK_HEIGHT_DESC'
  | 'HEX_ASC'
  | 'HEX_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'SPEC_NAME_ASC'
  | 'SPEC_NAME_DESC'
  | 'SPEC_VERSION_ASC'
  | 'SPEC_VERSION_DESC';

export type Metadatum = Node & {
  __typename?: 'Metadatum';
  blockHash: Scalars['String']['output'];
  blockHeight: Scalars['Int']['output'];
  hex: Scalars['String']['output'];
  id: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  specName: Scalars['String']['output'];
  specVersion?: Maybe<Scalars['Int']['output']>;
};

export type MetadatumAggregates = {
  __typename?: 'MetadatumAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<MetadatumAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<MetadatumDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<MetadatumMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<MetadatumMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<MetadatumStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<MetadatumStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<MetadatumSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<MetadatumVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<MetadatumVarianceSampleAggregates>;
};

export type MetadatumAverageAggregates = {
  __typename?: 'MetadatumAverageAggregates';
  /** Mean average of blockHeight across the matching connection */
  blockHeight?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of specVersion across the matching connection */
  specVersion?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `Metadatum` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type MetadatumCondition = {
  /** Checks for equality with the object’s `blockHash` field. */
  blockHash?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `blockHeight` field. */
  blockHeight?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `hex` field. */
  hex?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `specName` field. */
  specName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `specVersion` field. */
  specVersion?: InputMaybe<Scalars['Int']['input']>;
};

export type MetadatumDistinctCountAggregates = {
  __typename?: 'MetadatumDistinctCountAggregates';
  /** Distinct count of blockHash across the matching connection */
  blockHash?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of blockHeight across the matching connection */
  blockHeight?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of hex across the matching connection */
  hex?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of id across the matching connection */
  id?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of specName across the matching connection */
  specName?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of specVersion across the matching connection */
  specVersion?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `Metadatum` object types. All fields are combined with a logical ‘and.’ */
export type MetadatumFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MetadatumFilter>>;
  /** Filter by the object’s `blockHash` field. */
  blockHash?: InputMaybe<StringFilter>;
  /** Filter by the object’s `blockHeight` field. */
  blockHeight?: InputMaybe<IntFilter>;
  /** Filter by the object’s `hex` field. */
  hex?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MetadatumFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MetadatumFilter>>;
  /** Filter by the object’s `specName` field. */
  specName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `specVersion` field. */
  specVersion?: InputMaybe<IntFilter>;
};

export type MetadatumMaxAggregates = {
  __typename?: 'MetadatumMaxAggregates';
  /** Maximum of blockHeight across the matching connection */
  blockHeight?: Maybe<Scalars['Int']['output']>;
  /** Maximum of specVersion across the matching connection */
  specVersion?: Maybe<Scalars['Int']['output']>;
};

export type MetadatumMinAggregates = {
  __typename?: 'MetadatumMinAggregates';
  /** Minimum of blockHeight across the matching connection */
  blockHeight?: Maybe<Scalars['Int']['output']>;
  /** Minimum of specVersion across the matching connection */
  specVersion?: Maybe<Scalars['Int']['output']>;
};

export type MetadatumStddevPopulationAggregates = {
  __typename?: 'MetadatumStddevPopulationAggregates';
  /** Population standard deviation of blockHeight across the matching connection */
  blockHeight?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of specVersion across the matching connection */
  specVersion?: Maybe<Scalars['BigFloat']['output']>;
};

export type MetadatumStddevSampleAggregates = {
  __typename?: 'MetadatumStddevSampleAggregates';
  /** Sample standard deviation of blockHeight across the matching connection */
  blockHeight?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of specVersion across the matching connection */
  specVersion?: Maybe<Scalars['BigFloat']['output']>;
};

export type MetadatumSumAggregates = {
  __typename?: 'MetadatumSumAggregates';
  /** Sum of blockHeight across the matching connection */
  blockHeight: Scalars['BigInt']['output'];
  /** Sum of specVersion across the matching connection */
  specVersion: Scalars['BigInt']['output'];
};

export type MetadatumVariancePopulationAggregates = {
  __typename?: 'MetadatumVariancePopulationAggregates';
  /** Population variance of blockHeight across the matching connection */
  blockHeight?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of specVersion across the matching connection */
  specVersion?: Maybe<Scalars['BigFloat']['output']>;
};

export type MetadatumVarianceSampleAggregates = {
  __typename?: 'MetadatumVarianceSampleAggregates';
  /** Sample variance of blockHeight across the matching connection */
  blockHeight?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of specVersion across the matching connection */
  specVersion?: Maybe<Scalars['BigFloat']['output']>;
};

export type Migration = Node & {
  __typename?: 'Migration';
  executedAt?: Maybe<Scalars['Datetime']['output']>;
  hash: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

export type MigrationAggregates = {
  __typename?: 'MigrationAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<MigrationAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<MigrationDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<MigrationMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<MigrationMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<MigrationStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<MigrationStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<MigrationSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<MigrationVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<MigrationVarianceSampleAggregates>;
};

export type MigrationAverageAggregates = {
  __typename?: 'MigrationAverageAggregates';
  /** Mean average of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `Migration` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type MigrationCondition = {
  /** Checks for equality with the object’s `executedAt` field. */
  executedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `hash` field. */
  hash?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
};

export type MigrationDistinctCountAggregates = {
  __typename?: 'MigrationDistinctCountAggregates';
  /** Distinct count of executedAt across the matching connection */
  executedAt?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of hash across the matching connection */
  hash?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of id across the matching connection */
  id?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of name across the matching connection */
  name?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `Migration` object types. All fields are combined with a logical ‘and.’ */
export type MigrationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<MigrationFilter>>;
  /** Filter by the object’s `executedAt` field. */
  executedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `hash` field. */
  hash?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<MigrationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<MigrationFilter>>;
};

export type MigrationMaxAggregates = {
  __typename?: 'MigrationMaxAggregates';
  /** Maximum of executedAt across the matching connection */
  executedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Maximum of id across the matching connection */
  id?: Maybe<Scalars['Int']['output']>;
};

export type MigrationMinAggregates = {
  __typename?: 'MigrationMinAggregates';
  /** Minimum of executedAt across the matching connection */
  executedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Minimum of id across the matching connection */
  id?: Maybe<Scalars['Int']['output']>;
};

export type MigrationStddevPopulationAggregates = {
  __typename?: 'MigrationStddevPopulationAggregates';
  /** Population standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
};

export type MigrationStddevSampleAggregates = {
  __typename?: 'MigrationStddevSampleAggregates';
  /** Sample standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
};

export type MigrationSumAggregates = {
  __typename?: 'MigrationSumAggregates';
  /** Sum of id across the matching connection */
  id: Scalars['BigInt']['output'];
};

export type MigrationVariancePopulationAggregates = {
  __typename?: 'MigrationVariancePopulationAggregates';
  /** Population variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
};

export type MigrationVarianceSampleAggregates = {
  __typename?: 'MigrationVarianceSampleAggregates';
  /** Sample variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
};

/** A connection to a list of `Migration` values. */
export type MigrationsConnection = {
  __typename?: 'MigrationsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<MigrationAggregates>;
  /** A list of edges which contains the `Migration` and cursor to aid in pagination. */
  edges: Array<MigrationsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<MigrationAggregates>>;
  /** A list of `Migration` objects. */
  nodes: Array<Migration>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Migration` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `Migration` values. */
export type MigrationsConnectionGroupedAggregatesArgs = {
  groupBy: Array<MigrationsGroupBy>;
  having?: InputMaybe<MigrationsHavingInput>;
};

/** A `Migration` edge in the connection. */
export type MigrationsEdge = {
  __typename?: 'MigrationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Migration` at the end of the edge. */
  node: Migration;
};

/** Grouping methods for `Migration` for usage during aggregation. */
export type MigrationsGroupBy =
  | 'EXECUTED_AT'
  | 'EXECUTED_AT_TRUNCATED_TO_DAY'
  | 'EXECUTED_AT_TRUNCATED_TO_HOUR'
  | 'EXECUTED_AT_TRUNCATED_TO_MONTH'
  | 'EXECUTED_AT_TRUNCATED_TO_WEEK'
  | 'HASH';

export type MigrationsHavingAverageInput = {
  executedAt?: InputMaybe<HavingDatetimeFilter>;
  id?: InputMaybe<HavingIntFilter>;
};

export type MigrationsHavingDistinctCountInput = {
  executedAt?: InputMaybe<HavingDatetimeFilter>;
  id?: InputMaybe<HavingIntFilter>;
};

/** Conditions for `Migration` aggregates. */
export type MigrationsHavingInput = {
  AND?: InputMaybe<Array<MigrationsHavingInput>>;
  OR?: InputMaybe<Array<MigrationsHavingInput>>;
  average?: InputMaybe<MigrationsHavingAverageInput>;
  distinctCount?: InputMaybe<MigrationsHavingDistinctCountInput>;
  max?: InputMaybe<MigrationsHavingMaxInput>;
  min?: InputMaybe<MigrationsHavingMinInput>;
  stddevPopulation?: InputMaybe<MigrationsHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<MigrationsHavingStddevSampleInput>;
  sum?: InputMaybe<MigrationsHavingSumInput>;
  variancePopulation?: InputMaybe<MigrationsHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<MigrationsHavingVarianceSampleInput>;
};

export type MigrationsHavingMaxInput = {
  executedAt?: InputMaybe<HavingDatetimeFilter>;
  id?: InputMaybe<HavingIntFilter>;
};

export type MigrationsHavingMinInput = {
  executedAt?: InputMaybe<HavingDatetimeFilter>;
  id?: InputMaybe<HavingIntFilter>;
};

export type MigrationsHavingStddevPopulationInput = {
  executedAt?: InputMaybe<HavingDatetimeFilter>;
  id?: InputMaybe<HavingIntFilter>;
};

export type MigrationsHavingStddevSampleInput = {
  executedAt?: InputMaybe<HavingDatetimeFilter>;
  id?: InputMaybe<HavingIntFilter>;
};

export type MigrationsHavingSumInput = {
  executedAt?: InputMaybe<HavingDatetimeFilter>;
  id?: InputMaybe<HavingIntFilter>;
};

export type MigrationsHavingVariancePopulationInput = {
  executedAt?: InputMaybe<HavingDatetimeFilter>;
  id?: InputMaybe<HavingIntFilter>;
};

export type MigrationsHavingVarianceSampleInput = {
  executedAt?: InputMaybe<HavingDatetimeFilter>;
  id?: InputMaybe<HavingIntFilter>;
};

/** Methods to use when ordering `Migration`. */
export type MigrationsOrderBy =
  | 'EXECUTED_AT_ASC'
  | 'EXECUTED_AT_DESC'
  | 'HASH_ASC'
  | 'HASH_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** An object with a globally unique `ID`. */
export type Node = {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

export type Operator = Node & {
  __typename?: 'Operator';
  /** Reads a single `Account` that is related to this `Operator`. */
  accountByIdSs58: Account;
  activeDelegationFeeBps: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `Delegation`. */
  delegationsByOperatorIdSs58: DelegationsConnection;
  exceptionList: Scalars['JSON']['output'];
  idSs58: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  openDelegationEnabled: Scalars['Boolean']['output'];
  /** Reads and enables pagination through a set of `OperatorValidator`. */
  operatorValidatorsByOperatorIdSs58: OperatorValidatorsConnection;
  upcomingDelegationFeeBps: Scalars['Int']['output'];
};


export type OperatorDelegationsByOperatorIdSs58Args = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DelegationCondition>;
  filter?: InputMaybe<DelegationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DelegationsOrderBy>>;
};


export type OperatorOperatorValidatorsByOperatorIdSs58Args = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OperatorValidatorCondition>;
  filter?: InputMaybe<OperatorValidatorFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OperatorValidatorsOrderBy>>;
};

export type OperatorAggregates = {
  __typename?: 'OperatorAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<OperatorAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<OperatorDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<OperatorMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<OperatorMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<OperatorStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<OperatorStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<OperatorSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<OperatorVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<OperatorVarianceSampleAggregates>;
};

export type OperatorAverageAggregates = {
  __typename?: 'OperatorAverageAggregates';
  /** Mean average of activeDelegationFeeBps across the matching connection */
  activeDelegationFeeBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of upcomingDelegationFeeBps across the matching connection */
  upcomingDelegationFeeBps?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `Operator` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type OperatorCondition = {
  /** Checks for equality with the object’s `activeDelegationFeeBps` field. */
  activeDelegationFeeBps?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `exceptionList` field. */
  exceptionList?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `idSs58` field. */
  idSs58?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `openDelegationEnabled` field. */
  openDelegationEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `upcomingDelegationFeeBps` field. */
  upcomingDelegationFeeBps?: InputMaybe<Scalars['Int']['input']>;
};

export type OperatorDistinctCountAggregates = {
  __typename?: 'OperatorDistinctCountAggregates';
  /** Distinct count of activeDelegationFeeBps across the matching connection */
  activeDelegationFeeBps?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of exceptionList across the matching connection */
  exceptionList?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of idSs58 across the matching connection */
  idSs58?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of openDelegationEnabled across the matching connection */
  openDelegationEnabled?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of upcomingDelegationFeeBps across the matching connection */
  upcomingDelegationFeeBps?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `Operator` object types. All fields are combined with a logical ‘and.’ */
export type OperatorFilter = {
  /** Filter by the object’s `accountByIdSs58` relation. */
  accountByIdSs58?: InputMaybe<AccountFilter>;
  /** Filter by the object’s `activeDelegationFeeBps` field. */
  activeDelegationFeeBps?: InputMaybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<OperatorFilter>>;
  /** Filter by the object’s `delegationsByOperatorIdSs58` relation. */
  delegationsByOperatorIdSs58?: InputMaybe<OperatorToManyDelegationFilter>;
  /** Some related `delegationsByOperatorIdSs58` exist. */
  delegationsByOperatorIdSs58Exist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `exceptionList` field. */
  exceptionList?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `idSs58` field. */
  idSs58?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<OperatorFilter>;
  /** Filter by the object’s `openDelegationEnabled` field. */
  openDelegationEnabled?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `operatorValidatorsByOperatorIdSs58` relation. */
  operatorValidatorsByOperatorIdSs58?: InputMaybe<OperatorToManyOperatorValidatorFilter>;
  /** Some related `operatorValidatorsByOperatorIdSs58` exist. */
  operatorValidatorsByOperatorIdSs58Exist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<OperatorFilter>>;
  /** Filter by the object’s `upcomingDelegationFeeBps` field. */
  upcomingDelegationFeeBps?: InputMaybe<IntFilter>;
};

/** Grouping methods for `Operator` for usage during aggregation. */
export type OperatorGroupBy =
  | 'ACTIVE_DELEGATION_FEE_BPS'
  | 'EXCEPTION_LIST'
  | 'OPEN_DELEGATION_ENABLED'
  | 'UPCOMING_DELEGATION_FEE_BPS';

export type OperatorHavingAverageInput = {
  activeDelegationFeeBps?: InputMaybe<HavingIntFilter>;
  upcomingDelegationFeeBps?: InputMaybe<HavingIntFilter>;
};

export type OperatorHavingDistinctCountInput = {
  activeDelegationFeeBps?: InputMaybe<HavingIntFilter>;
  upcomingDelegationFeeBps?: InputMaybe<HavingIntFilter>;
};

/** Conditions for `Operator` aggregates. */
export type OperatorHavingInput = {
  AND?: InputMaybe<Array<OperatorHavingInput>>;
  OR?: InputMaybe<Array<OperatorHavingInput>>;
  average?: InputMaybe<OperatorHavingAverageInput>;
  distinctCount?: InputMaybe<OperatorHavingDistinctCountInput>;
  max?: InputMaybe<OperatorHavingMaxInput>;
  min?: InputMaybe<OperatorHavingMinInput>;
  stddevPopulation?: InputMaybe<OperatorHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<OperatorHavingStddevSampleInput>;
  sum?: InputMaybe<OperatorHavingSumInput>;
  variancePopulation?: InputMaybe<OperatorHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<OperatorHavingVarianceSampleInput>;
};

export type OperatorHavingMaxInput = {
  activeDelegationFeeBps?: InputMaybe<HavingIntFilter>;
  upcomingDelegationFeeBps?: InputMaybe<HavingIntFilter>;
};

export type OperatorHavingMinInput = {
  activeDelegationFeeBps?: InputMaybe<HavingIntFilter>;
  upcomingDelegationFeeBps?: InputMaybe<HavingIntFilter>;
};

export type OperatorHavingStddevPopulationInput = {
  activeDelegationFeeBps?: InputMaybe<HavingIntFilter>;
  upcomingDelegationFeeBps?: InputMaybe<HavingIntFilter>;
};

export type OperatorHavingStddevSampleInput = {
  activeDelegationFeeBps?: InputMaybe<HavingIntFilter>;
  upcomingDelegationFeeBps?: InputMaybe<HavingIntFilter>;
};

export type OperatorHavingSumInput = {
  activeDelegationFeeBps?: InputMaybe<HavingIntFilter>;
  upcomingDelegationFeeBps?: InputMaybe<HavingIntFilter>;
};

export type OperatorHavingVariancePopulationInput = {
  activeDelegationFeeBps?: InputMaybe<HavingIntFilter>;
  upcomingDelegationFeeBps?: InputMaybe<HavingIntFilter>;
};

export type OperatorHavingVarianceSampleInput = {
  activeDelegationFeeBps?: InputMaybe<HavingIntFilter>;
  upcomingDelegationFeeBps?: InputMaybe<HavingIntFilter>;
};

export type OperatorMaxAggregates = {
  __typename?: 'OperatorMaxAggregates';
  /** Maximum of activeDelegationFeeBps across the matching connection */
  activeDelegationFeeBps?: Maybe<Scalars['Int']['output']>;
  /** Maximum of upcomingDelegationFeeBps across the matching connection */
  upcomingDelegationFeeBps?: Maybe<Scalars['Int']['output']>;
};

export type OperatorMinAggregates = {
  __typename?: 'OperatorMinAggregates';
  /** Minimum of activeDelegationFeeBps across the matching connection */
  activeDelegationFeeBps?: Maybe<Scalars['Int']['output']>;
  /** Minimum of upcomingDelegationFeeBps across the matching connection */
  upcomingDelegationFeeBps?: Maybe<Scalars['Int']['output']>;
};

export type OperatorStddevPopulationAggregates = {
  __typename?: 'OperatorStddevPopulationAggregates';
  /** Population standard deviation of activeDelegationFeeBps across the matching connection */
  activeDelegationFeeBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of upcomingDelegationFeeBps across the matching connection */
  upcomingDelegationFeeBps?: Maybe<Scalars['BigFloat']['output']>;
};

export type OperatorStddevSampleAggregates = {
  __typename?: 'OperatorStddevSampleAggregates';
  /** Sample standard deviation of activeDelegationFeeBps across the matching connection */
  activeDelegationFeeBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of upcomingDelegationFeeBps across the matching connection */
  upcomingDelegationFeeBps?: Maybe<Scalars['BigFloat']['output']>;
};

export type OperatorSumAggregates = {
  __typename?: 'OperatorSumAggregates';
  /** Sum of activeDelegationFeeBps across the matching connection */
  activeDelegationFeeBps: Scalars['BigInt']['output'];
  /** Sum of upcomingDelegationFeeBps across the matching connection */
  upcomingDelegationFeeBps: Scalars['BigInt']['output'];
};

/** A filter to be used against many `Delegation` object types. All fields are combined with a logical ‘and.’ */
export type OperatorToManyDelegationFilter = {
  /** Aggregates across related `Delegation` match the filter criteria. */
  aggregates?: InputMaybe<DelegationAggregatesFilter>;
  /** Every related `Delegation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DelegationFilter>;
  /** No related `Delegation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DelegationFilter>;
  /** Some related `Delegation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DelegationFilter>;
};

/** A filter to be used against many `OperatorValidator` object types. All fields are combined with a logical ‘and.’ */
export type OperatorToManyOperatorValidatorFilter = {
  /** Aggregates across related `OperatorValidator` match the filter criteria. */
  aggregates?: InputMaybe<OperatorValidatorAggregatesFilter>;
  /** Every related `OperatorValidator` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<OperatorValidatorFilter>;
  /** No related `OperatorValidator` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<OperatorValidatorFilter>;
  /** Some related `OperatorValidator` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<OperatorValidatorFilter>;
};

export type OperatorValidator = Node & {
  __typename?: 'OperatorValidator';
  activeAmount: Scalars['BigFloat']['output'];
  bond: Scalars['BigFloat']['output'];
  id: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Operator` that is related to this `OperatorValidator`. */
  operatorByOperatorIdSs58: Operator;
  operatorIdSs58: Scalars['String']['output'];
  upcomingAmount: Scalars['BigFloat']['output'];
  /** Reads a single `Validator` that is related to this `OperatorValidator`. */
  validatorByValidatorIdSs58: Validator;
  validatorIdSs58: Scalars['String']['output'];
};

export type OperatorValidatorAggregates = {
  __typename?: 'OperatorValidatorAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<OperatorValidatorAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<OperatorValidatorDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<OperatorValidatorMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<OperatorValidatorMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<OperatorValidatorStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<OperatorValidatorStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<OperatorValidatorSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<OperatorValidatorVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<OperatorValidatorVarianceSampleAggregates>;
};

/** A filter to be used against aggregates of `OperatorValidator` object types. */
export type OperatorValidatorAggregatesFilter = {
  /** Mean average aggregate over matching `OperatorValidator` objects. */
  average?: InputMaybe<OperatorValidatorAverageAggregateFilter>;
  /** Distinct count aggregate over matching `OperatorValidator` objects. */
  distinctCount?: InputMaybe<OperatorValidatorDistinctCountAggregateFilter>;
  /** A filter that must pass for the relevant `OperatorValidator` object to be included within the aggregate. */
  filter?: InputMaybe<OperatorValidatorFilter>;
  /** Maximum aggregate over matching `OperatorValidator` objects. */
  max?: InputMaybe<OperatorValidatorMaxAggregateFilter>;
  /** Minimum aggregate over matching `OperatorValidator` objects. */
  min?: InputMaybe<OperatorValidatorMinAggregateFilter>;
  /** Population standard deviation aggregate over matching `OperatorValidator` objects. */
  stddevPopulation?: InputMaybe<OperatorValidatorStddevPopulationAggregateFilter>;
  /** Sample standard deviation aggregate over matching `OperatorValidator` objects. */
  stddevSample?: InputMaybe<OperatorValidatorStddevSampleAggregateFilter>;
  /** Sum aggregate over matching `OperatorValidator` objects. */
  sum?: InputMaybe<OperatorValidatorSumAggregateFilter>;
  /** Population variance aggregate over matching `OperatorValidator` objects. */
  variancePopulation?: InputMaybe<OperatorValidatorVariancePopulationAggregateFilter>;
  /** Sample variance aggregate over matching `OperatorValidator` objects. */
  varianceSample?: InputMaybe<OperatorValidatorVarianceSampleAggregateFilter>;
};

export type OperatorValidatorAverageAggregateFilter = {
  activeAmount?: InputMaybe<BigFloatFilter>;
  bond?: InputMaybe<BigFloatFilter>;
  upcomingAmount?: InputMaybe<BigFloatFilter>;
};

export type OperatorValidatorAverageAggregates = {
  __typename?: 'OperatorValidatorAverageAggregates';
  /** Mean average of activeAmount across the matching connection */
  activeAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of bond across the matching connection */
  bond?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of upcomingAmount across the matching connection */
  upcomingAmount?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `OperatorValidator` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type OperatorValidatorCondition = {
  /** Checks for equality with the object’s `activeAmount` field. */
  activeAmount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `bond` field. */
  bond?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `operatorIdSs58` field. */
  operatorIdSs58?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `upcomingAmount` field. */
  upcomingAmount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `validatorIdSs58` field. */
  validatorIdSs58?: InputMaybe<Scalars['String']['input']>;
};

export type OperatorValidatorDistinctCountAggregateFilter = {
  activeAmount?: InputMaybe<BigIntFilter>;
  bond?: InputMaybe<BigIntFilter>;
  id?: InputMaybe<BigIntFilter>;
  operatorIdSs58?: InputMaybe<BigIntFilter>;
  upcomingAmount?: InputMaybe<BigIntFilter>;
  validatorIdSs58?: InputMaybe<BigIntFilter>;
};

export type OperatorValidatorDistinctCountAggregates = {
  __typename?: 'OperatorValidatorDistinctCountAggregates';
  /** Distinct count of activeAmount across the matching connection */
  activeAmount?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of bond across the matching connection */
  bond?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of id across the matching connection */
  id?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of operatorIdSs58 across the matching connection */
  operatorIdSs58?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of upcomingAmount across the matching connection */
  upcomingAmount?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of validatorIdSs58 across the matching connection */
  validatorIdSs58?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `OperatorValidator` object types. All fields are combined with a logical ‘and.’ */
export type OperatorValidatorFilter = {
  /** Filter by the object’s `activeAmount` field. */
  activeAmount?: InputMaybe<BigFloatFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<OperatorValidatorFilter>>;
  /** Filter by the object’s `bond` field. */
  bond?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<OperatorValidatorFilter>;
  /** Filter by the object’s `operatorByOperatorIdSs58` relation. */
  operatorByOperatorIdSs58?: InputMaybe<OperatorFilter>;
  /** Filter by the object’s `operatorIdSs58` field. */
  operatorIdSs58?: InputMaybe<StringFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<OperatorValidatorFilter>>;
  /** Filter by the object’s `upcomingAmount` field. */
  upcomingAmount?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `validatorByValidatorIdSs58` relation. */
  validatorByValidatorIdSs58?: InputMaybe<ValidatorFilter>;
  /** Filter by the object’s `validatorIdSs58` field. */
  validatorIdSs58?: InputMaybe<StringFilter>;
};

/** Grouping methods for `OperatorValidator` for usage during aggregation. */
export type OperatorValidatorGroupBy =
  | 'ACTIVE_AMOUNT'
  | 'BOND'
  | 'OPERATOR_ID_SS58'
  | 'UPCOMING_AMOUNT'
  | 'VALIDATOR_ID_SS58';

export type OperatorValidatorHavingAverageInput = {
  activeAmount?: InputMaybe<HavingBigfloatFilter>;
  bond?: InputMaybe<HavingBigfloatFilter>;
  upcomingAmount?: InputMaybe<HavingBigfloatFilter>;
};

export type OperatorValidatorHavingDistinctCountInput = {
  activeAmount?: InputMaybe<HavingBigfloatFilter>;
  bond?: InputMaybe<HavingBigfloatFilter>;
  upcomingAmount?: InputMaybe<HavingBigfloatFilter>;
};

/** Conditions for `OperatorValidator` aggregates. */
export type OperatorValidatorHavingInput = {
  AND?: InputMaybe<Array<OperatorValidatorHavingInput>>;
  OR?: InputMaybe<Array<OperatorValidatorHavingInput>>;
  average?: InputMaybe<OperatorValidatorHavingAverageInput>;
  distinctCount?: InputMaybe<OperatorValidatorHavingDistinctCountInput>;
  max?: InputMaybe<OperatorValidatorHavingMaxInput>;
  min?: InputMaybe<OperatorValidatorHavingMinInput>;
  stddevPopulation?: InputMaybe<OperatorValidatorHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<OperatorValidatorHavingStddevSampleInput>;
  sum?: InputMaybe<OperatorValidatorHavingSumInput>;
  variancePopulation?: InputMaybe<OperatorValidatorHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<OperatorValidatorHavingVarianceSampleInput>;
};

export type OperatorValidatorHavingMaxInput = {
  activeAmount?: InputMaybe<HavingBigfloatFilter>;
  bond?: InputMaybe<HavingBigfloatFilter>;
  upcomingAmount?: InputMaybe<HavingBigfloatFilter>;
};

export type OperatorValidatorHavingMinInput = {
  activeAmount?: InputMaybe<HavingBigfloatFilter>;
  bond?: InputMaybe<HavingBigfloatFilter>;
  upcomingAmount?: InputMaybe<HavingBigfloatFilter>;
};

export type OperatorValidatorHavingStddevPopulationInput = {
  activeAmount?: InputMaybe<HavingBigfloatFilter>;
  bond?: InputMaybe<HavingBigfloatFilter>;
  upcomingAmount?: InputMaybe<HavingBigfloatFilter>;
};

export type OperatorValidatorHavingStddevSampleInput = {
  activeAmount?: InputMaybe<HavingBigfloatFilter>;
  bond?: InputMaybe<HavingBigfloatFilter>;
  upcomingAmount?: InputMaybe<HavingBigfloatFilter>;
};

export type OperatorValidatorHavingSumInput = {
  activeAmount?: InputMaybe<HavingBigfloatFilter>;
  bond?: InputMaybe<HavingBigfloatFilter>;
  upcomingAmount?: InputMaybe<HavingBigfloatFilter>;
};

export type OperatorValidatorHavingVariancePopulationInput = {
  activeAmount?: InputMaybe<HavingBigfloatFilter>;
  bond?: InputMaybe<HavingBigfloatFilter>;
  upcomingAmount?: InputMaybe<HavingBigfloatFilter>;
};

export type OperatorValidatorHavingVarianceSampleInput = {
  activeAmount?: InputMaybe<HavingBigfloatFilter>;
  bond?: InputMaybe<HavingBigfloatFilter>;
  upcomingAmount?: InputMaybe<HavingBigfloatFilter>;
};

export type OperatorValidatorMaxAggregateFilter = {
  activeAmount?: InputMaybe<BigFloatFilter>;
  bond?: InputMaybe<BigFloatFilter>;
  upcomingAmount?: InputMaybe<BigFloatFilter>;
};

export type OperatorValidatorMaxAggregates = {
  __typename?: 'OperatorValidatorMaxAggregates';
  /** Maximum of activeAmount across the matching connection */
  activeAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of bond across the matching connection */
  bond?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of upcomingAmount across the matching connection */
  upcomingAmount?: Maybe<Scalars['BigFloat']['output']>;
};

export type OperatorValidatorMinAggregateFilter = {
  activeAmount?: InputMaybe<BigFloatFilter>;
  bond?: InputMaybe<BigFloatFilter>;
  upcomingAmount?: InputMaybe<BigFloatFilter>;
};

export type OperatorValidatorMinAggregates = {
  __typename?: 'OperatorValidatorMinAggregates';
  /** Minimum of activeAmount across the matching connection */
  activeAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of bond across the matching connection */
  bond?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of upcomingAmount across the matching connection */
  upcomingAmount?: Maybe<Scalars['BigFloat']['output']>;
};

export type OperatorValidatorStddevPopulationAggregateFilter = {
  activeAmount?: InputMaybe<BigFloatFilter>;
  bond?: InputMaybe<BigFloatFilter>;
  upcomingAmount?: InputMaybe<BigFloatFilter>;
};

export type OperatorValidatorStddevPopulationAggregates = {
  __typename?: 'OperatorValidatorStddevPopulationAggregates';
  /** Population standard deviation of activeAmount across the matching connection */
  activeAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of bond across the matching connection */
  bond?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of upcomingAmount across the matching connection */
  upcomingAmount?: Maybe<Scalars['BigFloat']['output']>;
};

export type OperatorValidatorStddevSampleAggregateFilter = {
  activeAmount?: InputMaybe<BigFloatFilter>;
  bond?: InputMaybe<BigFloatFilter>;
  upcomingAmount?: InputMaybe<BigFloatFilter>;
};

export type OperatorValidatorStddevSampleAggregates = {
  __typename?: 'OperatorValidatorStddevSampleAggregates';
  /** Sample standard deviation of activeAmount across the matching connection */
  activeAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of bond across the matching connection */
  bond?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of upcomingAmount across the matching connection */
  upcomingAmount?: Maybe<Scalars['BigFloat']['output']>;
};

export type OperatorValidatorSumAggregateFilter = {
  activeAmount?: InputMaybe<BigFloatFilter>;
  bond?: InputMaybe<BigFloatFilter>;
  upcomingAmount?: InputMaybe<BigFloatFilter>;
};

export type OperatorValidatorSumAggregates = {
  __typename?: 'OperatorValidatorSumAggregates';
  /** Sum of activeAmount across the matching connection */
  activeAmount: Scalars['BigFloat']['output'];
  /** Sum of bond across the matching connection */
  bond: Scalars['BigFloat']['output'];
  /** Sum of upcomingAmount across the matching connection */
  upcomingAmount: Scalars['BigFloat']['output'];
};

export type OperatorValidatorVariancePopulationAggregateFilter = {
  activeAmount?: InputMaybe<BigFloatFilter>;
  bond?: InputMaybe<BigFloatFilter>;
  upcomingAmount?: InputMaybe<BigFloatFilter>;
};

export type OperatorValidatorVariancePopulationAggregates = {
  __typename?: 'OperatorValidatorVariancePopulationAggregates';
  /** Population variance of activeAmount across the matching connection */
  activeAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of bond across the matching connection */
  bond?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of upcomingAmount across the matching connection */
  upcomingAmount?: Maybe<Scalars['BigFloat']['output']>;
};

export type OperatorValidatorVarianceSampleAggregateFilter = {
  activeAmount?: InputMaybe<BigFloatFilter>;
  bond?: InputMaybe<BigFloatFilter>;
  upcomingAmount?: InputMaybe<BigFloatFilter>;
};

export type OperatorValidatorVarianceSampleAggregates = {
  __typename?: 'OperatorValidatorVarianceSampleAggregates';
  /** Sample variance of activeAmount across the matching connection */
  activeAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of bond across the matching connection */
  bond?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of upcomingAmount across the matching connection */
  upcomingAmount?: Maybe<Scalars['BigFloat']['output']>;
};

/** A connection to a list of `OperatorValidator` values. */
export type OperatorValidatorsConnection = {
  __typename?: 'OperatorValidatorsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<OperatorValidatorAggregates>;
  /** A list of edges which contains the `OperatorValidator` and cursor to aid in pagination. */
  edges: Array<OperatorValidatorsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<OperatorValidatorAggregates>>;
  /** A list of `OperatorValidator` objects. */
  nodes: Array<OperatorValidator>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `OperatorValidator` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `OperatorValidator` values. */
export type OperatorValidatorsConnectionGroupedAggregatesArgs = {
  groupBy: Array<OperatorValidatorGroupBy>;
  having?: InputMaybe<OperatorValidatorHavingInput>;
};

/** A `OperatorValidator` edge in the connection. */
export type OperatorValidatorsEdge = {
  __typename?: 'OperatorValidatorsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `OperatorValidator` at the end of the edge. */
  node: OperatorValidator;
};

/** Methods to use when ordering `OperatorValidator`. */
export type OperatorValidatorsOrderBy =
  | 'ACTIVE_AMOUNT_ASC'
  | 'ACTIVE_AMOUNT_DESC'
  | 'BOND_ASC'
  | 'BOND_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL'
  | 'OPERATOR_ID_SS58_ASC'
  | 'OPERATOR_ID_SS58_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'UPCOMING_AMOUNT_ASC'
  | 'UPCOMING_AMOUNT_DESC'
  | 'VALIDATOR_ID_SS58_ASC'
  | 'VALIDATOR_ID_SS58_DESC';

export type OperatorVariancePopulationAggregates = {
  __typename?: 'OperatorVariancePopulationAggregates';
  /** Population variance of activeDelegationFeeBps across the matching connection */
  activeDelegationFeeBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of upcomingDelegationFeeBps across the matching connection */
  upcomingDelegationFeeBps?: Maybe<Scalars['BigFloat']['output']>;
};

export type OperatorVarianceSampleAggregates = {
  __typename?: 'OperatorVarianceSampleAggregates';
  /** Sample variance of activeDelegationFeeBps across the matching connection */
  activeDelegationFeeBps?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of upcomingDelegationFeeBps across the matching connection */
  upcomingDelegationFeeBps?: Maybe<Scalars['BigFloat']['output']>;
};

/** A connection to a list of `Operator` values. */
export type OperatorsConnection = {
  __typename?: 'OperatorsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<OperatorAggregates>;
  /** A list of edges which contains the `Operator` and cursor to aid in pagination. */
  edges: Array<OperatorsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<OperatorAggregates>>;
  /** A list of `Operator` objects. */
  nodes: Array<Operator>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Operator` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `Operator` values. */
export type OperatorsConnectionGroupedAggregatesArgs = {
  groupBy: Array<OperatorGroupBy>;
  having?: InputMaybe<OperatorHavingInput>;
};

/** A `Operator` edge in the connection. */
export type OperatorsEdge = {
  __typename?: 'OperatorsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Operator` at the end of the edge. */
  node: Operator;
};

/** Methods to use when ordering `Operator`. */
export type OperatorsOrderBy =
  | 'ACTIVE_DELEGATION_FEE_BPS_ASC'
  | 'ACTIVE_DELEGATION_FEE_BPS_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_AVERAGE_ACTIVE_AMOUNT_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_AVERAGE_ACTIVE_AMOUNT_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_AVERAGE_DELEGATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_AVERAGE_DELEGATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_AVERAGE_OPERATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_AVERAGE_OPERATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_AVERAGE_UPCOMING_AMOUNT_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_AVERAGE_UPCOMING_AMOUNT_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_COUNT_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_COUNT_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_DISTINCT_COUNT_ACTIVE_AMOUNT_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_DISTINCT_COUNT_ACTIVE_AMOUNT_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_DISTINCT_COUNT_DELEGATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_DISTINCT_COUNT_DELEGATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_DISTINCT_COUNT_OPERATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_DISTINCT_COUNT_OPERATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_DISTINCT_COUNT_UPCOMING_AMOUNT_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_DISTINCT_COUNT_UPCOMING_AMOUNT_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_MAX_ACTIVE_AMOUNT_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_MAX_ACTIVE_AMOUNT_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_MAX_DELEGATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_MAX_DELEGATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_MAX_OPERATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_MAX_OPERATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_MAX_UPCOMING_AMOUNT_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_MAX_UPCOMING_AMOUNT_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_MIN_ACTIVE_AMOUNT_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_MIN_ACTIVE_AMOUNT_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_MIN_DELEGATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_MIN_DELEGATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_MIN_OPERATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_MIN_OPERATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_MIN_UPCOMING_AMOUNT_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_MIN_UPCOMING_AMOUNT_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_STDDEV_POPULATION_ACTIVE_AMOUNT_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_STDDEV_POPULATION_ACTIVE_AMOUNT_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_STDDEV_POPULATION_DELEGATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_STDDEV_POPULATION_DELEGATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_STDDEV_POPULATION_OPERATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_STDDEV_POPULATION_OPERATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_STDDEV_POPULATION_UPCOMING_AMOUNT_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_STDDEV_POPULATION_UPCOMING_AMOUNT_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_STDDEV_SAMPLE_ACTIVE_AMOUNT_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_STDDEV_SAMPLE_ACTIVE_AMOUNT_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_STDDEV_SAMPLE_DELEGATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_STDDEV_SAMPLE_DELEGATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_STDDEV_SAMPLE_OPERATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_STDDEV_SAMPLE_OPERATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_STDDEV_SAMPLE_UPCOMING_AMOUNT_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_STDDEV_SAMPLE_UPCOMING_AMOUNT_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_SUM_ACTIVE_AMOUNT_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_SUM_ACTIVE_AMOUNT_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_SUM_DELEGATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_SUM_DELEGATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_SUM_OPERATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_SUM_OPERATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_SUM_UPCOMING_AMOUNT_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_SUM_UPCOMING_AMOUNT_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_VARIANCE_POPULATION_ACTIVE_AMOUNT_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_VARIANCE_POPULATION_ACTIVE_AMOUNT_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_VARIANCE_POPULATION_DELEGATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_VARIANCE_POPULATION_DELEGATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_VARIANCE_POPULATION_OPERATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_VARIANCE_POPULATION_OPERATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_VARIANCE_POPULATION_UPCOMING_AMOUNT_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_VARIANCE_POPULATION_UPCOMING_AMOUNT_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_VARIANCE_SAMPLE_ACTIVE_AMOUNT_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_VARIANCE_SAMPLE_ACTIVE_AMOUNT_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_VARIANCE_SAMPLE_DELEGATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_VARIANCE_SAMPLE_DELEGATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_VARIANCE_SAMPLE_OPERATOR_ID_SS58_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_VARIANCE_SAMPLE_OPERATOR_ID_SS58_DESC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_VARIANCE_SAMPLE_UPCOMING_AMOUNT_ASC'
  | 'DELEGATIONS_BY_OPERATOR_ID_SS58_VARIANCE_SAMPLE_UPCOMING_AMOUNT_DESC'
  | 'EXCEPTION_LIST_ASC'
  | 'EXCEPTION_LIST_DESC'
  | 'ID_SS58_ASC'
  | 'ID_SS58_DESC'
  | 'NATURAL'
  | 'OPEN_DELEGATION_ENABLED_ASC'
  | 'OPEN_DELEGATION_ENABLED_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_AVERAGE_ACTIVE_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_AVERAGE_ACTIVE_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_AVERAGE_BOND_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_AVERAGE_BOND_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_AVERAGE_ID_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_AVERAGE_ID_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_AVERAGE_OPERATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_AVERAGE_OPERATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_AVERAGE_UPCOMING_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_AVERAGE_UPCOMING_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_AVERAGE_VALIDATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_AVERAGE_VALIDATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_COUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_COUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_DISTINCT_COUNT_ACTIVE_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_DISTINCT_COUNT_ACTIVE_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_DISTINCT_COUNT_BOND_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_DISTINCT_COUNT_BOND_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_DISTINCT_COUNT_ID_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_DISTINCT_COUNT_ID_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_DISTINCT_COUNT_OPERATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_DISTINCT_COUNT_OPERATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_DISTINCT_COUNT_UPCOMING_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_DISTINCT_COUNT_UPCOMING_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_DISTINCT_COUNT_VALIDATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_DISTINCT_COUNT_VALIDATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_MAX_ACTIVE_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_MAX_ACTIVE_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_MAX_BOND_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_MAX_BOND_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_MAX_ID_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_MAX_ID_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_MAX_OPERATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_MAX_OPERATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_MAX_UPCOMING_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_MAX_UPCOMING_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_MAX_VALIDATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_MAX_VALIDATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_MIN_ACTIVE_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_MIN_ACTIVE_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_MIN_BOND_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_MIN_BOND_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_MIN_ID_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_MIN_ID_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_MIN_OPERATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_MIN_OPERATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_MIN_UPCOMING_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_MIN_UPCOMING_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_MIN_VALIDATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_MIN_VALIDATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_STDDEV_POPULATION_ACTIVE_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_STDDEV_POPULATION_ACTIVE_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_STDDEV_POPULATION_BOND_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_STDDEV_POPULATION_BOND_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_STDDEV_POPULATION_ID_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_STDDEV_POPULATION_ID_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_STDDEV_POPULATION_OPERATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_STDDEV_POPULATION_OPERATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_STDDEV_POPULATION_UPCOMING_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_STDDEV_POPULATION_UPCOMING_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_STDDEV_POPULATION_VALIDATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_STDDEV_POPULATION_VALIDATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_STDDEV_SAMPLE_ACTIVE_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_STDDEV_SAMPLE_ACTIVE_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_STDDEV_SAMPLE_BOND_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_STDDEV_SAMPLE_BOND_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_STDDEV_SAMPLE_ID_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_STDDEV_SAMPLE_ID_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_STDDEV_SAMPLE_OPERATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_STDDEV_SAMPLE_OPERATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_STDDEV_SAMPLE_UPCOMING_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_STDDEV_SAMPLE_UPCOMING_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_STDDEV_SAMPLE_VALIDATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_STDDEV_SAMPLE_VALIDATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_SUM_ACTIVE_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_SUM_ACTIVE_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_SUM_BOND_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_SUM_BOND_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_SUM_ID_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_SUM_ID_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_SUM_OPERATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_SUM_OPERATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_SUM_UPCOMING_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_SUM_UPCOMING_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_SUM_VALIDATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_SUM_VALIDATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_VARIANCE_POPULATION_ACTIVE_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_VARIANCE_POPULATION_ACTIVE_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_VARIANCE_POPULATION_BOND_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_VARIANCE_POPULATION_BOND_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_VARIANCE_POPULATION_ID_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_VARIANCE_POPULATION_ID_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_VARIANCE_POPULATION_OPERATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_VARIANCE_POPULATION_OPERATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_VARIANCE_POPULATION_UPCOMING_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_VARIANCE_POPULATION_UPCOMING_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_VARIANCE_POPULATION_VALIDATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_VARIANCE_POPULATION_VALIDATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_VARIANCE_SAMPLE_ACTIVE_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_VARIANCE_SAMPLE_ACTIVE_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_VARIANCE_SAMPLE_BOND_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_VARIANCE_SAMPLE_BOND_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_VARIANCE_SAMPLE_ID_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_VARIANCE_SAMPLE_ID_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_VARIANCE_SAMPLE_OPERATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_VARIANCE_SAMPLE_OPERATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_VARIANCE_SAMPLE_UPCOMING_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_VARIANCE_SAMPLE_UPCOMING_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_VARIANCE_SAMPLE_VALIDATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_OPERATOR_ID_SS58_VARIANCE_SAMPLE_VALIDATOR_ID_SS58_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'UPCOMING_DELEGATION_FEE_BPS_ASC'
  | 'UPCOMING_DELEGATION_FEE_BPS_DESC';

export type OraclePrice = Node & {
  __typename?: 'OraclePrice';
  baseAsset: PriceAsset;
  id: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `LendingPool`. */
  lendingPoolsByOraclePriceId: LendingPoolsConnection;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  price: Scalars['Float']['output'];
  quoteAsset: PriceAsset;
  updatedAtOracleTimestamp: Scalars['Datetime']['output'];
  updatedAtStatechainBlock: Scalars['Int']['output'];
};


export type OraclePriceLendingPoolsByOraclePriceIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LendingPoolCondition>;
  filter?: InputMaybe<LendingPoolFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LendingPoolsOrderBy>>;
};

export type OraclePriceAggregates = {
  __typename?: 'OraclePriceAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<OraclePriceAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<OraclePriceDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<OraclePriceMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<OraclePriceMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<OraclePriceStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<OraclePriceStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<OraclePriceSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<OraclePriceVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<OraclePriceVarianceSampleAggregates>;
};

export type OraclePriceAverageAggregates = {
  __typename?: 'OraclePriceAverageAggregates';
  /** Mean average of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of price across the matching connection */
  price?: Maybe<Scalars['Float']['output']>;
  /** Mean average of updatedAtStatechainBlock across the matching connection */
  updatedAtStatechainBlock?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `OraclePrice` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type OraclePriceCondition = {
  /** Checks for equality with the object’s `baseAsset` field. */
  baseAsset?: InputMaybe<PriceAsset>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `price` field. */
  price?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `quoteAsset` field. */
  quoteAsset?: InputMaybe<PriceAsset>;
  /** Checks for equality with the object’s `updatedAtOracleTimestamp` field. */
  updatedAtOracleTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `updatedAtStatechainBlock` field. */
  updatedAtStatechainBlock?: InputMaybe<Scalars['Int']['input']>;
};

export type OraclePriceDistinctCountAggregates = {
  __typename?: 'OraclePriceDistinctCountAggregates';
  /** Distinct count of baseAsset across the matching connection */
  baseAsset?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of id across the matching connection */
  id?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of price across the matching connection */
  price?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of quoteAsset across the matching connection */
  quoteAsset?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of updatedAtOracleTimestamp across the matching connection */
  updatedAtOracleTimestamp?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of updatedAtStatechainBlock across the matching connection */
  updatedAtStatechainBlock?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `OraclePrice` object types. All fields are combined with a logical ‘and.’ */
export type OraclePriceFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<OraclePriceFilter>>;
  /** Filter by the object’s `baseAsset` field. */
  baseAsset?: InputMaybe<PriceAssetFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `lendingPoolsByOraclePriceId` relation. */
  lendingPoolsByOraclePriceId?: InputMaybe<OraclePriceToManyLendingPoolFilter>;
  /** Some related `lendingPoolsByOraclePriceId` exist. */
  lendingPoolsByOraclePriceIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Negates the expression. */
  not?: InputMaybe<OraclePriceFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<OraclePriceFilter>>;
  /** Filter by the object’s `price` field. */
  price?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `quoteAsset` field. */
  quoteAsset?: InputMaybe<PriceAssetFilter>;
  /** Filter by the object’s `updatedAtOracleTimestamp` field. */
  updatedAtOracleTimestamp?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updatedAtStatechainBlock` field. */
  updatedAtStatechainBlock?: InputMaybe<IntFilter>;
};

/** Grouping methods for `OraclePrice` for usage during aggregation. */
export type OraclePriceGroupBy =
  | 'BASE_ASSET'
  | 'PRICE'
  | 'QUOTE_ASSET'
  | 'UPDATED_AT_ORACLE_TIMESTAMP'
  | 'UPDATED_AT_ORACLE_TIMESTAMP_TRUNCATED_TO_DAY'
  | 'UPDATED_AT_ORACLE_TIMESTAMP_TRUNCATED_TO_HOUR'
  | 'UPDATED_AT_ORACLE_TIMESTAMP_TRUNCATED_TO_MONTH'
  | 'UPDATED_AT_ORACLE_TIMESTAMP_TRUNCATED_TO_WEEK'
  | 'UPDATED_AT_STATECHAIN_BLOCK';

export type OraclePriceHavingAverageInput = {
  id?: InputMaybe<HavingIntFilter>;
  price?: InputMaybe<HavingFloatFilter>;
  updatedAtOracleTimestamp?: InputMaybe<HavingDatetimeFilter>;
  updatedAtStatechainBlock?: InputMaybe<HavingIntFilter>;
};

export type OraclePriceHavingDistinctCountInput = {
  id?: InputMaybe<HavingIntFilter>;
  price?: InputMaybe<HavingFloatFilter>;
  updatedAtOracleTimestamp?: InputMaybe<HavingDatetimeFilter>;
  updatedAtStatechainBlock?: InputMaybe<HavingIntFilter>;
};

/** Conditions for `OraclePrice` aggregates. */
export type OraclePriceHavingInput = {
  AND?: InputMaybe<Array<OraclePriceHavingInput>>;
  OR?: InputMaybe<Array<OraclePriceHavingInput>>;
  average?: InputMaybe<OraclePriceHavingAverageInput>;
  distinctCount?: InputMaybe<OraclePriceHavingDistinctCountInput>;
  max?: InputMaybe<OraclePriceHavingMaxInput>;
  min?: InputMaybe<OraclePriceHavingMinInput>;
  stddevPopulation?: InputMaybe<OraclePriceHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<OraclePriceHavingStddevSampleInput>;
  sum?: InputMaybe<OraclePriceHavingSumInput>;
  variancePopulation?: InputMaybe<OraclePriceHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<OraclePriceHavingVarianceSampleInput>;
};

export type OraclePriceHavingMaxInput = {
  id?: InputMaybe<HavingIntFilter>;
  price?: InputMaybe<HavingFloatFilter>;
  updatedAtOracleTimestamp?: InputMaybe<HavingDatetimeFilter>;
  updatedAtStatechainBlock?: InputMaybe<HavingIntFilter>;
};

export type OraclePriceHavingMinInput = {
  id?: InputMaybe<HavingIntFilter>;
  price?: InputMaybe<HavingFloatFilter>;
  updatedAtOracleTimestamp?: InputMaybe<HavingDatetimeFilter>;
  updatedAtStatechainBlock?: InputMaybe<HavingIntFilter>;
};

export type OraclePriceHavingStddevPopulationInput = {
  id?: InputMaybe<HavingIntFilter>;
  price?: InputMaybe<HavingFloatFilter>;
  updatedAtOracleTimestamp?: InputMaybe<HavingDatetimeFilter>;
  updatedAtStatechainBlock?: InputMaybe<HavingIntFilter>;
};

export type OraclePriceHavingStddevSampleInput = {
  id?: InputMaybe<HavingIntFilter>;
  price?: InputMaybe<HavingFloatFilter>;
  updatedAtOracleTimestamp?: InputMaybe<HavingDatetimeFilter>;
  updatedAtStatechainBlock?: InputMaybe<HavingIntFilter>;
};

export type OraclePriceHavingSumInput = {
  id?: InputMaybe<HavingIntFilter>;
  price?: InputMaybe<HavingFloatFilter>;
  updatedAtOracleTimestamp?: InputMaybe<HavingDatetimeFilter>;
  updatedAtStatechainBlock?: InputMaybe<HavingIntFilter>;
};

export type OraclePriceHavingVariancePopulationInput = {
  id?: InputMaybe<HavingIntFilter>;
  price?: InputMaybe<HavingFloatFilter>;
  updatedAtOracleTimestamp?: InputMaybe<HavingDatetimeFilter>;
  updatedAtStatechainBlock?: InputMaybe<HavingIntFilter>;
};

export type OraclePriceHavingVarianceSampleInput = {
  id?: InputMaybe<HavingIntFilter>;
  price?: InputMaybe<HavingFloatFilter>;
  updatedAtOracleTimestamp?: InputMaybe<HavingDatetimeFilter>;
  updatedAtStatechainBlock?: InputMaybe<HavingIntFilter>;
};

export type OraclePriceMaxAggregates = {
  __typename?: 'OraclePriceMaxAggregates';
  /** Maximum of id across the matching connection */
  id?: Maybe<Scalars['Int']['output']>;
  /** Maximum of price across the matching connection */
  price?: Maybe<Scalars['Float']['output']>;
  /** Maximum of updatedAtOracleTimestamp across the matching connection */
  updatedAtOracleTimestamp?: Maybe<Scalars['Datetime']['output']>;
  /** Maximum of updatedAtStatechainBlock across the matching connection */
  updatedAtStatechainBlock?: Maybe<Scalars['Int']['output']>;
};

export type OraclePriceMinAggregates = {
  __typename?: 'OraclePriceMinAggregates';
  /** Minimum of id across the matching connection */
  id?: Maybe<Scalars['Int']['output']>;
  /** Minimum of price across the matching connection */
  price?: Maybe<Scalars['Float']['output']>;
  /** Minimum of updatedAtOracleTimestamp across the matching connection */
  updatedAtOracleTimestamp?: Maybe<Scalars['Datetime']['output']>;
  /** Minimum of updatedAtStatechainBlock across the matching connection */
  updatedAtStatechainBlock?: Maybe<Scalars['Int']['output']>;
};

export type OraclePriceStddevPopulationAggregates = {
  __typename?: 'OraclePriceStddevPopulationAggregates';
  /** Population standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of price across the matching connection */
  price?: Maybe<Scalars['Float']['output']>;
  /** Population standard deviation of updatedAtStatechainBlock across the matching connection */
  updatedAtStatechainBlock?: Maybe<Scalars['BigFloat']['output']>;
};

export type OraclePriceStddevSampleAggregates = {
  __typename?: 'OraclePriceStddevSampleAggregates';
  /** Sample standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of price across the matching connection */
  price?: Maybe<Scalars['Float']['output']>;
  /** Sample standard deviation of updatedAtStatechainBlock across the matching connection */
  updatedAtStatechainBlock?: Maybe<Scalars['BigFloat']['output']>;
};

export type OraclePriceSumAggregates = {
  __typename?: 'OraclePriceSumAggregates';
  /** Sum of id across the matching connection */
  id: Scalars['BigInt']['output'];
  /** Sum of price across the matching connection */
  price: Scalars['Float']['output'];
  /** Sum of updatedAtStatechainBlock across the matching connection */
  updatedAtStatechainBlock: Scalars['BigInt']['output'];
};

/** A filter to be used against many `LendingPool` object types. All fields are combined with a logical ‘and.’ */
export type OraclePriceToManyLendingPoolFilter = {
  /** Aggregates across related `LendingPool` match the filter criteria. */
  aggregates?: InputMaybe<LendingPoolAggregatesFilter>;
  /** Every related `LendingPool` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<LendingPoolFilter>;
  /** No related `LendingPool` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<LendingPoolFilter>;
  /** Some related `LendingPool` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<LendingPoolFilter>;
};

export type OraclePriceVariancePopulationAggregates = {
  __typename?: 'OraclePriceVariancePopulationAggregates';
  /** Population variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of price across the matching connection */
  price?: Maybe<Scalars['Float']['output']>;
  /** Population variance of updatedAtStatechainBlock across the matching connection */
  updatedAtStatechainBlock?: Maybe<Scalars['BigFloat']['output']>;
};

export type OraclePriceVarianceSampleAggregates = {
  __typename?: 'OraclePriceVarianceSampleAggregates';
  /** Sample variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of price across the matching connection */
  price?: Maybe<Scalars['Float']['output']>;
  /** Sample variance of updatedAtStatechainBlock across the matching connection */
  updatedAtStatechainBlock?: Maybe<Scalars['BigFloat']['output']>;
};

/** A connection to a list of `OraclePrice` values. */
export type OraclePricesConnection = {
  __typename?: 'OraclePricesConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<OraclePriceAggregates>;
  /** A list of edges which contains the `OraclePrice` and cursor to aid in pagination. */
  edges: Array<OraclePricesEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<OraclePriceAggregates>>;
  /** A list of `OraclePrice` objects. */
  nodes: Array<OraclePrice>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `OraclePrice` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `OraclePrice` values. */
export type OraclePricesConnectionGroupedAggregatesArgs = {
  groupBy: Array<OraclePriceGroupBy>;
  having?: InputMaybe<OraclePriceHavingInput>;
};

/** A `OraclePrice` edge in the connection. */
export type OraclePricesEdge = {
  __typename?: 'OraclePricesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `OraclePrice` at the end of the edge. */
  node: OraclePrice;
};

/** Methods to use when ordering `OraclePrice`. */
export type OraclePricesOrderBy =
  | 'BASE_ASSET_ASC'
  | 'BASE_ASSET_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_ADDING_LENDER_FUNDS_ENABLED_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_ADDING_LENDER_FUNDS_ENABLED_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_ASSET_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_ASSET_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_BORROWING_ENABLED_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_BORROWING_ENABLED_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_INTEREST_AT_JUNCTION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_INTEREST_AT_JUNCTION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_INTEREST_AT_MAX_UTILISATION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_INTEREST_AT_MAX_UTILISATION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_INTEREST_AT_ZERO_UTILISATION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_INTEREST_AT_ZERO_UTILISATION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_INTEREST_RATE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_INTEREST_RATE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_JUNCTION_UTILISATION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_JUNCTION_UTILISATION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_LIQUIDATION_FEE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_LIQUIDATION_FEE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_ORACLE_PRICE_ID_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_ORACLE_PRICE_ID_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_ORIGINATION_FEE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_ORIGINATION_FEE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_TOTAL_AMOUNT_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_TOTAL_AMOUNT_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_TOTAL_AMOUNT_USD_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_TOTAL_AMOUNT_USD_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_TOTAL_AVAILABLE_AMOUNT_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_TOTAL_AVAILABLE_AMOUNT_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_TOTAL_AVAILABLE_AMOUNT_USD_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_TOTAL_AVAILABLE_AMOUNT_USD_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_TOTAL_BORROWED_AMOUNT_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_TOTAL_BORROWED_AMOUNT_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_TOTAL_BORROWED_AMOUNT_USD_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_TOTAL_BORROWED_AMOUNT_USD_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_UTILISATION_RATE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_UTILISATION_RATE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_WITHDRAWING_LENDER_FUNDS_ENABLED_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_AVERAGE_WITHDRAWING_LENDER_FUNDS_ENABLED_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_COUNT_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_COUNT_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_ADDING_LENDER_FUNDS_ENABLED_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_ADDING_LENDER_FUNDS_ENABLED_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_ASSET_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_ASSET_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_BORROWING_ENABLED_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_BORROWING_ENABLED_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_INTEREST_AT_JUNCTION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_INTEREST_AT_JUNCTION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_INTEREST_AT_MAX_UTILISATION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_INTEREST_AT_MAX_UTILISATION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_INTEREST_AT_ZERO_UTILISATION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_INTEREST_AT_ZERO_UTILISATION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_INTEREST_RATE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_INTEREST_RATE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_JUNCTION_UTILISATION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_JUNCTION_UTILISATION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_LIQUIDATION_FEE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_LIQUIDATION_FEE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_ORACLE_PRICE_ID_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_ORACLE_PRICE_ID_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_ORIGINATION_FEE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_ORIGINATION_FEE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_TOTAL_AMOUNT_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_TOTAL_AMOUNT_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_TOTAL_AMOUNT_USD_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_TOTAL_AMOUNT_USD_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_TOTAL_AVAILABLE_AMOUNT_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_TOTAL_AVAILABLE_AMOUNT_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_TOTAL_AVAILABLE_AMOUNT_USD_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_TOTAL_AVAILABLE_AMOUNT_USD_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_TOTAL_BORROWED_AMOUNT_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_TOTAL_BORROWED_AMOUNT_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_TOTAL_BORROWED_AMOUNT_USD_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_TOTAL_BORROWED_AMOUNT_USD_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_UTILISATION_RATE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_UTILISATION_RATE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_WITHDRAWING_LENDER_FUNDS_ENABLED_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_DISTINCT_COUNT_WITHDRAWING_LENDER_FUNDS_ENABLED_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_ADDING_LENDER_FUNDS_ENABLED_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_ADDING_LENDER_FUNDS_ENABLED_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_ASSET_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_ASSET_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_BORROWING_ENABLED_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_BORROWING_ENABLED_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_INTEREST_AT_JUNCTION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_INTEREST_AT_JUNCTION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_INTEREST_AT_MAX_UTILISATION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_INTEREST_AT_MAX_UTILISATION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_INTEREST_AT_ZERO_UTILISATION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_INTEREST_AT_ZERO_UTILISATION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_INTEREST_RATE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_INTEREST_RATE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_JUNCTION_UTILISATION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_JUNCTION_UTILISATION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_LIQUIDATION_FEE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_LIQUIDATION_FEE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_ORACLE_PRICE_ID_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_ORACLE_PRICE_ID_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_ORIGINATION_FEE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_ORIGINATION_FEE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_TOTAL_AMOUNT_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_TOTAL_AMOUNT_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_TOTAL_AMOUNT_USD_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_TOTAL_AMOUNT_USD_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_TOTAL_AVAILABLE_AMOUNT_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_TOTAL_AVAILABLE_AMOUNT_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_TOTAL_AVAILABLE_AMOUNT_USD_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_TOTAL_AVAILABLE_AMOUNT_USD_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_TOTAL_BORROWED_AMOUNT_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_TOTAL_BORROWED_AMOUNT_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_TOTAL_BORROWED_AMOUNT_USD_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_TOTAL_BORROWED_AMOUNT_USD_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_UTILISATION_RATE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_UTILISATION_RATE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_WITHDRAWING_LENDER_FUNDS_ENABLED_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MAX_WITHDRAWING_LENDER_FUNDS_ENABLED_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_ADDING_LENDER_FUNDS_ENABLED_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_ADDING_LENDER_FUNDS_ENABLED_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_ASSET_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_ASSET_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_BORROWING_ENABLED_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_BORROWING_ENABLED_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_INTEREST_AT_JUNCTION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_INTEREST_AT_JUNCTION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_INTEREST_AT_MAX_UTILISATION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_INTEREST_AT_MAX_UTILISATION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_INTEREST_AT_ZERO_UTILISATION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_INTEREST_AT_ZERO_UTILISATION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_INTEREST_RATE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_INTEREST_RATE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_JUNCTION_UTILISATION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_JUNCTION_UTILISATION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_LIQUIDATION_FEE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_LIQUIDATION_FEE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_ORACLE_PRICE_ID_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_ORACLE_PRICE_ID_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_ORIGINATION_FEE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_ORIGINATION_FEE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_TOTAL_AMOUNT_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_TOTAL_AMOUNT_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_TOTAL_AMOUNT_USD_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_TOTAL_AMOUNT_USD_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_TOTAL_AVAILABLE_AMOUNT_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_TOTAL_AVAILABLE_AMOUNT_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_TOTAL_AVAILABLE_AMOUNT_USD_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_TOTAL_AVAILABLE_AMOUNT_USD_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_TOTAL_BORROWED_AMOUNT_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_TOTAL_BORROWED_AMOUNT_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_TOTAL_BORROWED_AMOUNT_USD_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_TOTAL_BORROWED_AMOUNT_USD_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_UTILISATION_RATE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_UTILISATION_RATE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_WITHDRAWING_LENDER_FUNDS_ENABLED_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_MIN_WITHDRAWING_LENDER_FUNDS_ENABLED_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_ADDING_LENDER_FUNDS_ENABLED_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_ADDING_LENDER_FUNDS_ENABLED_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_ASSET_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_ASSET_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_BORROWING_ENABLED_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_BORROWING_ENABLED_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_INTEREST_AT_JUNCTION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_INTEREST_AT_JUNCTION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_INTEREST_AT_MAX_UTILISATION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_INTEREST_AT_MAX_UTILISATION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_INTEREST_AT_ZERO_UTILISATION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_INTEREST_AT_ZERO_UTILISATION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_INTEREST_RATE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_INTEREST_RATE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_JUNCTION_UTILISATION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_JUNCTION_UTILISATION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_LIQUIDATION_FEE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_LIQUIDATION_FEE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_ORACLE_PRICE_ID_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_ORACLE_PRICE_ID_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_ORIGINATION_FEE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_ORIGINATION_FEE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_TOTAL_AMOUNT_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_TOTAL_AMOUNT_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_TOTAL_AMOUNT_USD_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_TOTAL_AMOUNT_USD_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_TOTAL_AVAILABLE_AMOUNT_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_TOTAL_AVAILABLE_AMOUNT_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_TOTAL_AVAILABLE_AMOUNT_USD_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_TOTAL_AVAILABLE_AMOUNT_USD_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_TOTAL_BORROWED_AMOUNT_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_TOTAL_BORROWED_AMOUNT_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_TOTAL_BORROWED_AMOUNT_USD_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_TOTAL_BORROWED_AMOUNT_USD_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_UTILISATION_RATE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_UTILISATION_RATE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_WITHDRAWING_LENDER_FUNDS_ENABLED_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_POPULATION_WITHDRAWING_LENDER_FUNDS_ENABLED_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_ADDING_LENDER_FUNDS_ENABLED_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_ADDING_LENDER_FUNDS_ENABLED_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_ASSET_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_ASSET_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_BORROWING_ENABLED_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_BORROWING_ENABLED_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_INTEREST_AT_JUNCTION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_INTEREST_AT_JUNCTION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_INTEREST_AT_MAX_UTILISATION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_INTEREST_AT_MAX_UTILISATION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_INTEREST_AT_ZERO_UTILISATION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_INTEREST_AT_ZERO_UTILISATION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_INTEREST_RATE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_INTEREST_RATE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_JUNCTION_UTILISATION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_JUNCTION_UTILISATION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_LIQUIDATION_FEE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_LIQUIDATION_FEE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_ORACLE_PRICE_ID_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_ORACLE_PRICE_ID_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_ORIGINATION_FEE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_ORIGINATION_FEE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_TOTAL_AMOUNT_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_TOTAL_AMOUNT_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_TOTAL_AMOUNT_USD_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_TOTAL_AMOUNT_USD_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_TOTAL_AVAILABLE_AMOUNT_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_TOTAL_AVAILABLE_AMOUNT_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_TOTAL_AVAILABLE_AMOUNT_USD_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_TOTAL_AVAILABLE_AMOUNT_USD_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_TOTAL_BORROWED_AMOUNT_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_TOTAL_BORROWED_AMOUNT_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_TOTAL_BORROWED_AMOUNT_USD_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_TOTAL_BORROWED_AMOUNT_USD_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_UTILISATION_RATE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_UTILISATION_RATE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_WITHDRAWING_LENDER_FUNDS_ENABLED_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_STDDEV_SAMPLE_WITHDRAWING_LENDER_FUNDS_ENABLED_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_ADDING_LENDER_FUNDS_ENABLED_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_ADDING_LENDER_FUNDS_ENABLED_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_ASSET_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_ASSET_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_BORROWING_ENABLED_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_BORROWING_ENABLED_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_INTEREST_AT_JUNCTION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_INTEREST_AT_JUNCTION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_INTEREST_AT_MAX_UTILISATION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_INTEREST_AT_MAX_UTILISATION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_INTEREST_AT_ZERO_UTILISATION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_INTEREST_AT_ZERO_UTILISATION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_INTEREST_RATE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_INTEREST_RATE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_JUNCTION_UTILISATION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_JUNCTION_UTILISATION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_LIQUIDATION_FEE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_LIQUIDATION_FEE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_ORACLE_PRICE_ID_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_ORACLE_PRICE_ID_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_ORIGINATION_FEE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_ORIGINATION_FEE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_TOTAL_AMOUNT_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_TOTAL_AMOUNT_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_TOTAL_AMOUNT_USD_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_TOTAL_AMOUNT_USD_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_TOTAL_AVAILABLE_AMOUNT_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_TOTAL_AVAILABLE_AMOUNT_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_TOTAL_AVAILABLE_AMOUNT_USD_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_TOTAL_AVAILABLE_AMOUNT_USD_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_TOTAL_BORROWED_AMOUNT_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_TOTAL_BORROWED_AMOUNT_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_TOTAL_BORROWED_AMOUNT_USD_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_TOTAL_BORROWED_AMOUNT_USD_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_UTILISATION_RATE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_UTILISATION_RATE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_WITHDRAWING_LENDER_FUNDS_ENABLED_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_SUM_WITHDRAWING_LENDER_FUNDS_ENABLED_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_ADDING_LENDER_FUNDS_ENABLED_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_ADDING_LENDER_FUNDS_ENABLED_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_ASSET_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_ASSET_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_BORROWING_ENABLED_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_BORROWING_ENABLED_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_INTEREST_AT_JUNCTION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_INTEREST_AT_JUNCTION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_INTEREST_AT_MAX_UTILISATION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_INTEREST_AT_MAX_UTILISATION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_INTEREST_AT_ZERO_UTILISATION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_INTEREST_AT_ZERO_UTILISATION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_INTEREST_RATE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_INTEREST_RATE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_JUNCTION_UTILISATION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_JUNCTION_UTILISATION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_LIQUIDATION_FEE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_LIQUIDATION_FEE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_ORACLE_PRICE_ID_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_ORACLE_PRICE_ID_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_ORIGINATION_FEE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_ORIGINATION_FEE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_TOTAL_AMOUNT_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_TOTAL_AMOUNT_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_TOTAL_AMOUNT_USD_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_TOTAL_AMOUNT_USD_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_TOTAL_AVAILABLE_AMOUNT_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_TOTAL_AVAILABLE_AMOUNT_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_TOTAL_AVAILABLE_AMOUNT_USD_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_TOTAL_AVAILABLE_AMOUNT_USD_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_TOTAL_BORROWED_AMOUNT_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_TOTAL_BORROWED_AMOUNT_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_TOTAL_BORROWED_AMOUNT_USD_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_TOTAL_BORROWED_AMOUNT_USD_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_UTILISATION_RATE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_UTILISATION_RATE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_WITHDRAWING_LENDER_FUNDS_ENABLED_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_POPULATION_WITHDRAWING_LENDER_FUNDS_ENABLED_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_ADDING_LENDER_FUNDS_ENABLED_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_ADDING_LENDER_FUNDS_ENABLED_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_ASSET_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_ASSET_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_BORROWING_ENABLED_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_BORROWING_ENABLED_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_INTEREST_AT_JUNCTION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_INTEREST_AT_JUNCTION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_INTEREST_AT_MAX_UTILISATION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_INTEREST_AT_MAX_UTILISATION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_INTEREST_AT_ZERO_UTILISATION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_INTEREST_AT_ZERO_UTILISATION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_INTEREST_RATE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_INTEREST_RATE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_JUNCTION_UTILISATION_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_JUNCTION_UTILISATION_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_LIQUIDATION_FEE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_LIQUIDATION_FEE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_ORACLE_PRICE_ID_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_ORACLE_PRICE_ID_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_ORIGINATION_FEE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_ORIGINATION_FEE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_TOTAL_AMOUNT_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_TOTAL_AMOUNT_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_TOTAL_AMOUNT_USD_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_TOTAL_AMOUNT_USD_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_TOTAL_AVAILABLE_AMOUNT_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_TOTAL_AVAILABLE_AMOUNT_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_TOTAL_AVAILABLE_AMOUNT_USD_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_TOTAL_AVAILABLE_AMOUNT_USD_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_TOTAL_BORROWED_AMOUNT_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_TOTAL_BORROWED_AMOUNT_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_TOTAL_BORROWED_AMOUNT_USD_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_TOTAL_BORROWED_AMOUNT_USD_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_UTILISATION_RATE_BPS_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_UTILISATION_RATE_BPS_DESC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_WITHDRAWING_LENDER_FUNDS_ENABLED_ASC'
  | 'LENDING_POOLS_BY_ORACLE_PRICE_ID_VARIANCE_SAMPLE_WITHDRAWING_LENDER_FUNDS_ENABLED_DESC'
  | 'NATURAL'
  | 'PRICE_ASC'
  | 'PRICE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'QUOTE_ASSET_ASC'
  | 'QUOTE_ASSET_DESC'
  | 'UPDATED_AT_ORACLE_TIMESTAMP_ASC'
  | 'UPDATED_AT_ORACLE_TIMESTAMP_DESC'
  | 'UPDATED_AT_STATECHAIN_BLOCK_ASC'
  | 'UPDATED_AT_STATECHAIN_BLOCK_DESC';

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']['output']>;
};

export type PendingDeposit = {
  __typename?: 'PendingDeposit';
  amount: Scalars['String']['output'];
  confirmations: Scalars['Int']['output'];
  txRef?: Maybe<Scalars['String']['output']>;
};

export type PendingDepositsInput = {
  address: Scalars['String']['input'];
  asset: Scalars['String']['input'];
  chain: Scalars['String']['input'];
};

export type Pool = Node & {
  __typename?: 'Pool';
  baseAsset: ChainflipAsset;
  baseLiquidityAmount: Scalars['BigFloat']['output'];
  buyPrice: Scalars['Float']['output'];
  id: Scalars['Int']['output'];
  liquidityFeeHundredthPips: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  openOrders?: Maybe<Scalars['JSON']['output']>;
  price: Scalars['Float']['output'];
  quoteAsset: ChainflipAsset;
  quoteLiquidityAmount: Scalars['BigFloat']['output'];
  rangeOrderPrice: Scalars['Float']['output'];
  sellPrice: Scalars['Float']['output'];
};

export type PoolAggregates = {
  __typename?: 'PoolAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<PoolAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<PoolDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<PoolMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<PoolMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<PoolStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<PoolStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<PoolSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<PoolVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<PoolVarianceSampleAggregates>;
};

export type PoolAverageAggregates = {
  __typename?: 'PoolAverageAggregates';
  /** Mean average of baseLiquidityAmount across the matching connection */
  baseLiquidityAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of buyPrice across the matching connection */
  buyPrice?: Maybe<Scalars['Float']['output']>;
  /** Mean average of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of liquidityFeeHundredthPips across the matching connection */
  liquidityFeeHundredthPips?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of price across the matching connection */
  price?: Maybe<Scalars['Float']['output']>;
  /** Mean average of quoteLiquidityAmount across the matching connection */
  quoteLiquidityAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of rangeOrderPrice across the matching connection */
  rangeOrderPrice?: Maybe<Scalars['Float']['output']>;
  /** Mean average of sellPrice across the matching connection */
  sellPrice?: Maybe<Scalars['Float']['output']>;
};

/** A condition to be used against `Pool` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PoolCondition = {
  /** Checks for equality with the object’s `baseAsset` field. */
  baseAsset?: InputMaybe<ChainflipAsset>;
  /** Checks for equality with the object’s `baseLiquidityAmount` field. */
  baseLiquidityAmount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `buyPrice` field. */
  buyPrice?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `liquidityFeeHundredthPips` field. */
  liquidityFeeHundredthPips?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `openOrders` field. */
  openOrders?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `price` field. */
  price?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `quoteAsset` field. */
  quoteAsset?: InputMaybe<ChainflipAsset>;
  /** Checks for equality with the object’s `quoteLiquidityAmount` field. */
  quoteLiquidityAmount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `rangeOrderPrice` field. */
  rangeOrderPrice?: InputMaybe<Scalars['Float']['input']>;
  /** Checks for equality with the object’s `sellPrice` field. */
  sellPrice?: InputMaybe<Scalars['Float']['input']>;
};

export type PoolDistinctCountAggregates = {
  __typename?: 'PoolDistinctCountAggregates';
  /** Distinct count of baseAsset across the matching connection */
  baseAsset?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of baseLiquidityAmount across the matching connection */
  baseLiquidityAmount?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of buyPrice across the matching connection */
  buyPrice?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of id across the matching connection */
  id?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of liquidityFeeHundredthPips across the matching connection */
  liquidityFeeHundredthPips?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of openOrders across the matching connection */
  openOrders?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of price across the matching connection */
  price?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of quoteAsset across the matching connection */
  quoteAsset?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of quoteLiquidityAmount across the matching connection */
  quoteLiquidityAmount?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of rangeOrderPrice across the matching connection */
  rangeOrderPrice?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of sellPrice across the matching connection */
  sellPrice?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `Pool` object types. All fields are combined with a logical ‘and.’ */
export type PoolFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PoolFilter>>;
  /** Filter by the object’s `baseAsset` field. */
  baseAsset?: InputMaybe<ChainflipAssetFilter>;
  /** Filter by the object’s `baseLiquidityAmount` field. */
  baseLiquidityAmount?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `buyPrice` field. */
  buyPrice?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `liquidityFeeHundredthPips` field. */
  liquidityFeeHundredthPips?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PoolFilter>;
  /** Filter by the object’s `openOrders` field. */
  openOrders?: InputMaybe<JsonFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PoolFilter>>;
  /** Filter by the object’s `price` field. */
  price?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `quoteAsset` field. */
  quoteAsset?: InputMaybe<ChainflipAssetFilter>;
  /** Filter by the object’s `quoteLiquidityAmount` field. */
  quoteLiquidityAmount?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `rangeOrderPrice` field. */
  rangeOrderPrice?: InputMaybe<FloatFilter>;
  /** Filter by the object’s `sellPrice` field. */
  sellPrice?: InputMaybe<FloatFilter>;
};

/** Grouping methods for `Pool` for usage during aggregation. */
export type PoolGroupBy =
  | 'BASE_ASSET'
  | 'BASE_LIQUIDITY_AMOUNT'
  | 'BUY_PRICE'
  | 'LIQUIDITY_FEE_HUNDREDTH_PIPS'
  | 'OPEN_ORDERS'
  | 'PRICE'
  | 'QUOTE_ASSET'
  | 'QUOTE_LIQUIDITY_AMOUNT'
  | 'RANGE_ORDER_PRICE'
  | 'SELL_PRICE';

export type PoolHavingAverageInput = {
  baseLiquidityAmount?: InputMaybe<HavingBigfloatFilter>;
  buyPrice?: InputMaybe<HavingFloatFilter>;
  id?: InputMaybe<HavingIntFilter>;
  liquidityFeeHundredthPips?: InputMaybe<HavingIntFilter>;
  price?: InputMaybe<HavingFloatFilter>;
  quoteLiquidityAmount?: InputMaybe<HavingBigfloatFilter>;
  rangeOrderPrice?: InputMaybe<HavingFloatFilter>;
  sellPrice?: InputMaybe<HavingFloatFilter>;
};

export type PoolHavingDistinctCountInput = {
  baseLiquidityAmount?: InputMaybe<HavingBigfloatFilter>;
  buyPrice?: InputMaybe<HavingFloatFilter>;
  id?: InputMaybe<HavingIntFilter>;
  liquidityFeeHundredthPips?: InputMaybe<HavingIntFilter>;
  price?: InputMaybe<HavingFloatFilter>;
  quoteLiquidityAmount?: InputMaybe<HavingBigfloatFilter>;
  rangeOrderPrice?: InputMaybe<HavingFloatFilter>;
  sellPrice?: InputMaybe<HavingFloatFilter>;
};

/** Conditions for `Pool` aggregates. */
export type PoolHavingInput = {
  AND?: InputMaybe<Array<PoolHavingInput>>;
  OR?: InputMaybe<Array<PoolHavingInput>>;
  average?: InputMaybe<PoolHavingAverageInput>;
  distinctCount?: InputMaybe<PoolHavingDistinctCountInput>;
  max?: InputMaybe<PoolHavingMaxInput>;
  min?: InputMaybe<PoolHavingMinInput>;
  stddevPopulation?: InputMaybe<PoolHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<PoolHavingStddevSampleInput>;
  sum?: InputMaybe<PoolHavingSumInput>;
  variancePopulation?: InputMaybe<PoolHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<PoolHavingVarianceSampleInput>;
};

export type PoolHavingMaxInput = {
  baseLiquidityAmount?: InputMaybe<HavingBigfloatFilter>;
  buyPrice?: InputMaybe<HavingFloatFilter>;
  id?: InputMaybe<HavingIntFilter>;
  liquidityFeeHundredthPips?: InputMaybe<HavingIntFilter>;
  price?: InputMaybe<HavingFloatFilter>;
  quoteLiquidityAmount?: InputMaybe<HavingBigfloatFilter>;
  rangeOrderPrice?: InputMaybe<HavingFloatFilter>;
  sellPrice?: InputMaybe<HavingFloatFilter>;
};

export type PoolHavingMinInput = {
  baseLiquidityAmount?: InputMaybe<HavingBigfloatFilter>;
  buyPrice?: InputMaybe<HavingFloatFilter>;
  id?: InputMaybe<HavingIntFilter>;
  liquidityFeeHundredthPips?: InputMaybe<HavingIntFilter>;
  price?: InputMaybe<HavingFloatFilter>;
  quoteLiquidityAmount?: InputMaybe<HavingBigfloatFilter>;
  rangeOrderPrice?: InputMaybe<HavingFloatFilter>;
  sellPrice?: InputMaybe<HavingFloatFilter>;
};

export type PoolHavingStddevPopulationInput = {
  baseLiquidityAmount?: InputMaybe<HavingBigfloatFilter>;
  buyPrice?: InputMaybe<HavingFloatFilter>;
  id?: InputMaybe<HavingIntFilter>;
  liquidityFeeHundredthPips?: InputMaybe<HavingIntFilter>;
  price?: InputMaybe<HavingFloatFilter>;
  quoteLiquidityAmount?: InputMaybe<HavingBigfloatFilter>;
  rangeOrderPrice?: InputMaybe<HavingFloatFilter>;
  sellPrice?: InputMaybe<HavingFloatFilter>;
};

export type PoolHavingStddevSampleInput = {
  baseLiquidityAmount?: InputMaybe<HavingBigfloatFilter>;
  buyPrice?: InputMaybe<HavingFloatFilter>;
  id?: InputMaybe<HavingIntFilter>;
  liquidityFeeHundredthPips?: InputMaybe<HavingIntFilter>;
  price?: InputMaybe<HavingFloatFilter>;
  quoteLiquidityAmount?: InputMaybe<HavingBigfloatFilter>;
  rangeOrderPrice?: InputMaybe<HavingFloatFilter>;
  sellPrice?: InputMaybe<HavingFloatFilter>;
};

export type PoolHavingSumInput = {
  baseLiquidityAmount?: InputMaybe<HavingBigfloatFilter>;
  buyPrice?: InputMaybe<HavingFloatFilter>;
  id?: InputMaybe<HavingIntFilter>;
  liquidityFeeHundredthPips?: InputMaybe<HavingIntFilter>;
  price?: InputMaybe<HavingFloatFilter>;
  quoteLiquidityAmount?: InputMaybe<HavingBigfloatFilter>;
  rangeOrderPrice?: InputMaybe<HavingFloatFilter>;
  sellPrice?: InputMaybe<HavingFloatFilter>;
};

export type PoolHavingVariancePopulationInput = {
  baseLiquidityAmount?: InputMaybe<HavingBigfloatFilter>;
  buyPrice?: InputMaybe<HavingFloatFilter>;
  id?: InputMaybe<HavingIntFilter>;
  liquidityFeeHundredthPips?: InputMaybe<HavingIntFilter>;
  price?: InputMaybe<HavingFloatFilter>;
  quoteLiquidityAmount?: InputMaybe<HavingBigfloatFilter>;
  rangeOrderPrice?: InputMaybe<HavingFloatFilter>;
  sellPrice?: InputMaybe<HavingFloatFilter>;
};

export type PoolHavingVarianceSampleInput = {
  baseLiquidityAmount?: InputMaybe<HavingBigfloatFilter>;
  buyPrice?: InputMaybe<HavingFloatFilter>;
  id?: InputMaybe<HavingIntFilter>;
  liquidityFeeHundredthPips?: InputMaybe<HavingIntFilter>;
  price?: InputMaybe<HavingFloatFilter>;
  quoteLiquidityAmount?: InputMaybe<HavingBigfloatFilter>;
  rangeOrderPrice?: InputMaybe<HavingFloatFilter>;
  sellPrice?: InputMaybe<HavingFloatFilter>;
};

export type PoolMaxAggregates = {
  __typename?: 'PoolMaxAggregates';
  /** Maximum of baseLiquidityAmount across the matching connection */
  baseLiquidityAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of buyPrice across the matching connection */
  buyPrice?: Maybe<Scalars['Float']['output']>;
  /** Maximum of id across the matching connection */
  id?: Maybe<Scalars['Int']['output']>;
  /** Maximum of liquidityFeeHundredthPips across the matching connection */
  liquidityFeeHundredthPips?: Maybe<Scalars['Int']['output']>;
  /** Maximum of price across the matching connection */
  price?: Maybe<Scalars['Float']['output']>;
  /** Maximum of quoteLiquidityAmount across the matching connection */
  quoteLiquidityAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of rangeOrderPrice across the matching connection */
  rangeOrderPrice?: Maybe<Scalars['Float']['output']>;
  /** Maximum of sellPrice across the matching connection */
  sellPrice?: Maybe<Scalars['Float']['output']>;
};

export type PoolMinAggregates = {
  __typename?: 'PoolMinAggregates';
  /** Minimum of baseLiquidityAmount across the matching connection */
  baseLiquidityAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of buyPrice across the matching connection */
  buyPrice?: Maybe<Scalars['Float']['output']>;
  /** Minimum of id across the matching connection */
  id?: Maybe<Scalars['Int']['output']>;
  /** Minimum of liquidityFeeHundredthPips across the matching connection */
  liquidityFeeHundredthPips?: Maybe<Scalars['Int']['output']>;
  /** Minimum of price across the matching connection */
  price?: Maybe<Scalars['Float']['output']>;
  /** Minimum of quoteLiquidityAmount across the matching connection */
  quoteLiquidityAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of rangeOrderPrice across the matching connection */
  rangeOrderPrice?: Maybe<Scalars['Float']['output']>;
  /** Minimum of sellPrice across the matching connection */
  sellPrice?: Maybe<Scalars['Float']['output']>;
};

export type PoolStddevPopulationAggregates = {
  __typename?: 'PoolStddevPopulationAggregates';
  /** Population standard deviation of baseLiquidityAmount across the matching connection */
  baseLiquidityAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of buyPrice across the matching connection */
  buyPrice?: Maybe<Scalars['Float']['output']>;
  /** Population standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of liquidityFeeHundredthPips across the matching connection */
  liquidityFeeHundredthPips?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of price across the matching connection */
  price?: Maybe<Scalars['Float']['output']>;
  /** Population standard deviation of quoteLiquidityAmount across the matching connection */
  quoteLiquidityAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of rangeOrderPrice across the matching connection */
  rangeOrderPrice?: Maybe<Scalars['Float']['output']>;
  /** Population standard deviation of sellPrice across the matching connection */
  sellPrice?: Maybe<Scalars['Float']['output']>;
};

export type PoolStddevSampleAggregates = {
  __typename?: 'PoolStddevSampleAggregates';
  /** Sample standard deviation of baseLiquidityAmount across the matching connection */
  baseLiquidityAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of buyPrice across the matching connection */
  buyPrice?: Maybe<Scalars['Float']['output']>;
  /** Sample standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of liquidityFeeHundredthPips across the matching connection */
  liquidityFeeHundredthPips?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of price across the matching connection */
  price?: Maybe<Scalars['Float']['output']>;
  /** Sample standard deviation of quoteLiquidityAmount across the matching connection */
  quoteLiquidityAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of rangeOrderPrice across the matching connection */
  rangeOrderPrice?: Maybe<Scalars['Float']['output']>;
  /** Sample standard deviation of sellPrice across the matching connection */
  sellPrice?: Maybe<Scalars['Float']['output']>;
};

export type PoolSumAggregates = {
  __typename?: 'PoolSumAggregates';
  /** Sum of baseLiquidityAmount across the matching connection */
  baseLiquidityAmount: Scalars['BigFloat']['output'];
  /** Sum of buyPrice across the matching connection */
  buyPrice: Scalars['Float']['output'];
  /** Sum of id across the matching connection */
  id: Scalars['BigInt']['output'];
  /** Sum of liquidityFeeHundredthPips across the matching connection */
  liquidityFeeHundredthPips: Scalars['BigInt']['output'];
  /** Sum of price across the matching connection */
  price: Scalars['Float']['output'];
  /** Sum of quoteLiquidityAmount across the matching connection */
  quoteLiquidityAmount: Scalars['BigFloat']['output'];
  /** Sum of rangeOrderPrice across the matching connection */
  rangeOrderPrice: Scalars['Float']['output'];
  /** Sum of sellPrice across the matching connection */
  sellPrice: Scalars['Float']['output'];
};

export type PoolVariancePopulationAggregates = {
  __typename?: 'PoolVariancePopulationAggregates';
  /** Population variance of baseLiquidityAmount across the matching connection */
  baseLiquidityAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of buyPrice across the matching connection */
  buyPrice?: Maybe<Scalars['Float']['output']>;
  /** Population variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of liquidityFeeHundredthPips across the matching connection */
  liquidityFeeHundredthPips?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of price across the matching connection */
  price?: Maybe<Scalars['Float']['output']>;
  /** Population variance of quoteLiquidityAmount across the matching connection */
  quoteLiquidityAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of rangeOrderPrice across the matching connection */
  rangeOrderPrice?: Maybe<Scalars['Float']['output']>;
  /** Population variance of sellPrice across the matching connection */
  sellPrice?: Maybe<Scalars['Float']['output']>;
};

export type PoolVarianceSampleAggregates = {
  __typename?: 'PoolVarianceSampleAggregates';
  /** Sample variance of baseLiquidityAmount across the matching connection */
  baseLiquidityAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of buyPrice across the matching connection */
  buyPrice?: Maybe<Scalars['Float']['output']>;
  /** Sample variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of liquidityFeeHundredthPips across the matching connection */
  liquidityFeeHundredthPips?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of price across the matching connection */
  price?: Maybe<Scalars['Float']['output']>;
  /** Sample variance of quoteLiquidityAmount across the matching connection */
  quoteLiquidityAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of rangeOrderPrice across the matching connection */
  rangeOrderPrice?: Maybe<Scalars['Float']['output']>;
  /** Sample variance of sellPrice across the matching connection */
  sellPrice?: Maybe<Scalars['Float']['output']>;
};

/** A connection to a list of `Pool` values. */
export type PoolsConnection = {
  __typename?: 'PoolsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<PoolAggregates>;
  /** A list of edges which contains the `Pool` and cursor to aid in pagination. */
  edges: Array<PoolsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<PoolAggregates>>;
  /** A list of `Pool` objects. */
  nodes: Array<Pool>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Pool` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `Pool` values. */
export type PoolsConnectionGroupedAggregatesArgs = {
  groupBy: Array<PoolGroupBy>;
  having?: InputMaybe<PoolHavingInput>;
};

/** A `Pool` edge in the connection. */
export type PoolsEdge = {
  __typename?: 'PoolsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Pool` at the end of the edge. */
  node: Pool;
};

/** Methods to use when ordering `Pool`. */
export type PoolsOrderBy =
  | 'BASE_ASSET_ASC'
  | 'BASE_ASSET_DESC'
  | 'BASE_LIQUIDITY_AMOUNT_ASC'
  | 'BASE_LIQUIDITY_AMOUNT_DESC'
  | 'BUY_PRICE_ASC'
  | 'BUY_PRICE_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'LIQUIDITY_FEE_HUNDREDTH_PIPS_ASC'
  | 'LIQUIDITY_FEE_HUNDREDTH_PIPS_DESC'
  | 'NATURAL'
  | 'OPEN_ORDERS_ASC'
  | 'OPEN_ORDERS_DESC'
  | 'PRICE_ASC'
  | 'PRICE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'QUOTE_ASSET_ASC'
  | 'QUOTE_ASSET_DESC'
  | 'QUOTE_LIQUIDITY_AMOUNT_ASC'
  | 'QUOTE_LIQUIDITY_AMOUNT_DESC'
  | 'RANGE_ORDER_PRICE_ASC'
  | 'RANGE_ORDER_PRICE_DESC'
  | 'SELL_PRICE_ASC'
  | 'SELL_PRICE_DESC';

export type PriceAsset =
  | 'Btc'
  | 'Eth'
  | 'Fine'
  | 'Sol'
  | 'Usd'
  | 'Usdc'
  | 'Usdt';

/** A filter to be used against PriceAsset fields. All fields are combined with a logical ‘and.’ */
export type PriceAssetFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<PriceAsset>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<PriceAsset>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<PriceAsset>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<PriceAsset>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<PriceAsset>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<PriceAsset>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<PriceAsset>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<PriceAsset>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<PriceAsset>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<PriceAsset>>;
};

export type PriceQueryInput = {
  address: Scalars['String']['input'];
  chainId: Scalars['String']['input'];
  date?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The root query type which gives access points into the data universe. */
export type Query = Node & {
  __typename?: 'Query';
  /** Reads a single `_PrismaMigration` using its globally unique `ID`. */
  _prismaMigration?: Maybe<_PrismaMigration>;
  _prismaMigrationById?: Maybe<_PrismaMigration>;
  /** Reads a single `AcalaEvmExecuted` using its globally unique `ID`. */
  acalaEvmExecuted?: Maybe<AcalaEvmExecuted>;
  acalaEvmExecutedByEventId?: Maybe<AcalaEvmExecuted>;
  /** Reads a single `AcalaEvmExecutedFailed` using its globally unique `ID`. */
  acalaEvmExecutedFailed?: Maybe<AcalaEvmExecutedFailed>;
  acalaEvmExecutedFailedByEventId?: Maybe<AcalaEvmExecutedFailed>;
  /** Reads a single `AcalaEvmExecutedFailedLog` using its globally unique `ID`. */
  acalaEvmExecutedFailedLog?: Maybe<AcalaEvmExecutedFailedLog>;
  acalaEvmExecutedFailedLogById?: Maybe<AcalaEvmExecutedFailedLog>;
  /** Reads a single `AcalaEvmExecutedLog` using its globally unique `ID`. */
  acalaEvmExecutedLog?: Maybe<AcalaEvmExecutedLog>;
  acalaEvmExecutedLogById?: Maybe<AcalaEvmExecutedLog>;
  /** Reads a single `Account` using its globally unique `ID`. */
  account?: Maybe<Account>;
  accountByIdHex?: Maybe<Account>;
  accountByIdSs58?: Maybe<Account>;
  /** Reads a single `AccountLink` using its globally unique `ID`. */
  accountLink?: Maybe<AccountLink>;
  accountLinkByAccountIdSs58AndEthereumAddress?: Maybe<AccountLink>;
  accountLinkById?: Maybe<AccountLink>;
  /** Reads and enables pagination through a set of `AcalaEvmExecutedFailedLog`. */
  allAcalaEvmExecutedFailedLogs?: Maybe<AcalaEvmExecutedFailedLogsConnection>;
  /** Reads and enables pagination through a set of `AcalaEvmExecutedFailed`. */
  allAcalaEvmExecutedFaileds?: Maybe<AcalaEvmExecutedFailedsConnection>;
  /** Reads and enables pagination through a set of `AcalaEvmExecutedLog`. */
  allAcalaEvmExecutedLogs?: Maybe<AcalaEvmExecutedLogsConnection>;
  /** Reads and enables pagination through a set of `AcalaEvmExecuted`. */
  allAcalaEvmExecuteds?: Maybe<AcalaEvmExecutedsConnection>;
  /** Reads and enables pagination through a set of `AccountLink`. */
  allAccountLinks?: Maybe<AccountLinksConnection>;
  /** Reads and enables pagination through a set of `Account`. */
  allAccounts?: Maybe<AccountsConnection>;
  /** Reads and enables pagination through a set of `Auction`. */
  allAuctions?: Maybe<AuctionsConnection>;
  /** Reads and enables pagination through a set of `Banner`. */
  allBanners?: Maybe<BannersConnection>;
  /** Reads and enables pagination through a set of `Block`. */
  allBlocks?: Maybe<BlocksConnection>;
  /** Reads and enables pagination through a set of `BoostBalance`. */
  allBoostBalances?: Maybe<BoostBalancesConnection>;
  /** Reads and enables pagination through a set of `BoostDelayChainflipBlock`. */
  allBoostDelayChainflipBlocks?: Maybe<BoostDelayChainflipBlocksConnection>;
  /** Reads and enables pagination through a set of `BoostPool`. */
  allBoostPools?: Maybe<BoostPoolsConnection>;
  /** Reads and enables pagination through a set of `BoostSafeMode`. */
  allBoostSafeModes?: Maybe<BoostSafeModesConnection>;
  /** Reads and enables pagination through a set of `BrokerAccount`. */
  allBrokerAccounts?: Maybe<BrokerAccountsConnection>;
  /** Reads and enables pagination through a set of `Call`. */
  allCalls?: Maybe<CallsConnection>;
  /** Reads and enables pagination through a set of `Circulation`. */
  allCirculations?: Maybe<CirculationsConnection>;
  /** Reads and enables pagination through a set of `ContractsContractEmitted`. */
  allContractsContractEmitteds?: Maybe<ContractsContractEmittedsConnection>;
  /** Reads and enables pagination through a set of `Delegation`. */
  allDelegations?: Maybe<DelegationsConnection>;
  /** Reads and enables pagination through a set of `DepositBalance`. */
  allDepositBalances?: Maybe<DepositBalancesConnection>;
  /** Reads and enables pagination through a set of `EnvironmentAddress`. */
  allEnvironmentAddresses?: Maybe<EnvironmentAddressesConnection>;
  /** Reads and enables pagination through a set of `Event`. */
  allEvents?: Maybe<EventsConnection>;
  /** Reads and enables pagination through a set of `Extrinsic`. */
  allExtrinsics?: Maybe<ExtrinsicsConnection>;
  /** Reads and enables pagination through a set of `FlipSupply`. */
  allFlipSupplies?: Maybe<FlipSuppliesConnection>;
  /** Reads and enables pagination through a set of `FrontierEthereumTransaction`. */
  allFrontierEthereumTransactions?: Maybe<FrontierEthereumTransactionsConnection>;
  /** Reads and enables pagination through a set of `FrontierEvmLog`. */
  allFrontierEvmLogs?: Maybe<FrontierEvmLogsConnection>;
  /** Reads and enables pagination through a set of `GearMessageEnqueued`. */
  allGearMessageEnqueueds?: Maybe<GearMessageEnqueuedsConnection>;
  /** Reads and enables pagination through a set of `GearUserMessageSent`. */
  allGearUserMessageSents?: Maybe<GearUserMessageSentsConnection>;
  /** Reads and enables pagination through a set of `LendingGlobalConfig`. */
  allLendingGlobalConfigs?: Maybe<LendingGlobalConfigsConnection>;
  /** Reads and enables pagination through a set of `LendingPool`. */
  allLendingPools?: Maybe<LendingPoolsConnection>;
  /** Reads and enables pagination through a set of `LendingSafeMode`. */
  allLendingSafeModes?: Maybe<LendingSafeModesConnection>;
  /** Reads and enables pagination through a set of `Loan`. */
  allLoans?: Maybe<LoansConnection>;
  /** Reads and enables pagination through a set of `LpAccount`. */
  allLpAccounts?: Maybe<LpAccountsConnection>;
  /** Reads and enables pagination through a set of `LpCollateralBalance`. */
  allLpCollateralBalances?: Maybe<LpCollateralBalancesConnection>;
  /** Reads and enables pagination through a set of `LpLendingBalance`. */
  allLpLendingBalances?: Maybe<LpLendingBalancesConnection>;
  /** Reads and enables pagination through a set of `LpLoanAccount`. */
  allLpLoanAccounts?: Maybe<LpLoanAccountsConnection>;
  /** Reads and enables pagination through a set of `LpTotalBalance`. */
  allLpTotalBalances?: Maybe<LpTotalBalancesConnection>;
  /** Reads and enables pagination through a set of `Metadatum`. */
  allMetadata?: Maybe<MetadataConnection>;
  /** Reads and enables pagination through a set of `Migration`. */
  allMigrations?: Maybe<MigrationsConnection>;
  /** Reads and enables pagination through a set of `OperatorValidator`. */
  allOperatorValidators?: Maybe<OperatorValidatorsConnection>;
  /** Reads and enables pagination through a set of `Operator`. */
  allOperators?: Maybe<OperatorsConnection>;
  /** Reads and enables pagination through a set of `OraclePrice`. */
  allOraclePrices?: Maybe<OraclePricesConnection>;
  /** Reads and enables pagination through a set of `Pool`. */
  allPools?: Maybe<PoolsConnection>;
  /** Reads and enables pagination through a set of `_PrismaMigration`. */
  allPrismaMigrations?: Maybe<_PrismaMigrationsConnection>;
  /** Reads and enables pagination through a set of `SupportedAsset`. */
  allSupportedAssets?: Maybe<SupportedAssetsConnection>;
  /** Reads and enables pagination through a set of `TokenPrice`. */
  allTokenPrices?: Maybe<TokenPricesConnection>;
  /** Reads and enables pagination through a set of `TradingStrategy`. */
  allTradingStrategies?: Maybe<TradingStrategiesConnection>;
  /** Reads and enables pagination through a set of `TradingStrategyLimit`. */
  allTradingStrategyLimits?: Maybe<TradingStrategyLimitsConnection>;
  /** Reads and enables pagination through a set of `Unregistered`. */
  allUnregistereds?: Maybe<UnregisteredsConnection>;
  /** Reads and enables pagination through a set of `Validator`. */
  allValidators?: Maybe<ValidatorsConnection>;
  /** Reads and enables pagination through a set of `Warning`. */
  allWarnings?: Maybe<WarningsConnection>;
  /** Reads a single `Auction` using its globally unique `ID`. */
  auction?: Maybe<Auction>;
  auctionById?: Maybe<Auction>;
  /** Reads a single `Banner` using its globally unique `ID`. */
  banner?: Maybe<Banner>;
  bannerByApp?: Maybe<Banner>;
  /** Reads a single `Block` using its globally unique `ID`. */
  block?: Maybe<Block>;
  blockById?: Maybe<Block>;
  boostBalanceByPoolIdAndLpIdSs58?: Maybe<BoostBalance>;
  /** Reads a single `BoostDelayChainflipBlock` using its globally unique `ID`. */
  boostDelayChainflipBlock?: Maybe<BoostDelayChainflipBlock>;
  boostDelayChainflipBlockByChain?: Maybe<BoostDelayChainflipBlock>;
  boostDelayChainflipBlockById?: Maybe<BoostDelayChainflipBlock>;
  /** Reads a single `BoostPool` using its globally unique `ID`. */
  boostPool?: Maybe<BoostPool>;
  boostPoolByAssetAndFeeTierPips?: Maybe<BoostPool>;
  boostPoolById?: Maybe<BoostPool>;
  /** Reads a single `BoostSafeMode` using its globally unique `ID`. */
  boostSafeMode?: Maybe<BoostSafeMode>;
  boostSafeModeByChain?: Maybe<BoostSafeMode>;
  boostSafeModeById?: Maybe<BoostSafeMode>;
  /** Reads a single `BrokerAccount` using its globally unique `ID`. */
  brokerAccount?: Maybe<BrokerAccount>;
  brokerAccountByIdSs58?: Maybe<BrokerAccount>;
  /** Reads a single `Call` using its globally unique `ID`. */
  call?: Maybe<Call>;
  callById?: Maybe<Call>;
  /** Reads a single `Circulation` using its globally unique `ID`. */
  circulation?: Maybe<Circulation>;
  circulationById?: Maybe<Circulation>;
  /** Reads a single `ContractsContractEmitted` using its globally unique `ID`. */
  contractsContractEmitted?: Maybe<ContractsContractEmitted>;
  contractsContractEmittedByEventId?: Maybe<ContractsContractEmitted>;
  delegationByDelegatorIdSs58AndOperatorIdSs58?: Maybe<Delegation>;
  depositBalanceByChainAndAssetAndLpIdSs58?: Maybe<DepositBalance>;
  /** Reads a single `EnvironmentAddress` using its globally unique `ID`. */
  environmentAddress?: Maybe<EnvironmentAddress>;
  environmentAddressById?: Maybe<EnvironmentAddress>;
  /** Reads a single `Event` using its globally unique `ID`. */
  event?: Maybe<Event>;
  eventById?: Maybe<Event>;
  /** Reads a single `Extrinsic` using its globally unique `ID`. */
  extrinsic?: Maybe<Extrinsic>;
  extrinsicById?: Maybe<Extrinsic>;
  /** Reads a single `FlipSupply` using its globally unique `ID`. */
  flipSupply?: Maybe<FlipSupply>;
  flipSupplyById?: Maybe<FlipSupply>;
  /** Reads a single `FrontierEthereumTransaction` using its globally unique `ID`. */
  frontierEthereumTransaction?: Maybe<FrontierEthereumTransaction>;
  frontierEthereumTransactionByCallId?: Maybe<FrontierEthereumTransaction>;
  /** Reads a single `FrontierEvmLog` using its globally unique `ID`. */
  frontierEvmLog?: Maybe<FrontierEvmLog>;
  frontierEvmLogByEventId?: Maybe<FrontierEvmLog>;
  /** Reads a single `GearMessageEnqueued` using its globally unique `ID`. */
  gearMessageEnqueued?: Maybe<GearMessageEnqueued>;
  gearMessageEnqueuedByEventId?: Maybe<GearMessageEnqueued>;
  /** Reads a single `GearUserMessageSent` using its globally unique `ID`. */
  gearUserMessageSent?: Maybe<GearUserMessageSent>;
  gearUserMessageSentByEventId?: Maybe<GearUserMessageSent>;
  getTokenPrices: Array<TokenPrice>;
  /** Reads a single `LendingGlobalConfig` using its globally unique `ID`. */
  lendingGlobalConfig?: Maybe<LendingGlobalConfig>;
  lendingGlobalConfigById?: Maybe<LendingGlobalConfig>;
  lendingPoolByAsset?: Maybe<LendingPool>;
  /** Reads a single `LendingSafeMode` using its globally unique `ID`. */
  lendingSafeMode?: Maybe<LendingSafeMode>;
  lendingSafeModeById?: Maybe<LendingSafeMode>;
  /** Reads a single `Loan` using its globally unique `ID`. */
  loan?: Maybe<Loan>;
  loanById?: Maybe<Loan>;
  /** Reads a single `LpAccount` using its globally unique `ID`. */
  lpAccount?: Maybe<LpAccount>;
  lpAccountByIdSs58?: Maybe<LpAccount>;
  lpLendingBalanceByAssetAndLpIdSs58?: Maybe<LpLendingBalance>;
  lpTotalBalanceByChainAndAssetAndLpIdSs58?: Maybe<LpTotalBalance>;
  /** Reads a single `Metadatum` using its globally unique `ID`. */
  metadatum?: Maybe<Metadatum>;
  metadatumById?: Maybe<Metadatum>;
  /** Reads a single `Migration` using its globally unique `ID`. */
  migration?: Maybe<Migration>;
  migrationById?: Maybe<Migration>;
  migrationByName?: Maybe<Migration>;
  /** Fetches an object given its globally unique `ID`. */
  node?: Maybe<Node>;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Operator` using its globally unique `ID`. */
  operator?: Maybe<Operator>;
  operatorByIdSs58?: Maybe<Operator>;
  /** Reads a single `OperatorValidator` using its globally unique `ID`. */
  operatorValidator?: Maybe<OperatorValidator>;
  operatorValidatorById?: Maybe<OperatorValidator>;
  /** Reads a single `OraclePrice` using its globally unique `ID`. */
  oraclePrice?: Maybe<OraclePrice>;
  oraclePriceByBaseAssetAndQuoteAsset?: Maybe<OraclePrice>;
  oraclePriceById?: Maybe<OraclePrice>;
  pendingDeposits: Array<Maybe<PendingDeposit>>;
  /** Reads a single `Pool` using its globally unique `ID`. */
  pool?: Maybe<Pool>;
  poolById?: Maybe<Pool>;
  poolByQuoteAssetAndBaseAsset?: Maybe<Pool>;
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
  supportedAssetById?: Maybe<SupportedAsset>;
  /** Reads a single `TokenPrice` using its globally unique `ID`. */
  tokenPrice?: Maybe<TokenPrice>;
  tokenPriceByChainIdAndAddress?: Maybe<TokenPrice>;
  tradingStrategyByStrategyAccountIdSs58?: Maybe<TradingStrategy>;
  /** Reads a single `TradingStrategyLimit` using its globally unique `ID`. */
  tradingStrategyLimit?: Maybe<TradingStrategyLimit>;
  tradingStrategyLimitByAsset?: Maybe<TradingStrategyLimit>;
  tradingStrategyLimitById?: Maybe<TradingStrategyLimit>;
  /** Reads a single `Unregistered` using its globally unique `ID`. */
  unregistered?: Maybe<Unregistered>;
  unregisteredByIdSs58?: Maybe<Unregistered>;
  /** Reads a single `Validator` using its globally unique `ID`. */
  validator?: Maybe<Validator>;
  validatorByIdSs58?: Maybe<Validator>;
};


/** The root query type which gives access points into the data universe. */
export type Query_PrismaMigrationArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type Query_PrismaMigrationByIdArgs = {
  id: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAcalaEvmExecutedArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAcalaEvmExecutedByEventIdArgs = {
  eventId: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAcalaEvmExecutedFailedArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAcalaEvmExecutedFailedByEventIdArgs = {
  eventId: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAcalaEvmExecutedFailedLogArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAcalaEvmExecutedFailedLogByIdArgs = {
  id: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAcalaEvmExecutedLogArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAcalaEvmExecutedLogByIdArgs = {
  id: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAccountArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAccountByIdHexArgs = {
  idHex: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAccountByIdSs58Args = {
  idSs58: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAccountLinkArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAccountLinkByAccountIdSs58AndEthereumAddressArgs = {
  accountIdSs58: Scalars['String']['input'];
  ethereumAddress: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAccountLinkByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAllAcalaEvmExecutedFailedLogsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AcalaEvmExecutedFailedLogCondition>;
  filter?: InputMaybe<AcalaEvmExecutedFailedLogFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AcalaEvmExecutedFailedLogsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllAcalaEvmExecutedFailedsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AcalaEvmExecutedFailedCondition>;
  filter?: InputMaybe<AcalaEvmExecutedFailedFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AcalaEvmExecutedFailedsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllAcalaEvmExecutedLogsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AcalaEvmExecutedLogCondition>;
  filter?: InputMaybe<AcalaEvmExecutedLogFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AcalaEvmExecutedLogsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllAcalaEvmExecutedsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AcalaEvmExecutedCondition>;
  filter?: InputMaybe<AcalaEvmExecutedFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AcalaEvmExecutedsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllAccountLinksArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AccountLinkCondition>;
  filter?: InputMaybe<AccountLinkFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountLinksOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllAccountsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AccountCondition>;
  filter?: InputMaybe<AccountFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AccountsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllAuctionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AuctionCondition>;
  filter?: InputMaybe<AuctionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuctionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllBannersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<BannerCondition>;
  filter?: InputMaybe<BannerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BannersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllBlocksArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<BlockCondition>;
  filter?: InputMaybe<BlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BlocksOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllBoostBalancesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<BoostBalanceCondition>;
  filter?: InputMaybe<BoostBalanceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BoostBalancesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllBoostDelayChainflipBlocksArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<BoostDelayChainflipBlockCondition>;
  filter?: InputMaybe<BoostDelayChainflipBlockFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BoostDelayChainflipBlocksOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllBoostPoolsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<BoostPoolCondition>;
  filter?: InputMaybe<BoostPoolFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BoostPoolsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllBoostSafeModesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<BoostSafeModeCondition>;
  filter?: InputMaybe<BoostSafeModeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BoostSafeModesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllBrokerAccountsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<BrokerAccountCondition>;
  filter?: InputMaybe<BrokerAccountFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BrokerAccountsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllCallsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CallCondition>;
  filter?: InputMaybe<CallFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CallsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllCirculationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CirculationCondition>;
  filter?: InputMaybe<CirculationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CirculationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllContractsContractEmittedsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ContractsContractEmittedCondition>;
  filter?: InputMaybe<ContractsContractEmittedFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ContractsContractEmittedsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllDelegationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DelegationCondition>;
  filter?: InputMaybe<DelegationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DelegationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllDepositBalancesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DepositBalanceCondition>;
  filter?: InputMaybe<DepositBalanceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DepositBalancesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllEnvironmentAddressesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EnvironmentAddressCondition>;
  filter?: InputMaybe<EnvironmentAddressFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EnvironmentAddressesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllEventsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<EventCondition>;
  filter?: InputMaybe<EventFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllExtrinsicsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ExtrinsicCondition>;
  filter?: InputMaybe<ExtrinsicFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ExtrinsicsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllFlipSuppliesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FlipSupplyCondition>;
  filter?: InputMaybe<FlipSupplyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FlipSuppliesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllFrontierEthereumTransactionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FrontierEthereumTransactionCondition>;
  filter?: InputMaybe<FrontierEthereumTransactionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FrontierEthereumTransactionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllFrontierEvmLogsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FrontierEvmLogCondition>;
  filter?: InputMaybe<FrontierEvmLogFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FrontierEvmLogsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllGearMessageEnqueuedsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GearMessageEnqueuedCondition>;
  filter?: InputMaybe<GearMessageEnqueuedFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GearMessageEnqueuedsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllGearUserMessageSentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GearUserMessageSentCondition>;
  filter?: InputMaybe<GearUserMessageSentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GearUserMessageSentsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllLendingGlobalConfigsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LendingGlobalConfigCondition>;
  filter?: InputMaybe<LendingGlobalConfigFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LendingGlobalConfigsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllLendingPoolsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LendingPoolCondition>;
  filter?: InputMaybe<LendingPoolFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LendingPoolsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllLendingSafeModesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LendingSafeModeCondition>;
  filter?: InputMaybe<LendingSafeModeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LendingSafeModesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllLoansArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LoanCondition>;
  filter?: InputMaybe<LoanFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LoansOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllLpAccountsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LpAccountCondition>;
  filter?: InputMaybe<LpAccountFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LpAccountsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllLpCollateralBalancesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LpCollateralBalanceCondition>;
  filter?: InputMaybe<LpCollateralBalanceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LpCollateralBalancesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllLpLendingBalancesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LpLendingBalanceCondition>;
  filter?: InputMaybe<LpLendingBalanceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LpLendingBalancesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllLpLoanAccountsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LpLoanAccountCondition>;
  filter?: InputMaybe<LpLoanAccountFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LpLoanAccountsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllLpTotalBalancesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<LpTotalBalanceCondition>;
  filter?: InputMaybe<LpTotalBalanceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LpTotalBalancesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllMetadataArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MetadatumCondition>;
  filter?: InputMaybe<MetadatumFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MetadataOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllMigrationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<MigrationCondition>;
  filter?: InputMaybe<MigrationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<MigrationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllOperatorValidatorsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OperatorValidatorCondition>;
  filter?: InputMaybe<OperatorValidatorFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OperatorValidatorsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllOperatorsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OperatorCondition>;
  filter?: InputMaybe<OperatorFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OperatorsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllOraclePricesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OraclePriceCondition>;
  filter?: InputMaybe<OraclePriceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OraclePricesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllPoolsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PoolCondition>;
  filter?: InputMaybe<PoolFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PoolsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllPrismaMigrationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<_PrismaMigrationCondition>;
  filter?: InputMaybe<_PrismaMigrationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<_PrismaMigrationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllSupportedAssetsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SupportedAssetCondition>;
  filter?: InputMaybe<SupportedAssetFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SupportedAssetsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllTokenPricesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TokenPriceCondition>;
  filter?: InputMaybe<TokenPriceFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TokenPricesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllTradingStrategiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TradingStrategyCondition>;
  filter?: InputMaybe<TradingStrategyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TradingStrategiesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllTradingStrategyLimitsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TradingStrategyLimitCondition>;
  filter?: InputMaybe<TradingStrategyLimitFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TradingStrategyLimitsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllUnregisteredsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UnregisteredCondition>;
  filter?: InputMaybe<UnregisteredFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UnregisteredsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllValidatorsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ValidatorCondition>;
  filter?: InputMaybe<ValidatorFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ValidatorsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllWarningsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<WarningCondition>;
  filter?: InputMaybe<WarningFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<WarningsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAuctionArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAuctionByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBannerArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBannerByAppArgs = {
  app: App;
};


/** The root query type which gives access points into the data universe. */
export type QueryBlockArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBlockByIdArgs = {
  id: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBoostBalanceByPoolIdAndLpIdSs58Args = {
  lpIdSs58: Scalars['String']['input'];
  poolId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBoostDelayChainflipBlockArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBoostDelayChainflipBlockByChainArgs = {
  chain: ChainflipChain;
};


/** The root query type which gives access points into the data universe. */
export type QueryBoostDelayChainflipBlockByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBoostPoolArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBoostPoolByAssetAndFeeTierPipsArgs = {
  asset: ChainflipAsset;
  feeTierPips: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBoostPoolByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBoostSafeModeArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBoostSafeModeByChainArgs = {
  chain: ChainflipChain;
};


/** The root query type which gives access points into the data universe. */
export type QueryBoostSafeModeByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBrokerAccountArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBrokerAccountByIdSs58Args = {
  idSs58: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCallArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCallByIdArgs = {
  id: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCirculationArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCirculationByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryContractsContractEmittedArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryContractsContractEmittedByEventIdArgs = {
  eventId: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDelegationByDelegatorIdSs58AndOperatorIdSs58Args = {
  delegatorIdSs58: Scalars['String']['input'];
  operatorIdSs58: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDepositBalanceByChainAndAssetAndLpIdSs58Args = {
  asset: ChainflipAsset;
  chain: ChainflipChain;
  lpIdSs58: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEnvironmentAddressArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEnvironmentAddressByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEventByIdArgs = {
  id: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryExtrinsicArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryExtrinsicByIdArgs = {
  id: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFlipSupplyArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFlipSupplyByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFrontierEthereumTransactionArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFrontierEthereumTransactionByCallIdArgs = {
  callId: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFrontierEvmLogArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFrontierEvmLogByEventIdArgs = {
  eventId: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGearMessageEnqueuedArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGearMessageEnqueuedByEventIdArgs = {
  eventId: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGearUserMessageSentArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGearUserMessageSentByEventIdArgs = {
  eventId: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGetTokenPricesArgs = {
  input: Array<PriceQueryInput>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLendingGlobalConfigArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLendingGlobalConfigByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLendingPoolByAssetArgs = {
  asset: ChainflipAsset;
};


/** The root query type which gives access points into the data universe. */
export type QueryLendingSafeModeArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLendingSafeModeByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLoanArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLoanByIdArgs = {
  id: Scalars['BigInt']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLpAccountArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLpAccountByIdSs58Args = {
  idSs58: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLpLendingBalanceByAssetAndLpIdSs58Args = {
  asset: ChainflipAsset;
  lpIdSs58: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLpTotalBalanceByChainAndAssetAndLpIdSs58Args = {
  asset: ChainflipAsset;
  chain: ChainflipChain;
  lpIdSs58: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMetadatumArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMetadatumByIdArgs = {
  id: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMigrationArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMigrationByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryMigrationByNameArgs = {
  name: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNodeArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOperatorArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOperatorByIdSs58Args = {
  idSs58: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOperatorValidatorArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOperatorValidatorByIdArgs = {
  id: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOraclePriceArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOraclePriceByBaseAssetAndQuoteAssetArgs = {
  baseAsset: PriceAsset;
  quoteAsset: PriceAsset;
};


/** The root query type which gives access points into the data universe. */
export type QueryOraclePriceByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPendingDepositsArgs = {
  input: PendingDepositsInput;
};


/** The root query type which gives access points into the data universe. */
export type QueryPoolArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPoolByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPoolByQuoteAssetAndBaseAssetArgs = {
  baseAsset: ChainflipAsset;
  quoteAsset: ChainflipAsset;
};


/** The root query type which gives access points into the data universe. */
export type QuerySupportedAssetByIdArgs = {
  id: ChainflipAsset;
};


/** The root query type which gives access points into the data universe. */
export type QueryTokenPriceArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTokenPriceByChainIdAndAddressArgs = {
  address: Scalars['String']['input'];
  chainId: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTradingStrategyByStrategyAccountIdSs58Args = {
  strategyAccountIdSs58: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTradingStrategyLimitArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTradingStrategyLimitByAssetArgs = {
  asset: ChainflipAsset;
};


/** The root query type which gives access points into the data universe. */
export type QueryTradingStrategyLimitByIdArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUnregisteredArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUnregisteredByIdSs58Args = {
  idSs58: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryValidatorArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryValidatorByIdSs58Args = {
  idSs58: Scalars['String']['input'];
};

/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */
export type StringFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Ends with the specified string (case-sensitive). */
  endsWith?: InputMaybe<Scalars['String']['input']>;
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['String']['input']>;
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Included in the specified list (case-insensitive). */
  inInsensitive?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Contains the specified string (case-sensitive). */
  includes?: InputMaybe<Scalars['String']['input']>;
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['String']['input']>;
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: InputMaybe<Scalars['String']['input']>;
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: InputMaybe<Scalars['String']['input']>;
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: InputMaybe<Scalars['String']['input']>;
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: InputMaybe<Scalars['String']['input']>;
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: InputMaybe<Scalars['String']['input']>;
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Starts with the specified string (case-sensitive). */
  startsWith?: InputMaybe<Scalars['String']['input']>;
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
};

export type SupportedAsset = {
  __typename?: 'SupportedAsset';
  id: ChainflipAsset;
};

export type SupportedAssetAggregates = {
  __typename?: 'SupportedAssetAggregates';
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<SupportedAssetDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/**
 * A condition to be used against `SupportedAsset` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type SupportedAssetCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<ChainflipAsset>;
};

export type SupportedAssetDistinctCountAggregates = {
  __typename?: 'SupportedAssetDistinctCountAggregates';
  /** Distinct count of id across the matching connection */
  id?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `SupportedAsset` object types. All fields are combined with a logical ‘and.’ */
export type SupportedAssetFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SupportedAssetFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<ChainflipAssetFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SupportedAssetFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SupportedAssetFilter>>;
};

/** A connection to a list of `SupportedAsset` values. */
export type SupportedAssetsConnection = {
  __typename?: 'SupportedAssetsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<SupportedAssetAggregates>;
  /** A list of edges which contains the `SupportedAsset` and cursor to aid in pagination. */
  edges: Array<SupportedAssetsEdge>;
  /** A list of `SupportedAsset` objects. */
  nodes: Array<SupportedAsset>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SupportedAsset` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SupportedAsset` edge in the connection. */
export type SupportedAssetsEdge = {
  __typename?: 'SupportedAssetsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SupportedAsset` at the end of the edge. */
  node: SupportedAsset;
};

/** Methods to use when ordering `SupportedAsset`. */
export type SupportedAssetsOrderBy =
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NATURAL';

export type TokenPrice = Node & {
  __typename?: 'TokenPrice';
  address: Scalars['String']['output'];
  chainId: Scalars['String']['output'];
  createdAt: Scalars['Datetime']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  updatedAt: Scalars['Datetime']['output'];
  usdPrice: Scalars['Float']['output'];
};

export type TokenPriceAggregates = {
  __typename?: 'TokenPriceAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<TokenPriceAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<TokenPriceDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<TokenPriceMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<TokenPriceMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<TokenPriceStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<TokenPriceStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<TokenPriceSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<TokenPriceVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<TokenPriceVarianceSampleAggregates>;
};

export type TokenPriceAverageAggregates = {
  __typename?: 'TokenPriceAverageAggregates';
  /** Mean average of usdPrice across the matching connection */
  usdPrice?: Maybe<Scalars['Float']['output']>;
};

/**
 * A condition to be used against `TokenPrice` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type TokenPriceCondition = {
  /** Checks for equality with the object’s `address` field. */
  address?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `chainId` field. */
  chainId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `usdPrice` field. */
  usdPrice?: InputMaybe<Scalars['Float']['input']>;
};

export type TokenPriceDistinctCountAggregates = {
  __typename?: 'TokenPriceDistinctCountAggregates';
  /** Distinct count of address across the matching connection */
  address?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of chainId across the matching connection */
  chainId?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of createdAt across the matching connection */
  createdAt?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of updatedAt across the matching connection */
  updatedAt?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of usdPrice across the matching connection */
  usdPrice?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `TokenPrice` object types. All fields are combined with a logical ‘and.’ */
export type TokenPriceFilter = {
  /** Filter by the object’s `address` field. */
  address?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TokenPriceFilter>>;
  /** Filter by the object’s `chainId` field. */
  chainId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `createdAt` field. */
  createdAt?: InputMaybe<DatetimeFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TokenPriceFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TokenPriceFilter>>;
  /** Filter by the object’s `updatedAt` field. */
  updatedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `usdPrice` field. */
  usdPrice?: InputMaybe<FloatFilter>;
};

/** Grouping methods for `TokenPrice` for usage during aggregation. */
export type TokenPriceGroupBy =
  | 'ADDRESS'
  | 'CHAIN_ID'
  | 'CREATED_AT'
  | 'CREATED_AT_TRUNCATED_TO_DAY'
  | 'CREATED_AT_TRUNCATED_TO_HOUR'
  | 'CREATED_AT_TRUNCATED_TO_MONTH'
  | 'CREATED_AT_TRUNCATED_TO_WEEK'
  | 'UPDATED_AT'
  | 'UPDATED_AT_TRUNCATED_TO_DAY'
  | 'UPDATED_AT_TRUNCATED_TO_HOUR'
  | 'UPDATED_AT_TRUNCATED_TO_MONTH'
  | 'UPDATED_AT_TRUNCATED_TO_WEEK'
  | 'USD_PRICE';

export type TokenPriceHavingAverageInput = {
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
  usdPrice?: InputMaybe<HavingFloatFilter>;
};

export type TokenPriceHavingDistinctCountInput = {
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
  usdPrice?: InputMaybe<HavingFloatFilter>;
};

/** Conditions for `TokenPrice` aggregates. */
export type TokenPriceHavingInput = {
  AND?: InputMaybe<Array<TokenPriceHavingInput>>;
  OR?: InputMaybe<Array<TokenPriceHavingInput>>;
  average?: InputMaybe<TokenPriceHavingAverageInput>;
  distinctCount?: InputMaybe<TokenPriceHavingDistinctCountInput>;
  max?: InputMaybe<TokenPriceHavingMaxInput>;
  min?: InputMaybe<TokenPriceHavingMinInput>;
  stddevPopulation?: InputMaybe<TokenPriceHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<TokenPriceHavingStddevSampleInput>;
  sum?: InputMaybe<TokenPriceHavingSumInput>;
  variancePopulation?: InputMaybe<TokenPriceHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<TokenPriceHavingVarianceSampleInput>;
};

export type TokenPriceHavingMaxInput = {
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
  usdPrice?: InputMaybe<HavingFloatFilter>;
};

export type TokenPriceHavingMinInput = {
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
  usdPrice?: InputMaybe<HavingFloatFilter>;
};

export type TokenPriceHavingStddevPopulationInput = {
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
  usdPrice?: InputMaybe<HavingFloatFilter>;
};

export type TokenPriceHavingStddevSampleInput = {
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
  usdPrice?: InputMaybe<HavingFloatFilter>;
};

export type TokenPriceHavingSumInput = {
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
  usdPrice?: InputMaybe<HavingFloatFilter>;
};

export type TokenPriceHavingVariancePopulationInput = {
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
  usdPrice?: InputMaybe<HavingFloatFilter>;
};

export type TokenPriceHavingVarianceSampleInput = {
  createdAt?: InputMaybe<HavingDatetimeFilter>;
  updatedAt?: InputMaybe<HavingDatetimeFilter>;
  usdPrice?: InputMaybe<HavingFloatFilter>;
};

export type TokenPriceMaxAggregates = {
  __typename?: 'TokenPriceMaxAggregates';
  /** Maximum of createdAt across the matching connection */
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  /** Maximum of updatedAt across the matching connection */
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Maximum of usdPrice across the matching connection */
  usdPrice?: Maybe<Scalars['Float']['output']>;
};

export type TokenPriceMinAggregates = {
  __typename?: 'TokenPriceMinAggregates';
  /** Minimum of createdAt across the matching connection */
  createdAt?: Maybe<Scalars['Datetime']['output']>;
  /** Minimum of updatedAt across the matching connection */
  updatedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Minimum of usdPrice across the matching connection */
  usdPrice?: Maybe<Scalars['Float']['output']>;
};

export type TokenPriceStddevPopulationAggregates = {
  __typename?: 'TokenPriceStddevPopulationAggregates';
  /** Population standard deviation of usdPrice across the matching connection */
  usdPrice?: Maybe<Scalars['Float']['output']>;
};

export type TokenPriceStddevSampleAggregates = {
  __typename?: 'TokenPriceStddevSampleAggregates';
  /** Sample standard deviation of usdPrice across the matching connection */
  usdPrice?: Maybe<Scalars['Float']['output']>;
};

export type TokenPriceSumAggregates = {
  __typename?: 'TokenPriceSumAggregates';
  /** Sum of usdPrice across the matching connection */
  usdPrice: Scalars['Float']['output'];
};

export type TokenPriceVariancePopulationAggregates = {
  __typename?: 'TokenPriceVariancePopulationAggregates';
  /** Population variance of usdPrice across the matching connection */
  usdPrice?: Maybe<Scalars['Float']['output']>;
};

export type TokenPriceVarianceSampleAggregates = {
  __typename?: 'TokenPriceVarianceSampleAggregates';
  /** Sample variance of usdPrice across the matching connection */
  usdPrice?: Maybe<Scalars['Float']['output']>;
};

/** A connection to a list of `TokenPrice` values. */
export type TokenPricesConnection = {
  __typename?: 'TokenPricesConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<TokenPriceAggregates>;
  /** A list of edges which contains the `TokenPrice` and cursor to aid in pagination. */
  edges: Array<TokenPricesEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<TokenPriceAggregates>>;
  /** A list of `TokenPrice` objects. */
  nodes: Array<TokenPrice>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TokenPrice` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `TokenPrice` values. */
export type TokenPricesConnectionGroupedAggregatesArgs = {
  groupBy: Array<TokenPriceGroupBy>;
  having?: InputMaybe<TokenPriceHavingInput>;
};

/** A `TokenPrice` edge in the connection. */
export type TokenPricesEdge = {
  __typename?: 'TokenPricesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TokenPrice` at the end of the edge. */
  node: TokenPrice;
};

/** Methods to use when ordering `TokenPrice`. */
export type TokenPricesOrderBy =
  | 'ADDRESS_ASC'
  | 'ADDRESS_DESC'
  | 'CHAIN_ID_ASC'
  | 'CHAIN_ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC'
  | 'USD_PRICE_ASC'
  | 'USD_PRICE_DESC';

/** A connection to a list of `TradingStrategy` values. */
export type TradingStrategiesConnection = {
  __typename?: 'TradingStrategiesConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<TradingStrategyAggregates>;
  /** A list of edges which contains the `TradingStrategy` and cursor to aid in pagination. */
  edges: Array<TradingStrategiesEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<TradingStrategyAggregates>>;
  /** A list of `TradingStrategy` objects. */
  nodes: Array<TradingStrategy>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TradingStrategy` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `TradingStrategy` values. */
export type TradingStrategiesConnectionGroupedAggregatesArgs = {
  groupBy: Array<TradingStrategyGroupBy>;
  having?: InputMaybe<TradingStrategyHavingInput>;
};

/** A `TradingStrategy` edge in the connection. */
export type TradingStrategiesEdge = {
  __typename?: 'TradingStrategiesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TradingStrategy` at the end of the edge. */
  node: TradingStrategy;
};

/** Methods to use when ordering `TradingStrategy`. */
export type TradingStrategiesOrderBy =
  | 'BASE_ASSET_ASC'
  | 'BASE_ASSET_BALANCE_ASC'
  | 'BASE_ASSET_BALANCE_DESC'
  | 'BASE_ASSET_BALANCE_USD_ASC'
  | 'BASE_ASSET_BALANCE_USD_DESC'
  | 'BASE_ASSET_DESC'
  | 'KEY_ASC'
  | 'KEY_DESC'
  | 'NATURAL'
  | 'OWNER_ACCOUNT_ID_SS58_ASC'
  | 'OWNER_ACCOUNT_ID_SS58_DESC'
  | 'QUOTE_ASSET_ASC'
  | 'QUOTE_ASSET_BALANCE_ASC'
  | 'QUOTE_ASSET_BALANCE_DESC'
  | 'QUOTE_ASSET_BALANCE_USD_ASC'
  | 'QUOTE_ASSET_BALANCE_USD_DESC'
  | 'QUOTE_ASSET_DESC'
  | 'STRATEGY_ACCOUNT_ID_SS58_ASC'
  | 'STRATEGY_ACCOUNT_ID_SS58_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC';

export type TradingStrategy = {
  __typename?: 'TradingStrategy';
  baseAsset: ChainflipAsset;
  baseAssetBalance: Scalars['BigFloat']['output'];
  baseAssetBalanceUsd: Scalars['BigFloat']['output'];
  key: Scalars['String']['output'];
  /** Reads a single `LpAccount` that is related to this `TradingStrategy`. */
  lpAccountByOwnerAccountIdSs58: LpAccount;
  ownerAccountIdSs58: Scalars['String']['output'];
  quoteAsset: ChainflipAsset;
  quoteAssetBalance: Scalars['BigFloat']['output'];
  quoteAssetBalanceUsd: Scalars['BigFloat']['output'];
  strategyAccountIdSs58: Scalars['String']['output'];
  type: TradingStrategyType;
};

export type TradingStrategyAggregates = {
  __typename?: 'TradingStrategyAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<TradingStrategyAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<TradingStrategyDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<TradingStrategyMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<TradingStrategyMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<TradingStrategyStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<TradingStrategyStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<TradingStrategySumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<TradingStrategyVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<TradingStrategyVarianceSampleAggregates>;
};

/** A filter to be used against aggregates of `TradingStrategy` object types. */
export type TradingStrategyAggregatesFilter = {
  /** Mean average aggregate over matching `TradingStrategy` objects. */
  average?: InputMaybe<TradingStrategyAverageAggregateFilter>;
  /** Distinct count aggregate over matching `TradingStrategy` objects. */
  distinctCount?: InputMaybe<TradingStrategyDistinctCountAggregateFilter>;
  /** A filter that must pass for the relevant `TradingStrategy` object to be included within the aggregate. */
  filter?: InputMaybe<TradingStrategyFilter>;
  /** Maximum aggregate over matching `TradingStrategy` objects. */
  max?: InputMaybe<TradingStrategyMaxAggregateFilter>;
  /** Minimum aggregate over matching `TradingStrategy` objects. */
  min?: InputMaybe<TradingStrategyMinAggregateFilter>;
  /** Population standard deviation aggregate over matching `TradingStrategy` objects. */
  stddevPopulation?: InputMaybe<TradingStrategyStddevPopulationAggregateFilter>;
  /** Sample standard deviation aggregate over matching `TradingStrategy` objects. */
  stddevSample?: InputMaybe<TradingStrategyStddevSampleAggregateFilter>;
  /** Sum aggregate over matching `TradingStrategy` objects. */
  sum?: InputMaybe<TradingStrategySumAggregateFilter>;
  /** Population variance aggregate over matching `TradingStrategy` objects. */
  variancePopulation?: InputMaybe<TradingStrategyVariancePopulationAggregateFilter>;
  /** Sample variance aggregate over matching `TradingStrategy` objects. */
  varianceSample?: InputMaybe<TradingStrategyVarianceSampleAggregateFilter>;
};

export type TradingStrategyAverageAggregateFilter = {
  baseAssetBalance?: InputMaybe<BigFloatFilter>;
  baseAssetBalanceUsd?: InputMaybe<BigFloatFilter>;
  quoteAssetBalance?: InputMaybe<BigFloatFilter>;
  quoteAssetBalanceUsd?: InputMaybe<BigFloatFilter>;
};

export type TradingStrategyAverageAggregates = {
  __typename?: 'TradingStrategyAverageAggregates';
  /** Mean average of baseAssetBalance across the matching connection */
  baseAssetBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of baseAssetBalanceUsd across the matching connection */
  baseAssetBalanceUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of quoteAssetBalance across the matching connection */
  quoteAssetBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of quoteAssetBalanceUsd across the matching connection */
  quoteAssetBalanceUsd?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `TradingStrategy` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TradingStrategyCondition = {
  /** Checks for equality with the object’s `baseAsset` field. */
  baseAsset?: InputMaybe<ChainflipAsset>;
  /** Checks for equality with the object’s `baseAssetBalance` field. */
  baseAssetBalance?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `baseAssetBalanceUsd` field. */
  baseAssetBalanceUsd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `key` field. */
  key?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `ownerAccountIdSs58` field. */
  ownerAccountIdSs58?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `quoteAsset` field. */
  quoteAsset?: InputMaybe<ChainflipAsset>;
  /** Checks for equality with the object’s `quoteAssetBalance` field. */
  quoteAssetBalance?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `quoteAssetBalanceUsd` field. */
  quoteAssetBalanceUsd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `strategyAccountIdSs58` field. */
  strategyAccountIdSs58?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<TradingStrategyType>;
};

export type TradingStrategyDistinctCountAggregateFilter = {
  baseAsset?: InputMaybe<BigIntFilter>;
  baseAssetBalance?: InputMaybe<BigIntFilter>;
  baseAssetBalanceUsd?: InputMaybe<BigIntFilter>;
  key?: InputMaybe<BigIntFilter>;
  ownerAccountIdSs58?: InputMaybe<BigIntFilter>;
  quoteAsset?: InputMaybe<BigIntFilter>;
  quoteAssetBalance?: InputMaybe<BigIntFilter>;
  quoteAssetBalanceUsd?: InputMaybe<BigIntFilter>;
  strategyAccountIdSs58?: InputMaybe<BigIntFilter>;
  type?: InputMaybe<BigIntFilter>;
};

export type TradingStrategyDistinctCountAggregates = {
  __typename?: 'TradingStrategyDistinctCountAggregates';
  /** Distinct count of baseAsset across the matching connection */
  baseAsset?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of baseAssetBalance across the matching connection */
  baseAssetBalance?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of baseAssetBalanceUsd across the matching connection */
  baseAssetBalanceUsd?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of key across the matching connection */
  key?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of ownerAccountIdSs58 across the matching connection */
  ownerAccountIdSs58?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of quoteAsset across the matching connection */
  quoteAsset?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of quoteAssetBalance across the matching connection */
  quoteAssetBalance?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of quoteAssetBalanceUsd across the matching connection */
  quoteAssetBalanceUsd?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of strategyAccountIdSs58 across the matching connection */
  strategyAccountIdSs58?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of type across the matching connection */
  type?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `TradingStrategy` object types. All fields are combined with a logical ‘and.’ */
export type TradingStrategyFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TradingStrategyFilter>>;
  /** Filter by the object’s `baseAsset` field. */
  baseAsset?: InputMaybe<ChainflipAssetFilter>;
  /** Filter by the object’s `baseAssetBalance` field. */
  baseAssetBalance?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `baseAssetBalanceUsd` field. */
  baseAssetBalanceUsd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `key` field. */
  key?: InputMaybe<StringFilter>;
  /** Filter by the object’s `lpAccountByOwnerAccountIdSs58` relation. */
  lpAccountByOwnerAccountIdSs58?: InputMaybe<LpAccountFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TradingStrategyFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TradingStrategyFilter>>;
  /** Filter by the object’s `ownerAccountIdSs58` field. */
  ownerAccountIdSs58?: InputMaybe<StringFilter>;
  /** Filter by the object’s `quoteAsset` field. */
  quoteAsset?: InputMaybe<ChainflipAssetFilter>;
  /** Filter by the object’s `quoteAssetBalance` field. */
  quoteAssetBalance?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `quoteAssetBalanceUsd` field. */
  quoteAssetBalanceUsd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `strategyAccountIdSs58` field. */
  strategyAccountIdSs58?: InputMaybe<StringFilter>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<TradingStrategyTypeFilter>;
};

/** Grouping methods for `TradingStrategy` for usage during aggregation. */
export type TradingStrategyGroupBy =
  | 'BASE_ASSET'
  | 'BASE_ASSET_BALANCE'
  | 'BASE_ASSET_BALANCE_USD'
  | 'KEY'
  | 'OWNER_ACCOUNT_ID_SS58'
  | 'QUOTE_ASSET'
  | 'QUOTE_ASSET_BALANCE'
  | 'QUOTE_ASSET_BALANCE_USD'
  | 'TYPE';

export type TradingStrategyHavingAverageInput = {
  baseAssetBalance?: InputMaybe<HavingBigfloatFilter>;
  baseAssetBalanceUsd?: InputMaybe<HavingBigfloatFilter>;
  quoteAssetBalance?: InputMaybe<HavingBigfloatFilter>;
  quoteAssetBalanceUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type TradingStrategyHavingDistinctCountInput = {
  baseAssetBalance?: InputMaybe<HavingBigfloatFilter>;
  baseAssetBalanceUsd?: InputMaybe<HavingBigfloatFilter>;
  quoteAssetBalance?: InputMaybe<HavingBigfloatFilter>;
  quoteAssetBalanceUsd?: InputMaybe<HavingBigfloatFilter>;
};

/** Conditions for `TradingStrategy` aggregates. */
export type TradingStrategyHavingInput = {
  AND?: InputMaybe<Array<TradingStrategyHavingInput>>;
  OR?: InputMaybe<Array<TradingStrategyHavingInput>>;
  average?: InputMaybe<TradingStrategyHavingAverageInput>;
  distinctCount?: InputMaybe<TradingStrategyHavingDistinctCountInput>;
  max?: InputMaybe<TradingStrategyHavingMaxInput>;
  min?: InputMaybe<TradingStrategyHavingMinInput>;
  stddevPopulation?: InputMaybe<TradingStrategyHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<TradingStrategyHavingStddevSampleInput>;
  sum?: InputMaybe<TradingStrategyHavingSumInput>;
  variancePopulation?: InputMaybe<TradingStrategyHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<TradingStrategyHavingVarianceSampleInput>;
};

export type TradingStrategyHavingMaxInput = {
  baseAssetBalance?: InputMaybe<HavingBigfloatFilter>;
  baseAssetBalanceUsd?: InputMaybe<HavingBigfloatFilter>;
  quoteAssetBalance?: InputMaybe<HavingBigfloatFilter>;
  quoteAssetBalanceUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type TradingStrategyHavingMinInput = {
  baseAssetBalance?: InputMaybe<HavingBigfloatFilter>;
  baseAssetBalanceUsd?: InputMaybe<HavingBigfloatFilter>;
  quoteAssetBalance?: InputMaybe<HavingBigfloatFilter>;
  quoteAssetBalanceUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type TradingStrategyHavingStddevPopulationInput = {
  baseAssetBalance?: InputMaybe<HavingBigfloatFilter>;
  baseAssetBalanceUsd?: InputMaybe<HavingBigfloatFilter>;
  quoteAssetBalance?: InputMaybe<HavingBigfloatFilter>;
  quoteAssetBalanceUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type TradingStrategyHavingStddevSampleInput = {
  baseAssetBalance?: InputMaybe<HavingBigfloatFilter>;
  baseAssetBalanceUsd?: InputMaybe<HavingBigfloatFilter>;
  quoteAssetBalance?: InputMaybe<HavingBigfloatFilter>;
  quoteAssetBalanceUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type TradingStrategyHavingSumInput = {
  baseAssetBalance?: InputMaybe<HavingBigfloatFilter>;
  baseAssetBalanceUsd?: InputMaybe<HavingBigfloatFilter>;
  quoteAssetBalance?: InputMaybe<HavingBigfloatFilter>;
  quoteAssetBalanceUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type TradingStrategyHavingVariancePopulationInput = {
  baseAssetBalance?: InputMaybe<HavingBigfloatFilter>;
  baseAssetBalanceUsd?: InputMaybe<HavingBigfloatFilter>;
  quoteAssetBalance?: InputMaybe<HavingBigfloatFilter>;
  quoteAssetBalanceUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type TradingStrategyHavingVarianceSampleInput = {
  baseAssetBalance?: InputMaybe<HavingBigfloatFilter>;
  baseAssetBalanceUsd?: InputMaybe<HavingBigfloatFilter>;
  quoteAssetBalance?: InputMaybe<HavingBigfloatFilter>;
  quoteAssetBalanceUsd?: InputMaybe<HavingBigfloatFilter>;
};

export type TradingStrategyLimit = Node & {
  __typename?: 'TradingStrategyLimit';
  asset: ChainflipAsset;
  id: Scalars['Int']['output'];
  minimumAddedFundsAmount: Scalars['BigFloat']['output'];
  minimumDeploymentAmount: Scalars['BigFloat']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

export type TradingStrategyLimitAggregates = {
  __typename?: 'TradingStrategyLimitAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<TradingStrategyLimitAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<TradingStrategyLimitDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<TradingStrategyLimitMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<TradingStrategyLimitMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<TradingStrategyLimitStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<TradingStrategyLimitStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<TradingStrategyLimitSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<TradingStrategyLimitVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<TradingStrategyLimitVarianceSampleAggregates>;
};

export type TradingStrategyLimitAverageAggregates = {
  __typename?: 'TradingStrategyLimitAverageAggregates';
  /** Mean average of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of minimumAddedFundsAmount across the matching connection */
  minimumAddedFundsAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of minimumDeploymentAmount across the matching connection */
  minimumDeploymentAmount?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `TradingStrategyLimit` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type TradingStrategyLimitCondition = {
  /** Checks for equality with the object’s `asset` field. */
  asset?: InputMaybe<ChainflipAsset>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `minimumAddedFundsAmount` field. */
  minimumAddedFundsAmount?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `minimumDeploymentAmount` field. */
  minimumDeploymentAmount?: InputMaybe<Scalars['BigFloat']['input']>;
};

export type TradingStrategyLimitDistinctCountAggregates = {
  __typename?: 'TradingStrategyLimitDistinctCountAggregates';
  /** Distinct count of asset across the matching connection */
  asset?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of id across the matching connection */
  id?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of minimumAddedFundsAmount across the matching connection */
  minimumAddedFundsAmount?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of minimumDeploymentAmount across the matching connection */
  minimumDeploymentAmount?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `TradingStrategyLimit` object types. All fields are combined with a logical ‘and.’ */
export type TradingStrategyLimitFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TradingStrategyLimitFilter>>;
  /** Filter by the object’s `asset` field. */
  asset?: InputMaybe<ChainflipAssetFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `minimumAddedFundsAmount` field. */
  minimumAddedFundsAmount?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `minimumDeploymentAmount` field. */
  minimumDeploymentAmount?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TradingStrategyLimitFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TradingStrategyLimitFilter>>;
};

/** Grouping methods for `TradingStrategyLimit` for usage during aggregation. */
export type TradingStrategyLimitGroupBy =
  | 'MINIMUM_ADDED_FUNDS_AMOUNT'
  | 'MINIMUM_DEPLOYMENT_AMOUNT';

export type TradingStrategyLimitHavingAverageInput = {
  id?: InputMaybe<HavingIntFilter>;
  minimumAddedFundsAmount?: InputMaybe<HavingBigfloatFilter>;
  minimumDeploymentAmount?: InputMaybe<HavingBigfloatFilter>;
};

export type TradingStrategyLimitHavingDistinctCountInput = {
  id?: InputMaybe<HavingIntFilter>;
  minimumAddedFundsAmount?: InputMaybe<HavingBigfloatFilter>;
  minimumDeploymentAmount?: InputMaybe<HavingBigfloatFilter>;
};

/** Conditions for `TradingStrategyLimit` aggregates. */
export type TradingStrategyLimitHavingInput = {
  AND?: InputMaybe<Array<TradingStrategyLimitHavingInput>>;
  OR?: InputMaybe<Array<TradingStrategyLimitHavingInput>>;
  average?: InputMaybe<TradingStrategyLimitHavingAverageInput>;
  distinctCount?: InputMaybe<TradingStrategyLimitHavingDistinctCountInput>;
  max?: InputMaybe<TradingStrategyLimitHavingMaxInput>;
  min?: InputMaybe<TradingStrategyLimitHavingMinInput>;
  stddevPopulation?: InputMaybe<TradingStrategyLimitHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<TradingStrategyLimitHavingStddevSampleInput>;
  sum?: InputMaybe<TradingStrategyLimitHavingSumInput>;
  variancePopulation?: InputMaybe<TradingStrategyLimitHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<TradingStrategyLimitHavingVarianceSampleInput>;
};

export type TradingStrategyLimitHavingMaxInput = {
  id?: InputMaybe<HavingIntFilter>;
  minimumAddedFundsAmount?: InputMaybe<HavingBigfloatFilter>;
  minimumDeploymentAmount?: InputMaybe<HavingBigfloatFilter>;
};

export type TradingStrategyLimitHavingMinInput = {
  id?: InputMaybe<HavingIntFilter>;
  minimumAddedFundsAmount?: InputMaybe<HavingBigfloatFilter>;
  minimumDeploymentAmount?: InputMaybe<HavingBigfloatFilter>;
};

export type TradingStrategyLimitHavingStddevPopulationInput = {
  id?: InputMaybe<HavingIntFilter>;
  minimumAddedFundsAmount?: InputMaybe<HavingBigfloatFilter>;
  minimumDeploymentAmount?: InputMaybe<HavingBigfloatFilter>;
};

export type TradingStrategyLimitHavingStddevSampleInput = {
  id?: InputMaybe<HavingIntFilter>;
  minimumAddedFundsAmount?: InputMaybe<HavingBigfloatFilter>;
  minimumDeploymentAmount?: InputMaybe<HavingBigfloatFilter>;
};

export type TradingStrategyLimitHavingSumInput = {
  id?: InputMaybe<HavingIntFilter>;
  minimumAddedFundsAmount?: InputMaybe<HavingBigfloatFilter>;
  minimumDeploymentAmount?: InputMaybe<HavingBigfloatFilter>;
};

export type TradingStrategyLimitHavingVariancePopulationInput = {
  id?: InputMaybe<HavingIntFilter>;
  minimumAddedFundsAmount?: InputMaybe<HavingBigfloatFilter>;
  minimumDeploymentAmount?: InputMaybe<HavingBigfloatFilter>;
};

export type TradingStrategyLimitHavingVarianceSampleInput = {
  id?: InputMaybe<HavingIntFilter>;
  minimumAddedFundsAmount?: InputMaybe<HavingBigfloatFilter>;
  minimumDeploymentAmount?: InputMaybe<HavingBigfloatFilter>;
};

export type TradingStrategyLimitMaxAggregates = {
  __typename?: 'TradingStrategyLimitMaxAggregates';
  /** Maximum of id across the matching connection */
  id?: Maybe<Scalars['Int']['output']>;
  /** Maximum of minimumAddedFundsAmount across the matching connection */
  minimumAddedFundsAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of minimumDeploymentAmount across the matching connection */
  minimumDeploymentAmount?: Maybe<Scalars['BigFloat']['output']>;
};

export type TradingStrategyLimitMinAggregates = {
  __typename?: 'TradingStrategyLimitMinAggregates';
  /** Minimum of id across the matching connection */
  id?: Maybe<Scalars['Int']['output']>;
  /** Minimum of minimumAddedFundsAmount across the matching connection */
  minimumAddedFundsAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of minimumDeploymentAmount across the matching connection */
  minimumDeploymentAmount?: Maybe<Scalars['BigFloat']['output']>;
};

export type TradingStrategyLimitStddevPopulationAggregates = {
  __typename?: 'TradingStrategyLimitStddevPopulationAggregates';
  /** Population standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of minimumAddedFundsAmount across the matching connection */
  minimumAddedFundsAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of minimumDeploymentAmount across the matching connection */
  minimumDeploymentAmount?: Maybe<Scalars['BigFloat']['output']>;
};

export type TradingStrategyLimitStddevSampleAggregates = {
  __typename?: 'TradingStrategyLimitStddevSampleAggregates';
  /** Sample standard deviation of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of minimumAddedFundsAmount across the matching connection */
  minimumAddedFundsAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of minimumDeploymentAmount across the matching connection */
  minimumDeploymentAmount?: Maybe<Scalars['BigFloat']['output']>;
};

export type TradingStrategyLimitSumAggregates = {
  __typename?: 'TradingStrategyLimitSumAggregates';
  /** Sum of id across the matching connection */
  id: Scalars['BigInt']['output'];
  /** Sum of minimumAddedFundsAmount across the matching connection */
  minimumAddedFundsAmount: Scalars['BigFloat']['output'];
  /** Sum of minimumDeploymentAmount across the matching connection */
  minimumDeploymentAmount: Scalars['BigFloat']['output'];
};

export type TradingStrategyLimitVariancePopulationAggregates = {
  __typename?: 'TradingStrategyLimitVariancePopulationAggregates';
  /** Population variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of minimumAddedFundsAmount across the matching connection */
  minimumAddedFundsAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of minimumDeploymentAmount across the matching connection */
  minimumDeploymentAmount?: Maybe<Scalars['BigFloat']['output']>;
};

export type TradingStrategyLimitVarianceSampleAggregates = {
  __typename?: 'TradingStrategyLimitVarianceSampleAggregates';
  /** Sample variance of id across the matching connection */
  id?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of minimumAddedFundsAmount across the matching connection */
  minimumAddedFundsAmount?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of minimumDeploymentAmount across the matching connection */
  minimumDeploymentAmount?: Maybe<Scalars['BigFloat']['output']>;
};

/** A connection to a list of `TradingStrategyLimit` values. */
export type TradingStrategyLimitsConnection = {
  __typename?: 'TradingStrategyLimitsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<TradingStrategyLimitAggregates>;
  /** A list of edges which contains the `TradingStrategyLimit` and cursor to aid in pagination. */
  edges: Array<TradingStrategyLimitsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<TradingStrategyLimitAggregates>>;
  /** A list of `TradingStrategyLimit` objects. */
  nodes: Array<TradingStrategyLimit>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TradingStrategyLimit` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `TradingStrategyLimit` values. */
export type TradingStrategyLimitsConnectionGroupedAggregatesArgs = {
  groupBy: Array<TradingStrategyLimitGroupBy>;
  having?: InputMaybe<TradingStrategyLimitHavingInput>;
};

/** A `TradingStrategyLimit` edge in the connection. */
export type TradingStrategyLimitsEdge = {
  __typename?: 'TradingStrategyLimitsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TradingStrategyLimit` at the end of the edge. */
  node: TradingStrategyLimit;
};

/** Methods to use when ordering `TradingStrategyLimit`. */
export type TradingStrategyLimitsOrderBy =
  | 'ASSET_ASC'
  | 'ASSET_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'MINIMUM_ADDED_FUNDS_AMOUNT_ASC'
  | 'MINIMUM_ADDED_FUNDS_AMOUNT_DESC'
  | 'MINIMUM_DEPLOYMENT_AMOUNT_ASC'
  | 'MINIMUM_DEPLOYMENT_AMOUNT_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

export type TradingStrategyMaxAggregateFilter = {
  baseAssetBalance?: InputMaybe<BigFloatFilter>;
  baseAssetBalanceUsd?: InputMaybe<BigFloatFilter>;
  quoteAssetBalance?: InputMaybe<BigFloatFilter>;
  quoteAssetBalanceUsd?: InputMaybe<BigFloatFilter>;
};

export type TradingStrategyMaxAggregates = {
  __typename?: 'TradingStrategyMaxAggregates';
  /** Maximum of baseAssetBalance across the matching connection */
  baseAssetBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of baseAssetBalanceUsd across the matching connection */
  baseAssetBalanceUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of quoteAssetBalance across the matching connection */
  quoteAssetBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of quoteAssetBalanceUsd across the matching connection */
  quoteAssetBalanceUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type TradingStrategyMinAggregateFilter = {
  baseAssetBalance?: InputMaybe<BigFloatFilter>;
  baseAssetBalanceUsd?: InputMaybe<BigFloatFilter>;
  quoteAssetBalance?: InputMaybe<BigFloatFilter>;
  quoteAssetBalanceUsd?: InputMaybe<BigFloatFilter>;
};

export type TradingStrategyMinAggregates = {
  __typename?: 'TradingStrategyMinAggregates';
  /** Minimum of baseAssetBalance across the matching connection */
  baseAssetBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of baseAssetBalanceUsd across the matching connection */
  baseAssetBalanceUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of quoteAssetBalance across the matching connection */
  quoteAssetBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of quoteAssetBalanceUsd across the matching connection */
  quoteAssetBalanceUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type TradingStrategyStddevPopulationAggregateFilter = {
  baseAssetBalance?: InputMaybe<BigFloatFilter>;
  baseAssetBalanceUsd?: InputMaybe<BigFloatFilter>;
  quoteAssetBalance?: InputMaybe<BigFloatFilter>;
  quoteAssetBalanceUsd?: InputMaybe<BigFloatFilter>;
};

export type TradingStrategyStddevPopulationAggregates = {
  __typename?: 'TradingStrategyStddevPopulationAggregates';
  /** Population standard deviation of baseAssetBalance across the matching connection */
  baseAssetBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of baseAssetBalanceUsd across the matching connection */
  baseAssetBalanceUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of quoteAssetBalance across the matching connection */
  quoteAssetBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of quoteAssetBalanceUsd across the matching connection */
  quoteAssetBalanceUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type TradingStrategyStddevSampleAggregateFilter = {
  baseAssetBalance?: InputMaybe<BigFloatFilter>;
  baseAssetBalanceUsd?: InputMaybe<BigFloatFilter>;
  quoteAssetBalance?: InputMaybe<BigFloatFilter>;
  quoteAssetBalanceUsd?: InputMaybe<BigFloatFilter>;
};

export type TradingStrategyStddevSampleAggregates = {
  __typename?: 'TradingStrategyStddevSampleAggregates';
  /** Sample standard deviation of baseAssetBalance across the matching connection */
  baseAssetBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of baseAssetBalanceUsd across the matching connection */
  baseAssetBalanceUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of quoteAssetBalance across the matching connection */
  quoteAssetBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of quoteAssetBalanceUsd across the matching connection */
  quoteAssetBalanceUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type TradingStrategySumAggregateFilter = {
  baseAssetBalance?: InputMaybe<BigFloatFilter>;
  baseAssetBalanceUsd?: InputMaybe<BigFloatFilter>;
  quoteAssetBalance?: InputMaybe<BigFloatFilter>;
  quoteAssetBalanceUsd?: InputMaybe<BigFloatFilter>;
};

export type TradingStrategySumAggregates = {
  __typename?: 'TradingStrategySumAggregates';
  /** Sum of baseAssetBalance across the matching connection */
  baseAssetBalance: Scalars['BigFloat']['output'];
  /** Sum of baseAssetBalanceUsd across the matching connection */
  baseAssetBalanceUsd: Scalars['BigFloat']['output'];
  /** Sum of quoteAssetBalance across the matching connection */
  quoteAssetBalance: Scalars['BigFloat']['output'];
  /** Sum of quoteAssetBalanceUsd across the matching connection */
  quoteAssetBalanceUsd: Scalars['BigFloat']['output'];
};

export type TradingStrategyType =
  | 'InventoryBased'
  | 'SimpleBuySell'
  | 'TickZeroCentered';

/** A filter to be used against TradingStrategyType fields. All fields are combined with a logical ‘and.’ */
export type TradingStrategyTypeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<TradingStrategyType>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<TradingStrategyType>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<TradingStrategyType>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<TradingStrategyType>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<TradingStrategyType>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<TradingStrategyType>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<TradingStrategyType>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<TradingStrategyType>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<TradingStrategyType>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<TradingStrategyType>>;
};

export type TradingStrategyVariancePopulationAggregateFilter = {
  baseAssetBalance?: InputMaybe<BigFloatFilter>;
  baseAssetBalanceUsd?: InputMaybe<BigFloatFilter>;
  quoteAssetBalance?: InputMaybe<BigFloatFilter>;
  quoteAssetBalanceUsd?: InputMaybe<BigFloatFilter>;
};

export type TradingStrategyVariancePopulationAggregates = {
  __typename?: 'TradingStrategyVariancePopulationAggregates';
  /** Population variance of baseAssetBalance across the matching connection */
  baseAssetBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of baseAssetBalanceUsd across the matching connection */
  baseAssetBalanceUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of quoteAssetBalance across the matching connection */
  quoteAssetBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of quoteAssetBalanceUsd across the matching connection */
  quoteAssetBalanceUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type TradingStrategyVarianceSampleAggregateFilter = {
  baseAssetBalance?: InputMaybe<BigFloatFilter>;
  baseAssetBalanceUsd?: InputMaybe<BigFloatFilter>;
  quoteAssetBalance?: InputMaybe<BigFloatFilter>;
  quoteAssetBalanceUsd?: InputMaybe<BigFloatFilter>;
};

export type TradingStrategyVarianceSampleAggregates = {
  __typename?: 'TradingStrategyVarianceSampleAggregates';
  /** Sample variance of baseAssetBalance across the matching connection */
  baseAssetBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of baseAssetBalanceUsd across the matching connection */
  baseAssetBalanceUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of quoteAssetBalance across the matching connection */
  quoteAssetBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of quoteAssetBalanceUsd across the matching connection */
  quoteAssetBalanceUsd?: Maybe<Scalars['BigFloat']['output']>;
};

export type Unregistered = Node & {
  __typename?: 'Unregistered';
  /** Reads a single `Account` that is related to this `Unregistered`. */
  accountByIdSs58: Account;
  idSs58: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

export type UnregisteredAggregates = {
  __typename?: 'UnregisteredAggregates';
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<UnregisteredDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/**
 * A condition to be used against `Unregistered` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type UnregisteredCondition = {
  /** Checks for equality with the object’s `idSs58` field. */
  idSs58?: InputMaybe<Scalars['String']['input']>;
};

export type UnregisteredDistinctCountAggregates = {
  __typename?: 'UnregisteredDistinctCountAggregates';
  /** Distinct count of idSs58 across the matching connection */
  idSs58?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `Unregistered` object types. All fields are combined with a logical ‘and.’ */
export type UnregisteredFilter = {
  /** Filter by the object’s `accountByIdSs58` relation. */
  accountByIdSs58?: InputMaybe<AccountFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UnregisteredFilter>>;
  /** Filter by the object’s `idSs58` field. */
  idSs58?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UnregisteredFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UnregisteredFilter>>;
};

/** A connection to a list of `Unregistered` values. */
export type UnregisteredsConnection = {
  __typename?: 'UnregisteredsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<UnregisteredAggregates>;
  /** A list of edges which contains the `Unregistered` and cursor to aid in pagination. */
  edges: Array<UnregisteredsEdge>;
  /** A list of `Unregistered` objects. */
  nodes: Array<Unregistered>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Unregistered` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Unregistered` edge in the connection. */
export type UnregisteredsEdge = {
  __typename?: 'UnregisteredsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Unregistered` at the end of the edge. */
  node: Unregistered;
};

/** Methods to use when ordering `Unregistered`. */
export type UnregisteredsOrderBy =
  | 'ID_SS58_ASC'
  | 'ID_SS58_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

export type Validator = Node & {
  __typename?: 'Validator';
  /** Reads a single `Account` that is related to this `Validator`. */
  accountByIdSs58: Account;
  alias?: Maybe<Scalars['String']['output']>;
  apyBp?: Maybe<Scalars['Int']['output']>;
  bid: Scalars['BigFloat']['output'];
  bidValueUsd: Scalars['BigFloat']['output'];
  boundRedeemAddress?: Maybe<Scalars['String']['output']>;
  idHex: Scalars['String']['output'];
  idSs58: Scalars['String']['output'];
  isBidding: Scalars['Boolean']['output'];
  isCurrentAuthority: Scalars['Boolean']['output'];
  isCurrentBackup: Scalars['Boolean']['output'];
  isKeyholder: Scalars['Boolean']['output'];
  isOnline: Scalars['Boolean']['output'];
  isQualified: Scalars['Boolean']['output'];
  lockedBalance: Scalars['BigFloat']['output'];
  lockedBalanceValueUsd: Scalars['BigFloat']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `OperatorValidator`. */
  operatorValidatorsByValidatorIdSs58: OperatorValidatorsConnection;
  reputationPoints: Scalars['Int']['output'];
  role: AccountRole;
  totalBalance: Scalars['BigFloat']['output'];
  totalBalanceValueUsd: Scalars['BigFloat']['output'];
  unlockedBalance: Scalars['BigFloat']['output'];
  unlockedBalanceValueUsd: Scalars['BigFloat']['output'];
  upcomingApyBp?: Maybe<Scalars['Int']['output']>;
};


export type ValidatorOperatorValidatorsByValidatorIdSs58Args = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OperatorValidatorCondition>;
  filter?: InputMaybe<OperatorValidatorFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OperatorValidatorsOrderBy>>;
};

export type ValidatorAggregates = {
  __typename?: 'ValidatorAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<ValidatorAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<ValidatorDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<ValidatorMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<ValidatorMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<ValidatorStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<ValidatorStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<ValidatorSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<ValidatorVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<ValidatorVarianceSampleAggregates>;
};

export type ValidatorAverageAggregates = {
  __typename?: 'ValidatorAverageAggregates';
  /** Mean average of apyBp across the matching connection */
  apyBp?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of bid across the matching connection */
  bid?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of bidValueUsd across the matching connection */
  bidValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of lockedBalance across the matching connection */
  lockedBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of lockedBalanceValueUsd across the matching connection */
  lockedBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of reputationPoints across the matching connection */
  reputationPoints?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of totalBalance across the matching connection */
  totalBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of totalBalanceValueUsd across the matching connection */
  totalBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of unlockedBalance across the matching connection */
  unlockedBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of unlockedBalanceValueUsd across the matching connection */
  unlockedBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Mean average of upcomingApyBp across the matching connection */
  upcomingApyBp?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `Validator` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ValidatorCondition = {
  /** Checks for equality with the object’s `alias` field. */
  alias?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `apyBp` field. */
  apyBp?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `bid` field. */
  bid?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `bidValueUsd` field. */
  bidValueUsd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `boundRedeemAddress` field. */
  boundRedeemAddress?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `idHex` field. */
  idHex?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `idSs58` field. */
  idSs58?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `isBidding` field. */
  isBidding?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isCurrentAuthority` field. */
  isCurrentAuthority?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isCurrentBackup` field. */
  isCurrentBackup?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isKeyholder` field. */
  isKeyholder?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isOnline` field. */
  isOnline?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isQualified` field. */
  isQualified?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `lockedBalance` field. */
  lockedBalance?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `lockedBalanceValueUsd` field. */
  lockedBalanceValueUsd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `reputationPoints` field. */
  reputationPoints?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `role` field. */
  role?: InputMaybe<AccountRole>;
  /** Checks for equality with the object’s `totalBalance` field. */
  totalBalance?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `totalBalanceValueUsd` field. */
  totalBalanceValueUsd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `unlockedBalance` field. */
  unlockedBalance?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `unlockedBalanceValueUsd` field. */
  unlockedBalanceValueUsd?: InputMaybe<Scalars['BigFloat']['input']>;
  /** Checks for equality with the object’s `upcomingApyBp` field. */
  upcomingApyBp?: InputMaybe<Scalars['Int']['input']>;
};

export type ValidatorDistinctCountAggregates = {
  __typename?: 'ValidatorDistinctCountAggregates';
  /** Distinct count of alias across the matching connection */
  alias?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of apyBp across the matching connection */
  apyBp?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of bid across the matching connection */
  bid?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of bidValueUsd across the matching connection */
  bidValueUsd?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of boundRedeemAddress across the matching connection */
  boundRedeemAddress?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of idHex across the matching connection */
  idHex?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of idSs58 across the matching connection */
  idSs58?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of isBidding across the matching connection */
  isBidding?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of isCurrentAuthority across the matching connection */
  isCurrentAuthority?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of isCurrentBackup across the matching connection */
  isCurrentBackup?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of isKeyholder across the matching connection */
  isKeyholder?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of isOnline across the matching connection */
  isOnline?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of isQualified across the matching connection */
  isQualified?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of lockedBalance across the matching connection */
  lockedBalance?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of lockedBalanceValueUsd across the matching connection */
  lockedBalanceValueUsd?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of reputationPoints across the matching connection */
  reputationPoints?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of role across the matching connection */
  role?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of totalBalance across the matching connection */
  totalBalance?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of totalBalanceValueUsd across the matching connection */
  totalBalanceValueUsd?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of unlockedBalance across the matching connection */
  unlockedBalance?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of unlockedBalanceValueUsd across the matching connection */
  unlockedBalanceValueUsd?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of upcomingApyBp across the matching connection */
  upcomingApyBp?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `Validator` object types. All fields are combined with a logical ‘and.’ */
export type ValidatorFilter = {
  /** Filter by the object’s `accountByIdSs58` relation. */
  accountByIdSs58?: InputMaybe<AccountFilter>;
  /** Filter by the object’s `alias` field. */
  alias?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ValidatorFilter>>;
  /** Filter by the object’s `apyBp` field. */
  apyBp?: InputMaybe<IntFilter>;
  /** Filter by the object’s `bid` field. */
  bid?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `bidValueUsd` field. */
  bidValueUsd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `boundRedeemAddress` field. */
  boundRedeemAddress?: InputMaybe<StringFilter>;
  /** Filter by the object’s `idHex` field. */
  idHex?: InputMaybe<StringFilter>;
  /** Filter by the object’s `idSs58` field. */
  idSs58?: InputMaybe<StringFilter>;
  /** Filter by the object’s `isBidding` field. */
  isBidding?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isCurrentAuthority` field. */
  isCurrentAuthority?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isCurrentBackup` field. */
  isCurrentBackup?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isKeyholder` field. */
  isKeyholder?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isOnline` field. */
  isOnline?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isQualified` field. */
  isQualified?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `lockedBalance` field. */
  lockedBalance?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `lockedBalanceValueUsd` field. */
  lockedBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ValidatorFilter>;
  /** Filter by the object’s `operatorValidatorsByValidatorIdSs58` relation. */
  operatorValidatorsByValidatorIdSs58?: InputMaybe<ValidatorToManyOperatorValidatorFilter>;
  /** Some related `operatorValidatorsByValidatorIdSs58` exist. */
  operatorValidatorsByValidatorIdSs58Exist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ValidatorFilter>>;
  /** Filter by the object’s `reputationPoints` field. */
  reputationPoints?: InputMaybe<IntFilter>;
  /** Filter by the object’s `role` field. */
  role?: InputMaybe<AccountRoleFilter>;
  /** Filter by the object’s `totalBalance` field. */
  totalBalance?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `totalBalanceValueUsd` field. */
  totalBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `unlockedBalance` field. */
  unlockedBalance?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `unlockedBalanceValueUsd` field. */
  unlockedBalanceValueUsd?: InputMaybe<BigFloatFilter>;
  /** Filter by the object’s `upcomingApyBp` field. */
  upcomingApyBp?: InputMaybe<IntFilter>;
};

/** Grouping methods for `Validator` for usage during aggregation. */
export type ValidatorGroupBy =
  | 'ALIAS'
  | 'APY_BP'
  | 'BID'
  | 'BID_VALUE_USD'
  | 'BOUND_REDEEM_ADDRESS'
  | 'IS_BIDDING'
  | 'IS_CURRENT_AUTHORITY'
  | 'IS_CURRENT_BACKUP'
  | 'IS_KEYHOLDER'
  | 'IS_ONLINE'
  | 'IS_QUALIFIED'
  | 'LOCKED_BALANCE'
  | 'LOCKED_BALANCE_VALUE_USD'
  | 'REPUTATION_POINTS'
  | 'ROLE'
  | 'TOTAL_BALANCE'
  | 'TOTAL_BALANCE_VALUE_USD'
  | 'UNLOCKED_BALANCE'
  | 'UNLOCKED_BALANCE_VALUE_USD'
  | 'UPCOMING_APY_BP';

export type ValidatorHavingAverageInput = {
  apyBp?: InputMaybe<HavingIntFilter>;
  bid?: InputMaybe<HavingBigfloatFilter>;
  bidValueUsd?: InputMaybe<HavingBigfloatFilter>;
  lockedBalance?: InputMaybe<HavingBigfloatFilter>;
  lockedBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  reputationPoints?: InputMaybe<HavingIntFilter>;
  totalBalance?: InputMaybe<HavingBigfloatFilter>;
  totalBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  unlockedBalance?: InputMaybe<HavingBigfloatFilter>;
  unlockedBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  upcomingApyBp?: InputMaybe<HavingIntFilter>;
};

export type ValidatorHavingDistinctCountInput = {
  apyBp?: InputMaybe<HavingIntFilter>;
  bid?: InputMaybe<HavingBigfloatFilter>;
  bidValueUsd?: InputMaybe<HavingBigfloatFilter>;
  lockedBalance?: InputMaybe<HavingBigfloatFilter>;
  lockedBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  reputationPoints?: InputMaybe<HavingIntFilter>;
  totalBalance?: InputMaybe<HavingBigfloatFilter>;
  totalBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  unlockedBalance?: InputMaybe<HavingBigfloatFilter>;
  unlockedBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  upcomingApyBp?: InputMaybe<HavingIntFilter>;
};

/** Conditions for `Validator` aggregates. */
export type ValidatorHavingInput = {
  AND?: InputMaybe<Array<ValidatorHavingInput>>;
  OR?: InputMaybe<Array<ValidatorHavingInput>>;
  average?: InputMaybe<ValidatorHavingAverageInput>;
  distinctCount?: InputMaybe<ValidatorHavingDistinctCountInput>;
  max?: InputMaybe<ValidatorHavingMaxInput>;
  min?: InputMaybe<ValidatorHavingMinInput>;
  stddevPopulation?: InputMaybe<ValidatorHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<ValidatorHavingStddevSampleInput>;
  sum?: InputMaybe<ValidatorHavingSumInput>;
  variancePopulation?: InputMaybe<ValidatorHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<ValidatorHavingVarianceSampleInput>;
};

export type ValidatorHavingMaxInput = {
  apyBp?: InputMaybe<HavingIntFilter>;
  bid?: InputMaybe<HavingBigfloatFilter>;
  bidValueUsd?: InputMaybe<HavingBigfloatFilter>;
  lockedBalance?: InputMaybe<HavingBigfloatFilter>;
  lockedBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  reputationPoints?: InputMaybe<HavingIntFilter>;
  totalBalance?: InputMaybe<HavingBigfloatFilter>;
  totalBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  unlockedBalance?: InputMaybe<HavingBigfloatFilter>;
  unlockedBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  upcomingApyBp?: InputMaybe<HavingIntFilter>;
};

export type ValidatorHavingMinInput = {
  apyBp?: InputMaybe<HavingIntFilter>;
  bid?: InputMaybe<HavingBigfloatFilter>;
  bidValueUsd?: InputMaybe<HavingBigfloatFilter>;
  lockedBalance?: InputMaybe<HavingBigfloatFilter>;
  lockedBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  reputationPoints?: InputMaybe<HavingIntFilter>;
  totalBalance?: InputMaybe<HavingBigfloatFilter>;
  totalBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  unlockedBalance?: InputMaybe<HavingBigfloatFilter>;
  unlockedBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  upcomingApyBp?: InputMaybe<HavingIntFilter>;
};

export type ValidatorHavingStddevPopulationInput = {
  apyBp?: InputMaybe<HavingIntFilter>;
  bid?: InputMaybe<HavingBigfloatFilter>;
  bidValueUsd?: InputMaybe<HavingBigfloatFilter>;
  lockedBalance?: InputMaybe<HavingBigfloatFilter>;
  lockedBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  reputationPoints?: InputMaybe<HavingIntFilter>;
  totalBalance?: InputMaybe<HavingBigfloatFilter>;
  totalBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  unlockedBalance?: InputMaybe<HavingBigfloatFilter>;
  unlockedBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  upcomingApyBp?: InputMaybe<HavingIntFilter>;
};

export type ValidatorHavingStddevSampleInput = {
  apyBp?: InputMaybe<HavingIntFilter>;
  bid?: InputMaybe<HavingBigfloatFilter>;
  bidValueUsd?: InputMaybe<HavingBigfloatFilter>;
  lockedBalance?: InputMaybe<HavingBigfloatFilter>;
  lockedBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  reputationPoints?: InputMaybe<HavingIntFilter>;
  totalBalance?: InputMaybe<HavingBigfloatFilter>;
  totalBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  unlockedBalance?: InputMaybe<HavingBigfloatFilter>;
  unlockedBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  upcomingApyBp?: InputMaybe<HavingIntFilter>;
};

export type ValidatorHavingSumInput = {
  apyBp?: InputMaybe<HavingIntFilter>;
  bid?: InputMaybe<HavingBigfloatFilter>;
  bidValueUsd?: InputMaybe<HavingBigfloatFilter>;
  lockedBalance?: InputMaybe<HavingBigfloatFilter>;
  lockedBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  reputationPoints?: InputMaybe<HavingIntFilter>;
  totalBalance?: InputMaybe<HavingBigfloatFilter>;
  totalBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  unlockedBalance?: InputMaybe<HavingBigfloatFilter>;
  unlockedBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  upcomingApyBp?: InputMaybe<HavingIntFilter>;
};

export type ValidatorHavingVariancePopulationInput = {
  apyBp?: InputMaybe<HavingIntFilter>;
  bid?: InputMaybe<HavingBigfloatFilter>;
  bidValueUsd?: InputMaybe<HavingBigfloatFilter>;
  lockedBalance?: InputMaybe<HavingBigfloatFilter>;
  lockedBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  reputationPoints?: InputMaybe<HavingIntFilter>;
  totalBalance?: InputMaybe<HavingBigfloatFilter>;
  totalBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  unlockedBalance?: InputMaybe<HavingBigfloatFilter>;
  unlockedBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  upcomingApyBp?: InputMaybe<HavingIntFilter>;
};

export type ValidatorHavingVarianceSampleInput = {
  apyBp?: InputMaybe<HavingIntFilter>;
  bid?: InputMaybe<HavingBigfloatFilter>;
  bidValueUsd?: InputMaybe<HavingBigfloatFilter>;
  lockedBalance?: InputMaybe<HavingBigfloatFilter>;
  lockedBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  reputationPoints?: InputMaybe<HavingIntFilter>;
  totalBalance?: InputMaybe<HavingBigfloatFilter>;
  totalBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  unlockedBalance?: InputMaybe<HavingBigfloatFilter>;
  unlockedBalanceValueUsd?: InputMaybe<HavingBigfloatFilter>;
  upcomingApyBp?: InputMaybe<HavingIntFilter>;
};

export type ValidatorMaxAggregates = {
  __typename?: 'ValidatorMaxAggregates';
  /** Maximum of apyBp across the matching connection */
  apyBp?: Maybe<Scalars['Int']['output']>;
  /** Maximum of bid across the matching connection */
  bid?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of bidValueUsd across the matching connection */
  bidValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of lockedBalance across the matching connection */
  lockedBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of lockedBalanceValueUsd across the matching connection */
  lockedBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of reputationPoints across the matching connection */
  reputationPoints?: Maybe<Scalars['Int']['output']>;
  /** Maximum of totalBalance across the matching connection */
  totalBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of totalBalanceValueUsd across the matching connection */
  totalBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of unlockedBalance across the matching connection */
  unlockedBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of unlockedBalanceValueUsd across the matching connection */
  unlockedBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Maximum of upcomingApyBp across the matching connection */
  upcomingApyBp?: Maybe<Scalars['Int']['output']>;
};

export type ValidatorMinAggregates = {
  __typename?: 'ValidatorMinAggregates';
  /** Minimum of apyBp across the matching connection */
  apyBp?: Maybe<Scalars['Int']['output']>;
  /** Minimum of bid across the matching connection */
  bid?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of bidValueUsd across the matching connection */
  bidValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of lockedBalance across the matching connection */
  lockedBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of lockedBalanceValueUsd across the matching connection */
  lockedBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of reputationPoints across the matching connection */
  reputationPoints?: Maybe<Scalars['Int']['output']>;
  /** Minimum of totalBalance across the matching connection */
  totalBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of totalBalanceValueUsd across the matching connection */
  totalBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of unlockedBalance across the matching connection */
  unlockedBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of unlockedBalanceValueUsd across the matching connection */
  unlockedBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Minimum of upcomingApyBp across the matching connection */
  upcomingApyBp?: Maybe<Scalars['Int']['output']>;
};

export type ValidatorStddevPopulationAggregates = {
  __typename?: 'ValidatorStddevPopulationAggregates';
  /** Population standard deviation of apyBp across the matching connection */
  apyBp?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of bid across the matching connection */
  bid?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of bidValueUsd across the matching connection */
  bidValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of lockedBalance across the matching connection */
  lockedBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of lockedBalanceValueUsd across the matching connection */
  lockedBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of reputationPoints across the matching connection */
  reputationPoints?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of totalBalance across the matching connection */
  totalBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of totalBalanceValueUsd across the matching connection */
  totalBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of unlockedBalance across the matching connection */
  unlockedBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of unlockedBalanceValueUsd across the matching connection */
  unlockedBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population standard deviation of upcomingApyBp across the matching connection */
  upcomingApyBp?: Maybe<Scalars['BigFloat']['output']>;
};

export type ValidatorStddevSampleAggregates = {
  __typename?: 'ValidatorStddevSampleAggregates';
  /** Sample standard deviation of apyBp across the matching connection */
  apyBp?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of bid across the matching connection */
  bid?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of bidValueUsd across the matching connection */
  bidValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of lockedBalance across the matching connection */
  lockedBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of lockedBalanceValueUsd across the matching connection */
  lockedBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of reputationPoints across the matching connection */
  reputationPoints?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of totalBalance across the matching connection */
  totalBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of totalBalanceValueUsd across the matching connection */
  totalBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of unlockedBalance across the matching connection */
  unlockedBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of unlockedBalanceValueUsd across the matching connection */
  unlockedBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample standard deviation of upcomingApyBp across the matching connection */
  upcomingApyBp?: Maybe<Scalars['BigFloat']['output']>;
};

export type ValidatorSumAggregates = {
  __typename?: 'ValidatorSumAggregates';
  /** Sum of apyBp across the matching connection */
  apyBp: Scalars['BigInt']['output'];
  /** Sum of bid across the matching connection */
  bid: Scalars['BigFloat']['output'];
  /** Sum of bidValueUsd across the matching connection */
  bidValueUsd: Scalars['BigFloat']['output'];
  /** Sum of lockedBalance across the matching connection */
  lockedBalance: Scalars['BigFloat']['output'];
  /** Sum of lockedBalanceValueUsd across the matching connection */
  lockedBalanceValueUsd: Scalars['BigFloat']['output'];
  /** Sum of reputationPoints across the matching connection */
  reputationPoints: Scalars['BigInt']['output'];
  /** Sum of totalBalance across the matching connection */
  totalBalance: Scalars['BigFloat']['output'];
  /** Sum of totalBalanceValueUsd across the matching connection */
  totalBalanceValueUsd: Scalars['BigFloat']['output'];
  /** Sum of unlockedBalance across the matching connection */
  unlockedBalance: Scalars['BigFloat']['output'];
  /** Sum of unlockedBalanceValueUsd across the matching connection */
  unlockedBalanceValueUsd: Scalars['BigFloat']['output'];
  /** Sum of upcomingApyBp across the matching connection */
  upcomingApyBp: Scalars['BigInt']['output'];
};

/** A filter to be used against many `OperatorValidator` object types. All fields are combined with a logical ‘and.’ */
export type ValidatorToManyOperatorValidatorFilter = {
  /** Aggregates across related `OperatorValidator` match the filter criteria. */
  aggregates?: InputMaybe<OperatorValidatorAggregatesFilter>;
  /** Every related `OperatorValidator` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<OperatorValidatorFilter>;
  /** No related `OperatorValidator` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<OperatorValidatorFilter>;
  /** Some related `OperatorValidator` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<OperatorValidatorFilter>;
};

export type ValidatorVariancePopulationAggregates = {
  __typename?: 'ValidatorVariancePopulationAggregates';
  /** Population variance of apyBp across the matching connection */
  apyBp?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of bid across the matching connection */
  bid?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of bidValueUsd across the matching connection */
  bidValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of lockedBalance across the matching connection */
  lockedBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of lockedBalanceValueUsd across the matching connection */
  lockedBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of reputationPoints across the matching connection */
  reputationPoints?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of totalBalance across the matching connection */
  totalBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of totalBalanceValueUsd across the matching connection */
  totalBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of unlockedBalance across the matching connection */
  unlockedBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of unlockedBalanceValueUsd across the matching connection */
  unlockedBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Population variance of upcomingApyBp across the matching connection */
  upcomingApyBp?: Maybe<Scalars['BigFloat']['output']>;
};

export type ValidatorVarianceSampleAggregates = {
  __typename?: 'ValidatorVarianceSampleAggregates';
  /** Sample variance of apyBp across the matching connection */
  apyBp?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of bid across the matching connection */
  bid?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of bidValueUsd across the matching connection */
  bidValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of lockedBalance across the matching connection */
  lockedBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of lockedBalanceValueUsd across the matching connection */
  lockedBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of reputationPoints across the matching connection */
  reputationPoints?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of totalBalance across the matching connection */
  totalBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of totalBalanceValueUsd across the matching connection */
  totalBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of unlockedBalance across the matching connection */
  unlockedBalance?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of unlockedBalanceValueUsd across the matching connection */
  unlockedBalanceValueUsd?: Maybe<Scalars['BigFloat']['output']>;
  /** Sample variance of upcomingApyBp across the matching connection */
  upcomingApyBp?: Maybe<Scalars['BigFloat']['output']>;
};

/** A connection to a list of `Validator` values. */
export type ValidatorsConnection = {
  __typename?: 'ValidatorsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<ValidatorAggregates>;
  /** A list of edges which contains the `Validator` and cursor to aid in pagination. */
  edges: Array<ValidatorsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<ValidatorAggregates>>;
  /** A list of `Validator` objects. */
  nodes: Array<Validator>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Validator` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `Validator` values. */
export type ValidatorsConnectionGroupedAggregatesArgs = {
  groupBy: Array<ValidatorGroupBy>;
  having?: InputMaybe<ValidatorHavingInput>;
};

/** A `Validator` edge in the connection. */
export type ValidatorsEdge = {
  __typename?: 'ValidatorsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Validator` at the end of the edge. */
  node: Validator;
};

/** Methods to use when ordering `Validator`. */
export type ValidatorsOrderBy =
  | 'ALIAS_ASC'
  | 'ALIAS_DESC'
  | 'APY_BP_ASC'
  | 'APY_BP_DESC'
  | 'BID_ASC'
  | 'BID_DESC'
  | 'BID_VALUE_USD_ASC'
  | 'BID_VALUE_USD_DESC'
  | 'BOUND_REDEEM_ADDRESS_ASC'
  | 'BOUND_REDEEM_ADDRESS_DESC'
  | 'ID_HEX_ASC'
  | 'ID_HEX_DESC'
  | 'ID_SS58_ASC'
  | 'ID_SS58_DESC'
  | 'IS_BIDDING_ASC'
  | 'IS_BIDDING_DESC'
  | 'IS_CURRENT_AUTHORITY_ASC'
  | 'IS_CURRENT_AUTHORITY_DESC'
  | 'IS_CURRENT_BACKUP_ASC'
  | 'IS_CURRENT_BACKUP_DESC'
  | 'IS_KEYHOLDER_ASC'
  | 'IS_KEYHOLDER_DESC'
  | 'IS_ONLINE_ASC'
  | 'IS_ONLINE_DESC'
  | 'IS_QUALIFIED_ASC'
  | 'IS_QUALIFIED_DESC'
  | 'LOCKED_BALANCE_ASC'
  | 'LOCKED_BALANCE_DESC'
  | 'LOCKED_BALANCE_VALUE_USD_ASC'
  | 'LOCKED_BALANCE_VALUE_USD_DESC'
  | 'NATURAL'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_AVERAGE_ACTIVE_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_AVERAGE_ACTIVE_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_AVERAGE_BOND_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_AVERAGE_BOND_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_AVERAGE_ID_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_AVERAGE_ID_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_AVERAGE_OPERATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_AVERAGE_OPERATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_AVERAGE_UPCOMING_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_AVERAGE_UPCOMING_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_AVERAGE_VALIDATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_AVERAGE_VALIDATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_COUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_COUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_DISTINCT_COUNT_ACTIVE_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_DISTINCT_COUNT_ACTIVE_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_DISTINCT_COUNT_BOND_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_DISTINCT_COUNT_BOND_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_DISTINCT_COUNT_ID_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_DISTINCT_COUNT_ID_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_DISTINCT_COUNT_OPERATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_DISTINCT_COUNT_OPERATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_DISTINCT_COUNT_UPCOMING_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_DISTINCT_COUNT_UPCOMING_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_DISTINCT_COUNT_VALIDATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_DISTINCT_COUNT_VALIDATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_MAX_ACTIVE_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_MAX_ACTIVE_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_MAX_BOND_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_MAX_BOND_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_MAX_ID_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_MAX_ID_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_MAX_OPERATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_MAX_OPERATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_MAX_UPCOMING_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_MAX_UPCOMING_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_MAX_VALIDATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_MAX_VALIDATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_MIN_ACTIVE_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_MIN_ACTIVE_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_MIN_BOND_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_MIN_BOND_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_MIN_ID_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_MIN_ID_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_MIN_OPERATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_MIN_OPERATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_MIN_UPCOMING_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_MIN_UPCOMING_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_MIN_VALIDATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_MIN_VALIDATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_STDDEV_POPULATION_ACTIVE_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_STDDEV_POPULATION_ACTIVE_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_STDDEV_POPULATION_BOND_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_STDDEV_POPULATION_BOND_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_STDDEV_POPULATION_ID_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_STDDEV_POPULATION_ID_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_STDDEV_POPULATION_OPERATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_STDDEV_POPULATION_OPERATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_STDDEV_POPULATION_UPCOMING_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_STDDEV_POPULATION_UPCOMING_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_STDDEV_POPULATION_VALIDATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_STDDEV_POPULATION_VALIDATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_STDDEV_SAMPLE_ACTIVE_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_STDDEV_SAMPLE_ACTIVE_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_STDDEV_SAMPLE_BOND_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_STDDEV_SAMPLE_BOND_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_STDDEV_SAMPLE_ID_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_STDDEV_SAMPLE_ID_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_STDDEV_SAMPLE_OPERATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_STDDEV_SAMPLE_OPERATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_STDDEV_SAMPLE_UPCOMING_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_STDDEV_SAMPLE_UPCOMING_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_STDDEV_SAMPLE_VALIDATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_STDDEV_SAMPLE_VALIDATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_SUM_ACTIVE_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_SUM_ACTIVE_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_SUM_BOND_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_SUM_BOND_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_SUM_ID_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_SUM_ID_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_SUM_OPERATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_SUM_OPERATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_SUM_UPCOMING_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_SUM_UPCOMING_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_SUM_VALIDATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_SUM_VALIDATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_VARIANCE_POPULATION_ACTIVE_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_VARIANCE_POPULATION_ACTIVE_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_VARIANCE_POPULATION_BOND_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_VARIANCE_POPULATION_BOND_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_VARIANCE_POPULATION_ID_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_VARIANCE_POPULATION_ID_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_VARIANCE_POPULATION_OPERATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_VARIANCE_POPULATION_OPERATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_VARIANCE_POPULATION_UPCOMING_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_VARIANCE_POPULATION_UPCOMING_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_VARIANCE_POPULATION_VALIDATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_VARIANCE_POPULATION_VALIDATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_VARIANCE_SAMPLE_ACTIVE_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_VARIANCE_SAMPLE_ACTIVE_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_VARIANCE_SAMPLE_BOND_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_VARIANCE_SAMPLE_BOND_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_VARIANCE_SAMPLE_ID_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_VARIANCE_SAMPLE_ID_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_VARIANCE_SAMPLE_OPERATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_VARIANCE_SAMPLE_OPERATOR_ID_SS58_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_VARIANCE_SAMPLE_UPCOMING_AMOUNT_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_VARIANCE_SAMPLE_UPCOMING_AMOUNT_DESC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_VARIANCE_SAMPLE_VALIDATOR_ID_SS58_ASC'
  | 'OPERATOR_VALIDATORS_BY_VALIDATOR_ID_SS58_VARIANCE_SAMPLE_VALIDATOR_ID_SS58_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'REPUTATION_POINTS_ASC'
  | 'REPUTATION_POINTS_DESC'
  | 'ROLE_ASC'
  | 'ROLE_DESC'
  | 'TOTAL_BALANCE_ASC'
  | 'TOTAL_BALANCE_DESC'
  | 'TOTAL_BALANCE_VALUE_USD_ASC'
  | 'TOTAL_BALANCE_VALUE_USD_DESC'
  | 'UNLOCKED_BALANCE_ASC'
  | 'UNLOCKED_BALANCE_DESC'
  | 'UNLOCKED_BALANCE_VALUE_USD_ASC'
  | 'UNLOCKED_BALANCE_VALUE_USD_DESC'
  | 'UPCOMING_APY_BP_ASC'
  | 'UPCOMING_APY_BP_DESC';

export type Warning = {
  __typename?: 'Warning';
  blockId?: Maybe<Scalars['String']['output']>;
  message?: Maybe<Scalars['String']['output']>;
};

export type WarningAggregates = {
  __typename?: 'WarningAggregates';
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<WarningDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
};

/** A condition to be used against `Warning` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type WarningCondition = {
  /** Checks for equality with the object’s `blockId` field. */
  blockId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `message` field. */
  message?: InputMaybe<Scalars['String']['input']>;
};

export type WarningDistinctCountAggregates = {
  __typename?: 'WarningDistinctCountAggregates';
  /** Distinct count of blockId across the matching connection */
  blockId?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of message across the matching connection */
  message?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `Warning` object types. All fields are combined with a logical ‘and.’ */
export type WarningFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<WarningFilter>>;
  /** Filter by the object’s `blockId` field. */
  blockId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `message` field. */
  message?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<WarningFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<WarningFilter>>;
};

/** Grouping methods for `Warning` for usage during aggregation. */
export type WarningGroupBy =
  | 'BLOCK_ID'
  | 'MESSAGE';

/** Conditions for `Warning` aggregates. */
export type WarningHavingInput = {
  AND?: InputMaybe<Array<WarningHavingInput>>;
  OR?: InputMaybe<Array<WarningHavingInput>>;
};

/** A connection to a list of `Warning` values. */
export type WarningsConnection = {
  __typename?: 'WarningsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<WarningAggregates>;
  /** A list of edges which contains the `Warning` and cursor to aid in pagination. */
  edges: Array<WarningsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<WarningAggregates>>;
  /** A list of `Warning` objects. */
  nodes: Array<Warning>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Warning` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `Warning` values. */
export type WarningsConnectionGroupedAggregatesArgs = {
  groupBy: Array<WarningGroupBy>;
  having?: InputMaybe<WarningHavingInput>;
};

/** A `Warning` edge in the connection. */
export type WarningsEdge = {
  __typename?: 'WarningsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Warning` at the end of the edge. */
  node: Warning;
};

/** Methods to use when ordering `Warning`. */
export type WarningsOrderBy =
  | 'BLOCK_ID_ASC'
  | 'BLOCK_ID_DESC'
  | 'MESSAGE_ASC'
  | 'MESSAGE_DESC'
  | 'NATURAL';

export type _PrismaMigration = Node & {
  __typename?: '_PrismaMigration';
  appliedStepsCount: Scalars['Int']['output'];
  checksum: Scalars['String']['output'];
  finishedAt?: Maybe<Scalars['Datetime']['output']>;
  id: Scalars['String']['output'];
  logs?: Maybe<Scalars['String']['output']>;
  migrationName: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  rolledBackAt?: Maybe<Scalars['Datetime']['output']>;
  startedAt: Scalars['Datetime']['output'];
};

export type _PrismaMigrationAggregates = {
  __typename?: '_PrismaMigrationAggregates';
  /** Mean average aggregates across the matching connection (ignoring before/after/first/last/offset) */
  average?: Maybe<_PrismaMigrationAverageAggregates>;
  /** Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset) */
  distinctCount?: Maybe<_PrismaMigrationDistinctCountAggregates>;
  keys?: Maybe<Array<Scalars['String']['output']>>;
  /** Maximum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  max?: Maybe<_PrismaMigrationMaxAggregates>;
  /** Minimum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  min?: Maybe<_PrismaMigrationMinAggregates>;
  /** Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevPopulation?: Maybe<_PrismaMigrationStddevPopulationAggregates>;
  /** Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset) */
  stddevSample?: Maybe<_PrismaMigrationStddevSampleAggregates>;
  /** Sum aggregates across the matching connection (ignoring before/after/first/last/offset) */
  sum?: Maybe<_PrismaMigrationSumAggregates>;
  /** Population variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  variancePopulation?: Maybe<_PrismaMigrationVariancePopulationAggregates>;
  /** Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset) */
  varianceSample?: Maybe<_PrismaMigrationVarianceSampleAggregates>;
};

export type _PrismaMigrationAverageAggregates = {
  __typename?: '_PrismaMigrationAverageAggregates';
  /** Mean average of appliedStepsCount across the matching connection */
  appliedStepsCount?: Maybe<Scalars['BigFloat']['output']>;
};

/**
 * A condition to be used against `_PrismaMigration` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type _PrismaMigrationCondition = {
  /** Checks for equality with the object’s `appliedStepsCount` field. */
  appliedStepsCount?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `checksum` field. */
  checksum?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `finishedAt` field. */
  finishedAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `logs` field. */
  logs?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `migrationName` field. */
  migrationName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `rolledBackAt` field. */
  rolledBackAt?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `startedAt` field. */
  startedAt?: InputMaybe<Scalars['Datetime']['input']>;
};

export type _PrismaMigrationDistinctCountAggregates = {
  __typename?: '_PrismaMigrationDistinctCountAggregates';
  /** Distinct count of appliedStepsCount across the matching connection */
  appliedStepsCount?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of checksum across the matching connection */
  checksum?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of finishedAt across the matching connection */
  finishedAt?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of id across the matching connection */
  id?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of logs across the matching connection */
  logs?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of migrationName across the matching connection */
  migrationName?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of rolledBackAt across the matching connection */
  rolledBackAt?: Maybe<Scalars['BigInt']['output']>;
  /** Distinct count of startedAt across the matching connection */
  startedAt?: Maybe<Scalars['BigInt']['output']>;
};

/** A filter to be used against `_PrismaMigration` object types. All fields are combined with a logical ‘and.’ */
export type _PrismaMigrationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<_PrismaMigrationFilter>>;
  /** Filter by the object’s `appliedStepsCount` field. */
  appliedStepsCount?: InputMaybe<IntFilter>;
  /** Filter by the object’s `checksum` field. */
  checksum?: InputMaybe<StringFilter>;
  /** Filter by the object’s `finishedAt` field. */
  finishedAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<StringFilter>;
  /** Filter by the object’s `logs` field. */
  logs?: InputMaybe<StringFilter>;
  /** Filter by the object’s `migrationName` field. */
  migrationName?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<_PrismaMigrationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<_PrismaMigrationFilter>>;
  /** Filter by the object’s `rolledBackAt` field. */
  rolledBackAt?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `startedAt` field. */
  startedAt?: InputMaybe<DatetimeFilter>;
};

export type _PrismaMigrationMaxAggregates = {
  __typename?: '_PrismaMigrationMaxAggregates';
  /** Maximum of appliedStepsCount across the matching connection */
  appliedStepsCount?: Maybe<Scalars['Int']['output']>;
  /** Maximum of finishedAt across the matching connection */
  finishedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Maximum of rolledBackAt across the matching connection */
  rolledBackAt?: Maybe<Scalars['Datetime']['output']>;
  /** Maximum of startedAt across the matching connection */
  startedAt?: Maybe<Scalars['Datetime']['output']>;
};

export type _PrismaMigrationMinAggregates = {
  __typename?: '_PrismaMigrationMinAggregates';
  /** Minimum of appliedStepsCount across the matching connection */
  appliedStepsCount?: Maybe<Scalars['Int']['output']>;
  /** Minimum of finishedAt across the matching connection */
  finishedAt?: Maybe<Scalars['Datetime']['output']>;
  /** Minimum of rolledBackAt across the matching connection */
  rolledBackAt?: Maybe<Scalars['Datetime']['output']>;
  /** Minimum of startedAt across the matching connection */
  startedAt?: Maybe<Scalars['Datetime']['output']>;
};

export type _PrismaMigrationStddevPopulationAggregates = {
  __typename?: '_PrismaMigrationStddevPopulationAggregates';
  /** Population standard deviation of appliedStepsCount across the matching connection */
  appliedStepsCount?: Maybe<Scalars['BigFloat']['output']>;
};

export type _PrismaMigrationStddevSampleAggregates = {
  __typename?: '_PrismaMigrationStddevSampleAggregates';
  /** Sample standard deviation of appliedStepsCount across the matching connection */
  appliedStepsCount?: Maybe<Scalars['BigFloat']['output']>;
};

export type _PrismaMigrationSumAggregates = {
  __typename?: '_PrismaMigrationSumAggregates';
  /** Sum of appliedStepsCount across the matching connection */
  appliedStepsCount: Scalars['BigInt']['output'];
};

export type _PrismaMigrationVariancePopulationAggregates = {
  __typename?: '_PrismaMigrationVariancePopulationAggregates';
  /** Population variance of appliedStepsCount across the matching connection */
  appliedStepsCount?: Maybe<Scalars['BigFloat']['output']>;
};

export type _PrismaMigrationVarianceSampleAggregates = {
  __typename?: '_PrismaMigrationVarianceSampleAggregates';
  /** Sample variance of appliedStepsCount across the matching connection */
  appliedStepsCount?: Maybe<Scalars['BigFloat']['output']>;
};

/** A connection to a list of `_PrismaMigration` values. */
export type _PrismaMigrationsConnection = {
  __typename?: '_PrismaMigrationsConnection';
  /** Aggregates across the matching connection (ignoring before/after/first/last/offset) */
  aggregates?: Maybe<_PrismaMigrationAggregates>;
  /** A list of edges which contains the `_PrismaMigration` and cursor to aid in pagination. */
  edges: Array<_PrismaMigrationsEdge>;
  /** Grouped aggregates across the matching connection (ignoring before/after/first/last/offset) */
  groupedAggregates?: Maybe<Array<_PrismaMigrationAggregates>>;
  /** A list of `_PrismaMigration` objects. */
  nodes: Array<_PrismaMigration>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `_PrismaMigration` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};


/** A connection to a list of `_PrismaMigration` values. */
export type _PrismaMigrationsConnectionGroupedAggregatesArgs = {
  groupBy: Array<_PrismaMigrationsGroupBy>;
  having?: InputMaybe<_PrismaMigrationsHavingInput>;
};

/** A `_PrismaMigration` edge in the connection. */
export type _PrismaMigrationsEdge = {
  __typename?: '_PrismaMigrationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `_PrismaMigration` at the end of the edge. */
  node: _PrismaMigration;
};

/** Grouping methods for `_PrismaMigration` for usage during aggregation. */
export type _PrismaMigrationsGroupBy =
  | 'APPLIED_STEPS_COUNT'
  | 'CHECKSUM'
  | 'FINISHED_AT'
  | 'FINISHED_AT_TRUNCATED_TO_DAY'
  | 'FINISHED_AT_TRUNCATED_TO_HOUR'
  | 'FINISHED_AT_TRUNCATED_TO_MONTH'
  | 'FINISHED_AT_TRUNCATED_TO_WEEK'
  | 'LOGS'
  | 'MIGRATION_NAME'
  | 'ROLLED_BACK_AT'
  | 'ROLLED_BACK_AT_TRUNCATED_TO_DAY'
  | 'ROLLED_BACK_AT_TRUNCATED_TO_HOUR'
  | 'ROLLED_BACK_AT_TRUNCATED_TO_MONTH'
  | 'ROLLED_BACK_AT_TRUNCATED_TO_WEEK'
  | 'STARTED_AT'
  | 'STARTED_AT_TRUNCATED_TO_DAY'
  | 'STARTED_AT_TRUNCATED_TO_HOUR'
  | 'STARTED_AT_TRUNCATED_TO_MONTH'
  | 'STARTED_AT_TRUNCATED_TO_WEEK';

export type _PrismaMigrationsHavingAverageInput = {
  appliedStepsCount?: InputMaybe<HavingIntFilter>;
  finishedAt?: InputMaybe<HavingDatetimeFilter>;
  rolledBackAt?: InputMaybe<HavingDatetimeFilter>;
  startedAt?: InputMaybe<HavingDatetimeFilter>;
};

export type _PrismaMigrationsHavingDistinctCountInput = {
  appliedStepsCount?: InputMaybe<HavingIntFilter>;
  finishedAt?: InputMaybe<HavingDatetimeFilter>;
  rolledBackAt?: InputMaybe<HavingDatetimeFilter>;
  startedAt?: InputMaybe<HavingDatetimeFilter>;
};

/** Conditions for `_PrismaMigration` aggregates. */
export type _PrismaMigrationsHavingInput = {
  AND?: InputMaybe<Array<_PrismaMigrationsHavingInput>>;
  OR?: InputMaybe<Array<_PrismaMigrationsHavingInput>>;
  average?: InputMaybe<_PrismaMigrationsHavingAverageInput>;
  distinctCount?: InputMaybe<_PrismaMigrationsHavingDistinctCountInput>;
  max?: InputMaybe<_PrismaMigrationsHavingMaxInput>;
  min?: InputMaybe<_PrismaMigrationsHavingMinInput>;
  stddevPopulation?: InputMaybe<_PrismaMigrationsHavingStddevPopulationInput>;
  stddevSample?: InputMaybe<_PrismaMigrationsHavingStddevSampleInput>;
  sum?: InputMaybe<_PrismaMigrationsHavingSumInput>;
  variancePopulation?: InputMaybe<_PrismaMigrationsHavingVariancePopulationInput>;
  varianceSample?: InputMaybe<_PrismaMigrationsHavingVarianceSampleInput>;
};

export type _PrismaMigrationsHavingMaxInput = {
  appliedStepsCount?: InputMaybe<HavingIntFilter>;
  finishedAt?: InputMaybe<HavingDatetimeFilter>;
  rolledBackAt?: InputMaybe<HavingDatetimeFilter>;
  startedAt?: InputMaybe<HavingDatetimeFilter>;
};

export type _PrismaMigrationsHavingMinInput = {
  appliedStepsCount?: InputMaybe<HavingIntFilter>;
  finishedAt?: InputMaybe<HavingDatetimeFilter>;
  rolledBackAt?: InputMaybe<HavingDatetimeFilter>;
  startedAt?: InputMaybe<HavingDatetimeFilter>;
};

export type _PrismaMigrationsHavingStddevPopulationInput = {
  appliedStepsCount?: InputMaybe<HavingIntFilter>;
  finishedAt?: InputMaybe<HavingDatetimeFilter>;
  rolledBackAt?: InputMaybe<HavingDatetimeFilter>;
  startedAt?: InputMaybe<HavingDatetimeFilter>;
};

export type _PrismaMigrationsHavingStddevSampleInput = {
  appliedStepsCount?: InputMaybe<HavingIntFilter>;
  finishedAt?: InputMaybe<HavingDatetimeFilter>;
  rolledBackAt?: InputMaybe<HavingDatetimeFilter>;
  startedAt?: InputMaybe<HavingDatetimeFilter>;
};

export type _PrismaMigrationsHavingSumInput = {
  appliedStepsCount?: InputMaybe<HavingIntFilter>;
  finishedAt?: InputMaybe<HavingDatetimeFilter>;
  rolledBackAt?: InputMaybe<HavingDatetimeFilter>;
  startedAt?: InputMaybe<HavingDatetimeFilter>;
};

export type _PrismaMigrationsHavingVariancePopulationInput = {
  appliedStepsCount?: InputMaybe<HavingIntFilter>;
  finishedAt?: InputMaybe<HavingDatetimeFilter>;
  rolledBackAt?: InputMaybe<HavingDatetimeFilter>;
  startedAt?: InputMaybe<HavingDatetimeFilter>;
};

export type _PrismaMigrationsHavingVarianceSampleInput = {
  appliedStepsCount?: InputMaybe<HavingIntFilter>;
  finishedAt?: InputMaybe<HavingDatetimeFilter>;
  rolledBackAt?: InputMaybe<HavingDatetimeFilter>;
  startedAt?: InputMaybe<HavingDatetimeFilter>;
};

/** Methods to use when ordering `_PrismaMigration`. */
export type _PrismaMigrationsOrderBy =
  | 'APPLIED_STEPS_COUNT_ASC'
  | 'APPLIED_STEPS_COUNT_DESC'
  | 'CHECKSUM_ASC'
  | 'CHECKSUM_DESC'
  | 'FINISHED_AT_ASC'
  | 'FINISHED_AT_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'LOGS_ASC'
  | 'LOGS_DESC'
  | 'MIGRATION_NAME_ASC'
  | 'MIGRATION_NAME_DESC'
  | 'NATURAL'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC'
  | 'ROLLED_BACK_AT_ASC'
  | 'ROLLED_BACK_AT_DESC'
  | 'STARTED_AT_ASC'
  | 'STARTED_AT_DESC';

export type GetBatchQueryVariables = Exact<{
  height: Scalars['Int']['input'];
  limit: Scalars['Int']['input'];
  swapEvents: Array<Scalars['String']['input']> | Scalars['String']['input'];
}>;


export type GetBatchQuery = { __typename?: 'Query', blocks?: { __typename?: 'BlocksConnection', nodes: Array<{ __typename?: 'Block', height: number, hash: string, timestamp: any, specId: string, events: { __typename?: 'EventsConnection', nodes: Array<{ __typename?: 'Event', args?: any | null, name: string, indexInBlock: number, callId?: string | null, extrinsicId?: string | null }> } }> } | null };

export type GetCallQueryVariables = Exact<{
  id: Scalars['String']['input'];
}>;


export type GetCallQuery = { __typename?: 'Query', call?: { __typename?: 'Call', args?: any | null } | null };

export type GetExtrinsicQueryVariables = Exact<{
  id: Scalars['String']['input'];
}>;


export type GetExtrinsicQuery = { __typename?: 'Query', extrinsic?: { __typename?: 'Extrinsic', signature?: any | null } | null };


export const GetBatchDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetBatch"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"height"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"limit"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}}},{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"swapEvents"}},"type":{"kind":"NonNullType","type":{"kind":"ListType","type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","alias":{"kind":"Name","value":"blocks"},"name":{"kind":"Name","value":"allBlocks"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"filter"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"height"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"greaterThanOrEqualTo"},"value":{"kind":"Variable","name":{"kind":"Name","value":"height"}}}]}}]}},{"kind":"Argument","name":{"kind":"Name","value":"first"},"value":{"kind":"Variable","name":{"kind":"Name","value":"limit"}}},{"kind":"Argument","name":{"kind":"Name","value":"orderBy"},"value":{"kind":"EnumValue","value":"HEIGHT_ASC"}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"nodes"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"height"}},{"kind":"Field","name":{"kind":"Name","value":"hash"}},{"kind":"Field","name":{"kind":"Name","value":"timestamp"}},{"kind":"Field","name":{"kind":"Name","value":"specId"}},{"kind":"Field","alias":{"kind":"Name","value":"events"},"name":{"kind":"Name","value":"eventsByBlockId"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"filter"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"name"},"value":{"kind":"ObjectValue","fields":[{"kind":"ObjectField","name":{"kind":"Name","value":"in"},"value":{"kind":"Variable","name":{"kind":"Name","value":"swapEvents"}}}]}}]}},{"kind":"Argument","name":{"kind":"Name","value":"orderBy"},"value":{"kind":"EnumValue","value":"INDEX_IN_BLOCK_ASC"}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"nodes"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"args"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"indexInBlock"}},{"kind":"Field","name":{"kind":"Name","value":"callId"}},{"kind":"Field","name":{"kind":"Name","value":"extrinsicId"}}]}}]}}]}}]}}]}}]} as unknown as DocumentNode<GetBatchQuery, GetBatchQueryVariables>;
export const GetCallDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetCall"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"id"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","alias":{"kind":"Name","value":"call"},"name":{"kind":"Name","value":"callById"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"id"},"value":{"kind":"Variable","name":{"kind":"Name","value":"id"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"args"}}]}}]}}]} as unknown as DocumentNode<GetCallQuery, GetCallQueryVariables>;
export const GetExtrinsicDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"GetExtrinsic"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"id"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","alias":{"kind":"Name","value":"extrinsic"},"name":{"kind":"Name","value":"extrinsicById"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"id"},"value":{"kind":"Variable","name":{"kind":"Name","value":"id"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"signature"}}]}}]}}]} as unknown as DocumentNode<GetExtrinsicQuery, GetExtrinsicQueryVariables>;